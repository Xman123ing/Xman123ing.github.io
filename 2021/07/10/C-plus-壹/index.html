<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="C-plus-壹, 中国地质大学(武汉)2008-2012 Asia亚信 IFly科大讯飞 OPPO">
    <meta name="description" content="技术分享 | C/C++ | 服务器后端 | 计算机系统 | 嵌入式系统 | FreeRTOS | SensorHub">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C-plus-壹 | IPanda`s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/css/prism-dark.css" type="text/css"></head>
<link rel="stylesheet" href="/js/prism/prism.css">




<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">IPanda`s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">IPanda`s Blog</div>
        <div class="logo-desc">
            
            技术分享 | C/C++ | 服务器后端 | 计算机系统 | 嵌入式系统 | FreeRTOS | SensorHub
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Xman123ing/Xman123ing.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Xman123ing/Xman123ing.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C-plus-壹</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                summary && 技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-10
                </div>
                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="3、模板编程"><a href="#3、模板编程" class="headerlink" title="3、模板编程"></a>3、模板编程</h1><p>C++语言 = C语言的超集 + 抽象机制 + 标准库   </p>
<p><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE4494d1a8eae1462fca4d359eba57a220/38285" alt="image01"></p>
<h2 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h2><p>作为C++语言重要组成部分之一的抽象机制(Abstraction mechanisms)主要有两种：</p>
<ul>
<li>面向对象编程Object-oriented programming；</li>
<li>模板编程generic programming；</li>
</ul>
<p>为了实现面向对象编程，C++提供了类。在模板编程方面，C++提供了模板(Template)，以一种直观的方式表示<strong>通用概念</strong>generic concept。   </p>
<p>模板编程的应用主要有两种：</p>
<ul>
<li>泛型编程generic programming；</li>
<li>元编程metaprogramming；</li>
</ul>
<p>前者注重于通用概念的抽象，用于设计<strong>通用的类型、算法</strong>；<br>后者注重于设计模板推导时的选择selection和迭代iteration；</p>
<h2 id="3-2、泛型编程"><a href="#3-2、泛型编程" class="headerlink" title="3.2、泛型编程"></a>3.2、泛型编程</h2><p>依赖于语言自身提供的模板机制   </p>
<p>狭义的泛型编程主要是两类：</p>
<ul>
<li>类模板class template；</li>
<li>函数模板function template；</li>
</ul>
<p>二者能够产生新的类型，属于<strong>类型构造器</strong>type constructor，分别用于定义具有相似功能的类和函数，是泛型中对类型和算法的抽象。   </p>
<p>无论是函数模板还是类模板，在实际代码中看起来都是”千变万化”的。这些”变化”，主要是因为类型被当做了参数，导致代码中可以变化的部分更多了。</p>
<p>归根结底，模板无外乎两点：</p>
<ul>
<li>函数或者类里面，有一些类型我们希望它能变化一下，我们用标识符来代替它，这就是”模板参数”；</li>
<li>在需要这些类型的地方，写上相对应的标识符（”模板参数”）。</li>
</ul>
<p>当然，这里的”可变”实际上在代码编译好后就固定下来了，也称之为编译期的可变性。</p>
<h3 id="3-2-1、类模板"><a href="#3-2-1、类模板" class="headerlink" title="3.2.1、类模板"></a>3.2.1、类模板</h3><p>类模板定义：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt; class CA
&#123;
    T member;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>template是C++关键字，意味着模板定义的开始。<br>与函数类似，模板也有一系列参数，这些参数被囊括在template之后的&lt;&gt;中，例如上文中的typename T，称之为模板参数。T是模板的精髓，可以通过指定模板实参，将T替换为所需要的实际类型，例如用CA<int>来实例化模板类CA，等价于以下的代码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class CA
&#123;
    int member;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>可以看出，用实际类型替换模板参数，可以获得很多形式相同的类型，有效的减少了代码量。这种用法，我们称之为”泛型”Generic Programming，它最常见的应用即是STL容器模板类。</strong></p>
<h3 id="3-2-2、类模板的使用"><a href="#3-2-2、类模板的使用" class="headerlink" title="3.2.2、类模板的使用"></a>3.2.2、类模板的使用</h3><p>对于C++来说，类型最重要的作用之一就是用它去产生一个变量。例如我们定义了一个动态数组的模板类vector，它对于任意的元素类型都具有push_back和clear的操作，我们便可以如下定义这个类：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt;
class vector
&#123;
public:
    void push_back(T const&amp;);
    void clear();				
	
private:
    T* elements;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时我们的程序需要一个整型和一个浮点型的vector，那么便可以通过以下代码获得两个变量：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">vector&lt;int&gt; intArray;
vector&lt;float&gt; floatArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>变量定义的过程可以分成两步来看：第一步，vector<int>将int绑定到模板类vector上，获得了一个”普通的类vector<int>“；第二步通过”vector”定义了一个变量。   </p>
<p><strong>通过类型绑定将模板类变成”普通的类”的过程，称之为模板实例化(Template Instantiate)</strong></p>
<h3 id="3-2-3、类模板的成员函数定义"><a href="#3-2-3、类模板的成员函数定义" class="headerlink" title="3.2.3、类模板的成员函数定义"></a>3.2.3、类模板的成员函数定义</h3><p>如果成员函数定义放在模板类内，则实现方法与普通类的成员函数一致，如果在类外实现，语法上略显复杂：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt;
class vector
&#123;
public:
    void clear();  &#x2F;&#x2F; 注意这里只有声明
private:
    T* elements;
&#125;;

template &lt;typename T&gt;
void vector&lt;T&gt;::clear()  &#x2F;&#x2F; 函数的实现放在这里
&#123;
    &#x2F;&#x2F; Function body
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-4、函数模板"><a href="#3-2-4、函数模板" class="headerlink" title="3.2.4、函数模板"></a>3.2.4、函数模板</h3><p>函数模板的语法及使用与类模板基本一致</p>
<h3 id="3-2-5、整形作为模板参数"><a href="#3-2-5、整形作为模板参数" class="headerlink" title="3.2.5、整形作为模板参数"></a>3.2.5、整形作为模板参数</h3><p>模板参数除了是待定类型typename T之外，也可以是一个确切的整型类型（Integral Number），这里的整型数比较宽泛，包括布尔型，有/无符号的整型，甚至包括指针：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt; class TemplateWithType;  &#x2F;&#x2F; 普通模板参数
template &lt;int      V&gt; class TemplateWithValue;  &#x2F;&#x2F; 整型模板参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>按照C++ Template最初的想法，模板不就是为了提供一个类型安全、易于调试的宏吗？有类型就够了，为什么要引入整型参数呢？考虑到宏除了代码替换功能外，还有一个作用是作为常数出现，所以整型模板参数最基本的用途就是定义一个常数。例如这段代码的作用：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T, int Size&gt; struct Array
&#123;
    T data[Size];
&#125;;

Array&lt;int, 16&gt; arr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于模板的匹配是在编译时完成，所以实例化模板的时候所使用的整型参数也必须要在编译期就能确定，必须是编译期常量。</p>
<h3 id="3-2-6、模板别名与模板实例化别名"><a href="#3-2-6、模板别名与模板实例化别名" class="headerlink" title="3.2.6、模板别名与模板实例化别名"></a>3.2.6、模板别名与模板实例化别名</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;
class AddMethod
&#123;
public:
    AddMethod(T num)&#123;std::cout &lt;&lt; &quot;constructer: &quot; &lt;&lt; num &lt;&lt; std::endl;&#125;
    ~AddMethod()&#123;std::cout &lt;&lt; &quot;destructer: &quot; &lt;&lt; std::endl;&#125;

    T a_;
    T b_;
&#125;;

&#x2F;&#x2F; 模板实例化别名
typedef AddMethod&lt;int32_t&gt; AddMethodInt;
typedef AddMethod&lt;float&gt; AddMethodFloat;

&#x2F;&#x2F; 模板别名
template&lt;typename T&gt;
using mapstr &#x3D; std::map&lt;T, std::string&gt;;

template&lt;typename T&gt;
void swap(T a_, T b_)
&#123;
    std::cout &lt;&lt; &quot;swap&quot; &lt;&lt; a_ &lt;&lt; &quot;, &quot; &lt;&lt; b_ &lt;&lt; std::endl;
&#125;

&#x2F;&#x2F;typedef swap&lt;int32_t&gt; swap_int;  &#x2F;&#x2F; 报错，提示函数模板swap不是类型名，因为typedef是为类型设置别名，而函数并不是类型

int main()
&#123;
    AddMethodInt add01(0);
    AddMethodFloat add02(1);

    mapstr&lt;int32_t&gt; map01;
    map01[0] &#x3D; &quot;Lisa&quot;;
    std::cout &lt;&lt; &quot;map[0] &#x3D; &quot; &lt;&lt; map01[0] &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>模板别名和模板实例化别名只适用于类模板，因为typedef、using是设置类型的别名，而函数并不属于类型；</li>
<li>mapstr定义了一类以string为value的map容器；</li>
</ul>
<h2 id="3-3、STL"><a href="#3-3、STL" class="headerlink" title="3.3、STL"></a>3.3、STL</h2><ul>
<li><strong>顺序容器</strong><br>顾名思义，就是以线性方式存储数据的容器，如数组、vector、列表、dequeue，顺序容器通常具有插入速度快（多是在首位的插入删除），但查找速度慢的特点。’顺序’并不是指内存空间的连续，而是在内存空间上具有线性关系；</li>
<li><strong>关联容器</strong><br>以特殊相关性存储数据的容器，这将降低插入速度，但是在查找速度方面有很大优势。’特定相关性’包括排序、hash_table、无序；</li>
</ul>
<h3 id="3-3-1、顺序容器"><a href="#3-3-1、顺序容器" class="headerlink" title="3.3.1、顺序容器"></a>3.3.1、顺序容器</h3><p>包括：<br>std::vector—–动态数组类，与操作数组一样，在最后插入数据<br>std::deque—-与std::vector类似，但允许在开头插入或删除数据<br>std::list—-链表类，操作与双向链表一样，可在任何位置添加或删除对象<br>std::forward_list—-与std::list类似，但是单向链表，只能沿一个方向遍历<br>std::vector是动态数组，可以根据需求动态调整长度，可能同时伴随内存空间的再分配，因此需要频繁调整长度的vector通常会降低程序性能；     </p>
<p><strong>容器的选择</strong>：<br>vector:<br>优点：在末尾插入数据，速度快且固定，可以像数组一样访问；<br>缺点：调整大小时将影响性能，查询时间与容器元素个数成正比，只能在末尾插入；   </p>
<p>list:<br>优点：可在任意位置插入、删除数据，所需时间固定；<br>缺点：不能像数组一样随机访问，查询速度比vector慢，因为不是存储在连续内存中，查询时间与容器元素个数成正比；    </p>
<h3 id="3-3-2、关联容器"><a href="#3-3-2、关联容器" class="headerlink" title="3.3.2、关联容器"></a>3.3.2、关联容器</h3><p>包括：<br>std::set—–集合类，存储不同的值，插入时进行排序，时间复杂度为对数<br>std::unordered_set—–存储不同的值，插入时不排序，时间复杂度为对数<br>std::map—–映射类，存储键值-对，并根据唯一的键排序，时间复杂度为对数<br>std::unordered_map—–存储键值-对，不排序，时间复杂度为对数<br>std::multiset—–与set类似，但允许重复值<br>std::unordered_multiset—–与unordered_set类似，但允许重复值<br>std::multimap—–与map类似，但允许重复值<br>std::unordered_multimap—–与unordered_map类似，但允许重复值   </p>
<p><strong>容器的选择</strong>：<br>set\map：<br>优点：查询时间与元素个数的对数成正比，查询速度快于顺序容器；<br>缺点：插入时进行排序，因此插入速度很慢，元素键值要唯一；   </p>
<p>unordered_set\unordered_map：<br>优点：查询、插入、删除速度不受元素个数影响；<br>缺点：不对元素进行排序，元素键值要唯一；   </p>
<p>multiset\multimap：<br>优点：存储非唯一键值，查询时间与元素个数的对数成正比，查询速度快于顺序容器；<br>缺点：插入时进行排序，因此插入速度很慢；   </p>
<p>unordered_multiset\unordered_multimap：<br>优点：存储非唯一键值，查询、插入、删除速度不受元素个数影响；<br>缺点：不对元素进行排序；  </p>
<p><strong>总结</strong>：<br>1、对于map和set容器而言，其查找速度确实比vector和list要快，但他们本身的时间复杂度为对数，即仍然会随着元素数的增加，查询速度会下降，比如元素数从10000减少到100时，速度提升一倍；<br>2、虽然对数时间复杂度已相当不错，但还有速度更好，且插入和查询时间固定的容器，即unordered类容器（散列容器）   </p>
<h3 id="3-3-3、capacity与size"><a href="#3-3-3、capacity与size" class="headerlink" title="3.3.3、capacity与size"></a>3.3.3、capacity与size</h3><ul>
<li>capacity容量，指为容器分配的内存空间；</li>
<li>size元素数量，指容器中已使用的内存空间；</li>
</ul>
<p><strong>引申</strong>：<br>vector访问元素范围越界问题指的是size越界，但越界并不一定会引起程序崩溃，因为：</p>
<ul>
<li>此时越界的size可能并未超过capcacity，size &lt; n &lt; capacity内存区间已分配，只是并未初始化而已，所以不会引起程序崩溃；</li>
<li>只有当超过capacity且是未分配的内存空间才会引起程序的不确定行为；</li>
</ul>
<h3 id="3-3-4、std-vector动态数组"><a href="#3-3-4、std-vector动态数组" class="headerlink" title="3.3.4、std::vector动态数组"></a>3.3.4、std::vector动态数组</h3><ul>
<li>在数组末尾插入、删除元素时间固定，与数组元素数量无关；    </li>
<li>在数组中间添加、删除元素所需时间与该元素后的元素数量成正比；</li>
<li>vector的元素在内存中连续存放；</li>
</ul>
<h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;

int main ()
&#123;
  std::vector &lt;int&gt; vecIntegers;

   &#x2F;&#x2F; Instantiate a vector with 10 elements (it can grow larger)
   std::vector &lt;int&gt; vecWithTenElements (10);

   &#x2F;&#x2F; Instantiate a vector with 10 elements, each initialized to 90
   std::vector &lt;int&gt; vecWithTenInitializedElements (10, 90);

   &#x2F;&#x2F; Instantiate one vector and initialize it to the contents of another
   std::vector &lt;int&gt; vecArrayCopy (vecWithTenInitializedElements);

   &#x2F;&#x2F; Use iterators and instantiate a vector to 5 elements taken from another
   std::vector &lt;int&gt; vecSomeElementsCopied ( vecWithTenElements.cbegin ()
                           , vecWithTenElements.cbegin () + 5 );
   &#x2F;&#x2F; 数组初始化列表的方式
   std::vector &lt;int&gt; vecArrayCopy &#x3D; &#123;10，20,3,30,50&#125;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h4><ul>
<li>push_back在末尾插入；</li>
<li>emplace_back在末尾插入，接收右值引用实参，可以避免不必要的内存操作；</li>
<li>insert在指定位置插入，但效率极低，通常不会使用；</li>
</ul>
<h4 id="3、访问"><a href="#3、访问" class="headerlink" title="3、访问"></a>3、访问</h4><ul>
<li>数组下标形式访问vector[i]；</li>
<li>at()函数访问vector.at(i)，会检查地址越界问题；</li>
<li>迭代器访问；</li>
</ul>
<h4 id="4、删除元素"><a href="#4、删除元素" class="headerlink" title="4、删除元素"></a>4、删除元素</h4><ul>
<li>pop_back末尾删除;</li>
<li>erase指定位置删除，iterator作为参数，但效率极低，通常不会使用；</li>
</ul>
<h4 id="5、插入与删除的迭代器失效问题"><a href="#5、插入与删除的迭代器失效问题" class="headerlink" title="5、插入与删除的迭代器失效问题"></a>5、插入与删除的迭代器失效问题</h4><p>vector删除元素时，被删除元素及之后的迭代器会失效，这是因为</p>
<ul>
<li>vector在内存中是连续存放的；</li>
<li>非末尾位置插入与删除操作都会引起当前位置及之后元素的移动，<br>甚至当插入操作超过capacity时更会引起vector的整体移动；</li>
<li>通过源码可以看出，当迭代器发生移动的时候，其内部的指针并没有更新，此时对该指针的相关操作就会出现内存访问异常的可能，此现象称作迭代器失效；</li>
</ul>
<h4 id="6、vector的扩容机制"><a href="#6、vector的扩容机制" class="headerlink" title="6、vector的扩容机制"></a>6、vector的扩容机制</h4><ul>
<li>vector默认初始化的size、capacity都为0；</li>
<li>插入时，若size = 0，扩容size为1；</li>
<li>插入时，若size != 0，则两倍 2 * size 扩容；</li>
</ul>
<h4 id="7、负载因子"><a href="#7、负载因子" class="headerlink" title="7、负载因子"></a>7、负载因子</h4><p><code>DEFAULT_LOAD_FACTOR</code> 负载因子：默认值为0.75。 当元素的总个数&gt;当前数组的容量 * 负载因子。数组会进行扩容，扩容为原来的两倍，扩容机制详见第</p>
<h4 id="8、clear、swap、resize、reserve、shrink-to-fit"><a href="#8、clear、swap、resize、reserve、shrink-to-fit" class="headerlink" title="8、clear、swap、resize、reserve、shrink_to_fit"></a>8、clear、swap、resize、reserve、shrink_to_fit</h4><ul>
<li>clear清空容器的size，相当于反初始化，对capacity没有影响，容器此时仍占有内存空间，并未释放；</li>
<li>swap，与另一个容器交换size和capacity，相当于指针交换，两个容器所在的内存空间并未变化；</li>
<li>resize调整容器的size，n为当前容器的size，m为目标size   <ul>
<li>当m &gt; n时，size扩容为m，同时可以指定扩容的部分初始值为t,   resize(m,t);</li>
<li>当m &lt; n时，size会缩减为m，被缩减的部分相当于反初始化；</li>
</ul>
</li>
<li>reserve调整容器容量，只有当目标容量大于当前容量操作才会生效,扩容操作通常会由编译器自动完成，规则由编译器决定，比如g++是2倍扩容规则；</li>
<li>shrink_to_fit裁剪容器，使size = capacity，结合clear可以释放容器；</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;vector&gt;
int main()
&#123;
    std::vector&lt;int&gt; vt01(10, 11);
    std::vector&lt;int&gt; vt02(100, 22);

    std::cout &lt;&lt; &quot;*****01*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;

    for (int32_t i &#x3D; 0; i &lt; 100; ++i) &#123;
        vt01.push_back(i);
    &#125;
    for (int32_t i &#x3D; 0; i &lt; 1000; ++i) &#123;
        vt02.push_back(i);
    &#125; 
    
    std::cout &lt;&lt; &quot;\n*****02*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;

    &#x2F;&#x2F; reserve
    vt01.reserve(200);
    std::cout &lt;&lt; &quot;\n*****03*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    
    vt01.reserve(20);
    std::cout &lt;&lt; &quot;\n*****04*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    
    &#x2F;&#x2F; resize
    vt01.resize(200);
    std::cout &lt;&lt; &quot;\n*****05*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;

    vt01.resize(20);
    std::cout &lt;&lt; &quot;\n*****06*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;

    &#x2F;&#x2F; clear
    std::cout &lt;&lt; &quot;\n*****07*****&quot; &lt;&lt; std::endl;
    vt02.clear();
    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;

    &#x2F;&#x2F; swap
    std::cout &lt;&lt; &quot;\n*****08*****&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;before&quot; &lt;&lt; std::endl;
    vt01.resize(100, 11);
    vt02.resize(1000, 22);
    
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;
    
    std::cout &lt;&lt; &quot;after&quot; &lt;&lt; std::endl;
    vt01.swap(vt02);
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;
    

    &#x2F;&#x2F;std::vector&lt;int&gt;().swap(vt01);
    &#x2F;&#x2F; shrink_to_fit
    std::cout &lt;&lt; &quot;\n*****09*****&quot; &lt;&lt; std::endl;
    vt01.shrink_to_fit();  &#x2F;&#x2F; 使size &#x3D; capacity, 释放未使用的内存空间
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    
    std::cout &lt;&lt; &quot;\n*****10*****&quot; &lt;&lt; std::endl;
    &#x2F;&#x2F; 释放vector
    vt01.clear();
    vt01.shrink_to_fit();  &#x2F;&#x2F; 使size &#x3D; capacity, 释放未使用的内存空间
    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">*****01*****
vt01 size &#x3D; 10    capacity &#x3D; 10
vt02 size &#x3D; 100    capacity &#x3D; 100

*****02*****
vt01 size &#x3D; 110    capacity &#x3D; 160
vt02 size &#x3D; 1100    capacity &#x3D; 1600

*****03*****
vt01 size &#x3D; 110    capacity &#x3D; 200

*****04*****
vt01 size &#x3D; 110    capacity &#x3D; 200

*****05*****
vt01 size &#x3D; 200    capacity &#x3D; 200

*****06*****
vt01 size &#x3D; 20    capacity &#x3D; 200

*****07*****
vt02 size &#x3D; 0    capacity &#x3D; 1600

*****08*****
before
vt01 size &#x3D; 100    capacity &#x3D; 200
vt02 size &#x3D; 1000    capacity &#x3D; 1600
after
vt01 size &#x3D; 1000    capacity &#x3D; 1600
vt02 size &#x3D; 100    capacity &#x3D; 200

*****09*****
vt01 size &#x3D; 1000    capacity &#x3D; 1000

*****10*****
vt01 size &#x3D; 0    capacity &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-5、std-list链表"><a href="#3-3-5、std-list链表" class="headerlink" title="3.3.5、std::list链表"></a>3.3.5、std::list链表</h3><p>list是双向链表，可双向遍历，插入、删除速度快，且时间固定。<br>forward_list是单向链表，只能沿一个方向遍历。   </p>
<h4 id="1、初始化-1"><a href="#1、初始化-1" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;list&gt;
#include &lt;vector&gt;

int main ()
&#123;
   using namespace std;

   &#x2F;&#x2F; instantiate an empty list
   list &lt;int&gt; listIntegers;

   &#x2F;&#x2F; instantiate a list with 10 integers 
   list&lt;int&gt; listWith10Integers(10);

   &#x2F;&#x2F; instantiate a list with 4 integers, each initialized to 99
   list&lt;int&gt; listWith4IntegerEach99 (10, 99);

   &#x2F;&#x2F; create an exact copy of an existing list
   list&lt;int&gt; listCopyAnother(listWith4IntegerEach99);

   &#x2F;&#x2F; a vector with 10 integers, each 2011
   vector&lt;int&gt; vecIntegers(10, 2011);

   &#x2F;&#x2F; instantiate a list using values from another container 
   list&lt;int&gt; listContainsCopyOfAnother(vecIntegers.cbegin(), 
                                       vecIntegers.cend());

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2、插入-1"><a href="#2、插入-1" class="headerlink" title="2、插入"></a>2、插入</h4><p>在开头插入元素：push_front<br>在末尾插入元素：push_back<br>在中间插入元素：insert，且有很多重载版本      </p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 版本一
iterator insert(iterator pos, const T&amp; x)   
pos: 插入位置；
x：插入值；


&#x2F;&#x2F; 版本二  
void insert(iterator pos, size_type n,const T&amp; x)   
pos：插入位置；
n：插入元素个数;
x：插入的值；

&#x2F;&#x2F; 版本三   
void insert(iterator pos, otherIterator begin, otherIterator end)   
pos：插入位置；
begin、end：插入起始范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;list&gt;
#include &lt;iostream&gt;

using namespace std;

template &lt;typename T&gt;
void DisplayContents (const T&amp; Input)
&#123;
   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11 
      ; iElement !&#x3D; Input.cend()
      ; ++ iElement )
      cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;

   cout &lt;&lt; endl;
&#125;

int main ()
&#123;
   list &lt;int&gt; listIntegers1;

   &#x2F;&#x2F; Inserting elements at the beginning...
   listIntegers1.insert (listIntegers1.begin (), 2);
   listIntegers1.insert (listIntegers1.begin (), 1);

   &#x2F;&#x2F; Inserting an element at the end...
   listIntegers1.insert (listIntegers1.end (), 3);

   cout &lt;&lt; &quot;The contents of list 1 after inserting elements:&quot; &lt;&lt; endl;
   DisplayContents (listIntegers1);

   list &lt;int&gt; listIntegers2;

   &#x2F;&#x2F; Inserting 4 elements of the same value 0...
   listIntegers2.insert (listIntegers2.begin (), 4, 0);

   cout &lt;&lt; &quot;The contents of list 2 after inserting &#39;&quot;;
   cout &lt;&lt; listIntegers2.size () &lt;&lt; &quot;&#39; elements of a value:&quot; &lt;&lt; endl;
   DisplayContents (listIntegers2);

   list &lt;int&gt; listIntegers3;

   &#x2F;&#x2F; Inserting elements from another list at the beginning...
   listIntegers3.insert (listIntegers3.begin (), 
                    listIntegers1.begin (), listIntegers1.end ());

   cout &lt;&lt; &quot;The contents of list 3 after inserting the contents of &quot;;
   cout &lt;&lt; &quot;list 1 at the beginning:&quot; &lt;&lt; endl;
   DisplayContents (listIntegers3);

   &#x2F;&#x2F; Inserting elements from another list at the end... 
   listIntegers3.insert (listIntegers3.end (), 
                  listIntegers2.begin (), listIntegers2.end ());

   cout &lt;&lt; &quot;The contents of list 3 after inserting &quot;;
   cout &lt;&lt; &quot;the contents of list 2 at the beginning:&quot; &lt;&lt; endl;
   DisplayContents (listIntegers3);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><ul>
<li>erase指定位置删除，iterator作为参数；</li>
<li>remove指定值删除，自定义类型的list需要重载操作符==；</li>
</ul>
<h4 id="4、翻转"><a href="#4、翻转" class="headerlink" title="4、翻转"></a>4、翻转</h4><p>reverse函数</p>
<h4 id="5、sort排序"><a href="#5、sort排序" class="headerlink" title="5、sort排序"></a>5、sort排序</h4><p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/li1615882553/article/details/83216113">STL中关于list容器的sort函数详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/avota/archive/2016/04/13/5388865.html">STL库list::sort()实现深度解析</a>    </p>
<p>list有自己独立的排序函数sort，它与stl的sort类似（详见<strong>13.4.16节</strong>）    </p>
<p>为何list会有独立的sort实现？<br>从源码来看<br><code>STL sort</code>原型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class RandomAccessIterator&gt;
inline void sort(RandomAccessIterator first, RandomAccessIterator last);
template &lt;class RandomAccessIterator, class Compare&gt;
inline void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>list sort</code>原型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef bidirectional_iterator_tag iterator_category;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看出stl sort的迭代器是随机访问RandomAccessIterator，而list sort的迭代器是双向迭代器bidirectional，bidirectional是RandomAccessIterator子类，如果使用stl sort对list进行排序会因向上类型转换，而出现截断的问题</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>list的sort有两个重载版本：</p>
<ul>
<li>默认版本没有参数，自定义类型需要重载运算符&lt;；</li>
<li>接受排序函数作为参数，可以自定义排序方法；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents (const T&amp; Input)
&#123;
   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11 
     ; iElement !&#x3D; Input.cend()
     ; ++ iElement )
     cout &lt;&lt; *iElement &lt;&lt; endl;

   cout &lt;&lt; endl;
&#125;

struct ContactItem
&#123;
   string strContactsName;
   string strPhoneNumber; 
   string strDisplayRepresentation;

   &#x2F;&#x2F; Constructor and destructor
   ContactItem (const string&amp; strName, const string &amp; strNumber)
   &#123;
      strContactsName &#x3D; strName;
      strPhoneNumber &#x3D; strNumber;
      strDisplayRepresentation &#x3D; (strContactsName + &quot;: &quot; + strPhoneNumber);
   &#125;

   &#x2F;&#x2F; used by list::remove() given contact list item
   bool operator &#x3D;&#x3D; (const ContactItem&amp; itemToCompare) const
   &#123;
      return (itemToCompare.strContactsName &#x3D;&#x3D; this-&gt;strContactsName);
   &#125;

   &#x2F;&#x2F; used by list::sort() without parameters
   bool operator &lt; (const ContactItem&amp; itemToCompare) const
   &#123;
      return (this-&gt;strContactsName &lt; itemToCompare.strContactsName);
   &#125;

   &#x2F;&#x2F; Used in DisplayContents via cout
   operator const char*() const
   &#123;
     return strDisplayRepresentation.c_str();
   &#125;
&#125;;

bool SortOnPhoneNumber (const ContactItem&amp; item1, 
                           const ContactItem&amp; item2)
&#123;
   return (item1.strPhoneNumber &lt; item2.strPhoneNumber);
&#125;

int main ()
&#123;
   list &lt;ContactItem&gt; Contacts;
   Contacts.push_back(ContactItem(&quot;Jack Welsch&quot;, &quot;+1 7889 879 879&quot;));
   Contacts.push_back(ContactItem(&quot;Bill Gates&quot;, &quot;+1 97 7897 8799 8&quot;));
   Contacts.push_back(ContactItem(&quot;Angela Merkel&quot;, &quot;+49 23456 5466&quot;));
   Contacts.push_back(ContactItem(&quot;Vladimir Putin&quot;, &quot;+7 6645 4564 797&quot;));
   Contacts.push_back(ContactItem(&quot;Manmohan Singh&quot;, &quot;+91 234 4564 789&quot;));
   Contacts.push_back(ContactItem(&quot;Barack Obama&quot;, &quot;+1 745 641 314&quot;));

   cout &lt;&lt; &quot;List in initial order: &quot; &lt;&lt; endl;
   DisplayContents(Contacts);

   Contacts.sort();
   cout &lt;&lt; &quot;After sorting in alphabetical order via operator&lt;:&quot; &lt;&lt; endl;
   DisplayContents(Contacts);

   Contacts.sort(SortOnPhoneNumber);
   cout &lt;&lt; &quot;After sorting in order of phone numbers via predicate:&quot; &lt;&lt; endl;
   DisplayContents(Contacts);

   cout &lt;&lt; &quot;After erasing Putin from the list: &quot;;
   Contacts.remove(ContactItem(&quot;Vladimir Putin&quot;, &quot;&quot;));
   DisplayContents(Contacts);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-6、deque双端队列"><a href="#3-3-6、deque双端队列" class="headerlink" title="3.3.6、deque双端队列"></a>3.3.6、deque双端队列</h3><p>双端队列（Double-ended queue，缩写为Deque，与list不同，它的底层实现不是链表，而是数组。</p>
<ul>
<li>可以高效的在头、尾两端插入、删除元素；</li>
<li>可以通过数组的方式访问元素；</li>
<li>deque 没有所谓的容量概念，因为它是动态地以分段连续空间组合而成随时可以增加一块新的空间并拼接起来。</li>
<li>虽然 deque 也提供 随机访问的迭代器，但它的迭代器与vectot、list都不一样，它的实现非常复杂和精妙；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main ()
&#123;
	using namespace std;

	&#x2F;&#x2F; Define a deque of integers
	deque &lt;int&gt; dqIntegers;

	&#x2F;&#x2F; Insert integers at the bottom of the array
	dqIntegers.push_back (3);
	dqIntegers.push_back (4);
	dqIntegers.push_back (5);

	&#x2F;&#x2F; Insert integers at the top of the array
	dqIntegers.push_front (2);
	dqIntegers.push_front (1);
	dqIntegers.push_front (0);

	cout &lt;&lt; &quot;The contents of the deque after inserting elements &quot;;
	cout &lt;&lt; &quot;at the top and bottom are:&quot; &lt;&lt; endl;

	&#x2F;&#x2F; Display contents on the screen
	for ( size_t nCount &#x3D; 0
		; nCount &lt; dqIntegers.size ()
		; ++ nCount )
	&#123;
		cout &lt;&lt; &quot;Element [&quot; &lt;&lt; nCount &lt;&lt; &quot;] &#x3D; &quot;;
		cout &lt;&lt; dqIntegers [nCount] &lt;&lt; endl;
	&#125;

	cout &lt;&lt; endl;

	&#x2F;&#x2F; Erase an element at the top
	dqIntegers.pop_front ();

	&#x2F;&#x2F; Erase an element at the bottom
	dqIntegers.pop_back ();

	cout &lt;&lt; &quot;The contents of the deque after erasing an element &quot;;
	cout &lt;&lt; &quot;from the top and bottom are:&quot; &lt;&lt; endl;

	&#x2F;&#x2F; Display contents again: this time using iterators
	&#x2F;&#x2F; deque &lt;int&gt;::iterator iElementLocator;  &#x2F;&#x2F; uncomment if using older compilers and remove auto below
	for (auto iElementLocator &#x3D; dqIntegers.begin ()
		; iElementLocator !&#x3D; dqIntegers.end ()
		; ++ iElementLocator )
	&#123;
		size_t Offset &#x3D; distance (dqIntegers.begin (), iElementLocator);
		cout &lt;&lt; &quot;Element [&quot; &lt;&lt; Offset &lt;&lt; &quot;] &#x3D; &quot; &lt;&lt; *iElementLocator &lt;&lt; endl;
	&#125;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1、deque-的中控器"><a href="#1、deque-的中控器" class="headerlink" title="1、deque 的中控器"></a>1、deque 的中控器</h4><p>deque 在逻辑上看起来是连续空间，内部确实是由一段一段的定量连续空间构成。<br>一旦有必要在 deque的前端或尾端增加新空间，deque便会配置一段定量的连续空间，串接在整个 deque 的头部或尾部。<br>设计 deque 的大师们，想必设计的时候遇到的最大挑战就是如何在这些分段的定量连续空间上，还能维护其整体连续的假象，并提供其随机存取的接口，从而避开了像vector那样的”重新配置-复制-释放”开销三部曲。<br>这样一来，虽然开销降低，却提高了复杂的迭代器架构。因此 deque 数据结构的设计和迭代器前进或后退等操作都非常复杂。<br>deque 采用一块所谓的 map （注意不是 STL 里面的 map 容器）作为中控器，其实就是一小块连续空间，其中的每个元素都是指针，指向另外一段较大的连续线性空间，称之为缓冲区。在后面我们看到，缓冲区才是 deque 的储存空间主体</p>
<h3 id="3-3-7、std-set集合"><a href="#3-3-7、std-set集合" class="headerlink" title="3.3.7、std::set集合"></a>3.3.7、std::set集合</h3><p>set是集合类容器，一共四种</p>
<ul>
<li>std::set<T></li>
<li>std::multiset<T></li>
<li>std::unordered_set<T></li>
<li>std::unordered_multiset<T></li>
</ul>
<p>std::set<T>与std::multiset<T>内部结构是红黑二叉树：</p>
<ul>
<li>插入时排序，默认升序，也可指定排序方式；</li>
<li>自定义类型需要重载操作符&lt;;</li>
<li>插入、删除、查询时间复杂度为O(logN)；</li>
<li>std::set<T>元素必须唯一，std::multiset<T>元素可以重复；     </li>
</ul>
<p>std::unordered_set<T>与std::unordered_multiset<T>内部结构是hash_table：</p>
<ul>
<li>插入时不排序；</li>
<li>插入、删除、查询时间是具体情况而定，key不发生碰撞或极少的碰撞情况下时间复杂度O(1)，最坏的情况是O(n)，所有key都在同一个bucket内；</li>
<li>自定义类型需要实现hash函数和比较函数；</li>
</ul>
<h4 id="1、示例"><a href="#1、示例" class="headerlink" title="1、示例"></a>1、示例</h4><ul>
<li>*multiset中find查找后，返回第一个匹配的元素位置；</li>
<li>*multiset中count返回匹配的元素个数；</li>
<li>*multiset中erase删除所有匹配的元素；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;
#include &lt;iterator&gt;
using namespace std;

struct LessOperator&#123;
   &#x2F;&#x2F; 函数对象
   bool operator() (const char *s1, const char *s2) const &#123;
    return strcmp(s1, s2) &lt; 0;
   &#125;
&#125;;
void printSet(set&lt;int&gt; s)&#123;
	set&lt;int&gt;::iterator iter;
	for (iter &#x3D; s.begin(); iter !&#x3D; s.end(); iter++) &#123;
	    cout&lt;&lt;*iter&lt;&lt;&quot;, &quot;;
	&#125;
	cout&lt;&lt;endl;
&#125;

int main()&#123;
	&#x2F;&#x2F;创建空的set对象，元素类型为int
	set&lt;int&gt; s1;
	&#x2F;&#x2F;创建空的set对象，元素类型char*，指定排序方式为 LessOperator
	set&lt;const char*, LessOperator&gt; s2(LessOperator); 
	
	set&lt;int&gt; s3(s1); 
	&#x2F;&#x2F; 以指定范围的元素创建
	int iArray[] &#x3D; &#123;13, 32, 19&#125;;
	set&lt;int&gt; s4(iArray, iArray + 3);
	
	&#x2F;&#x2F; 以指定范围的元素创建，并指定排序方式
	const char* szArray[] &#x3D; &#123;&quot;hello&quot;, &quot;dog&quot;, &quot;bird&quot; &#125;;
	set&lt;const char*, LessOperator&gt; s5(szArray, szArray + 3, LessOperator);
	
	&#x2F;*元素插入：
	1,插入value，返回pair对象，可以根据second判断是否插入成功
    pair&lt;iterator, bool&gt; insert(value)
    2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功
    iterator insert(&amp;pos, value)
    3,将指定范围的元素插入到set容器
	void insert[&amp;first, &amp;last);
	*&#x2F;
	cout&lt;&lt;&quot;s1.insert() : &quot;&lt;&lt;endl;
	for (int i &#x3D; 0; i &lt;5 ; i++)
        s1.insert(i*10);
    printSet(s1);
	
	cout&lt;&lt;&quot;s1.insert(20).second &#x3D; &quot;&lt;&lt;endl;
	if (s1.insert(20).second)
        cout&lt;&lt;&quot;Insert OK!&quot;&lt;&lt;endl;
	else
        cout&lt;&lt;&quot;Insert Failed!&quot;&lt;&lt;endl;


   &#x2F;*元素删除
    1,size_type erase(value) 删除元素值为value的所有元素，返回移除的元素个数
    2,void erase(&amp;pos) 移除pos位置上的元素，无返回值
    3,void erase(&amp;first, &amp;last) 移除迭代区间[&amp;first, &amp;last)内的元素，无返回值
    4,void clear()， 移除set容器内所有元素*&#x2F;
	cout&lt;&lt;&quot;\ns1.erase(70) &#x3D; &quot;&lt;&lt;endl;
	s1.erase(70);
	printSet(s1);

    cout&lt;&lt;&quot;set&lt;int&gt;::iterator iter &#x3D; s1.begin();\ns1.erase(iter) &#x3D; &quot;&lt;&lt;endl;
    set&lt;int&gt;::iterator iter &#x3D; s1.begin();
    s1.erase(iter);
    printSet(s1);

    &#x2F;*元素查找
	count(value)返回值为value的元素个数
	iterator find(value)返回value所在位置，找不到value将返回end()
	lower_bound(value),upper_bound(value), equal_range(value)*&#x2F;
	cout&lt;&lt;&quot;\ns1.count(10) &#x3D; &quot;&lt;&lt;s1.count(10)&lt;&lt;&quot;, s1.count(80) &#x3D; &quot;&lt;&lt;s1.count(80)&lt;&lt;endl;
	cout&lt;&lt;&quot;s1.find(10) : &quot;;
	if (s1.find(10) !&#x3D; s1.end()) 
		cout&lt;&lt;&quot;OK!&quot;&lt;&lt;endl;
	else
		cout&lt;&lt;&quot;not found!&quot;&lt;&lt;endl;
	
	&#x2F;*其它常用函数*&#x2F;
	cout&lt;&lt;&quot;\ns1.empty()&#x3D;&quot;&lt;&lt;s1.empty()&lt;&lt;&quot;, s1.size()&#x3D;&quot;&lt;&lt;s1.size()&lt;&lt;endl;
	set&lt;int&gt; s9;
	s9.insert(100);
	cout&lt;&lt;&quot;s1.swap(s9) :&quot;&lt;&lt;endl;
	s1.swap(s9);
	cout&lt;&lt;&quot;s1: &quot;&lt;&lt;endl;
	printSet(s1);
	cout&lt;&lt;&quot;s9: &quot;&lt;&lt;endl;
	printSet(s9);
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-8、std-map映射"><a href="#3-3-8、std-map映射" class="headerlink" title="3.3.8、std::map映射"></a>3.3.8、std::map映射</h3><p>map是键-值对容器，一共那个：</p>
<ul>
<li>std::map&lt;key, value&gt;</li>
<li>std::multimap&lt;key, value&gt;</li>
<li>std::unordered_map&lt;key, value&gt;</li>
<li>std::unordered_multimap&lt;key, value&gt;</li>
</ul>
<p>std::map&lt;key, value&gt;与std::multimap&lt;key, value&gt;内部结构是红黑二叉树：</p>
<ul>
<li>插入时对ey排序，默认升序，也可指定排序方式；</li>
<li>自定义key类型需要重载运算符&lt;；</li>
<li>插入、删除、查询时间复杂度为O(logN)；</li>
<li>std::map&lt;key, value&gt;key必须唯一，std::multimap&lt;key, value&gt;key可以重复；</li>
</ul>
<p>std::unordered_map&lt;key, value&gt;与std::unordered_multimap&lt;key, value&gt;内部结构是hash_table：</p>
<ul>
<li>插入时不排序；</li>
<li>插入、删除、查询时间是具体情况而定，key不发生碰撞或极少的碰撞情况下时间复杂度O(1)，最坏的情况是O(n)，所有key都在同一个bucket内；</li>
<li>自定义key类型需要实现hash函数和比较函数；</li>
</ul>
<h4 id="1、初始化-2"><a href="#1、初始化-2" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;map&gt;
#include&lt;string&gt;

template&lt;typename KeyType&gt;
struct SortDown  &#x2F;&#x2F; 降序
&#123;
   bool operator()(const KeyType&amp; key1, const KeyType&amp; key2)
   &#123;
      return (key1 &gt; key2);
   &#125;
&#125;;

int main ()
&#123;
   using namespace std;

   map&lt;int, string&gt; mapIntToString1;

   &#x2F;&#x2F; map constructed as a copy of another
   map&lt;int, string&gt; mapIntToString2(mapIntToString1);
   
   &#x2F;&#x2F; map constructed given a part of another map or multimap
   map&lt;int, string&gt; mapIntToString3(mapIntToString1.cbegin(), 
                                    mapIntToString1.cend());

   &#x2F;&#x2F; map with a predicate that inverses sort order
   map&lt;int, string, SortDown&lt;int&gt; &gt; mapIntToString4
      (mapIntToString1.cbegin(), mapIntToString1.cend());

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2、插入-2"><a href="#2、插入-2" class="headerlink" title="2、插入"></a>2、插入</h4><p>插入方式：</p>
<ul>
<li>make_pair</li>
<li>pair</li>
<li>value_type</li>
<li>数组的方式</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;
#include &lt;iostream&gt;
#include&lt;string&gt;

using namespace std;

&#x2F;&#x2F; Type-define the map and multimap definition for easy readability
typedef map &lt;int, string&gt; MAP_INT_STRING;

template &lt;typename T&gt;
void DisplayContents (const T&amp; Input)
&#123;
   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11 
      ; iElement !&#x3D; Input.cend()
      ; ++ iElement )
      cout &lt;&lt; iElement-&gt;first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; iElement-&gt;second &lt;&lt; endl;

   cout &lt;&lt; endl;
&#125;

int main ()
&#123;
   MAP_INT_STRING mapIntToString;

   &#x2F;&#x2F; Insert key-value pairs into the map using value_type
   mapIntToString.insert (MAP_INT_STRING::value_type (3, &quot;Three&quot;));

   &#x2F;&#x2F; Insert a pair using function make_pair
   mapIntToString.insert (make_pair (-1, &quot;Minus One&quot;));

   &#x2F;&#x2F; Insert a pair object directly
   mapIntToString.insert (pair &lt;int, string&gt;(1000, &quot;One Thousand&quot;));

   &#x2F;&#x2F; Insert using an array-like syntax for inserting key-value pairs
   mapIntToString [1000000] &#x3D; &quot;One Million&quot;;

   cout &lt;&lt; &quot;The map contains &quot; &lt;&lt; mapIntToString.size ();
   cout &lt;&lt; &quot; key-value pairs. They are: &quot; &lt;&lt; endl;
   DisplayContents(mapIntToString);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>需要注意的是</strong>：<br>当使用数组方式插入时，如果map中已经存在key值，则会直接覆盖,存在误操作风险。   </p>
<p><strong>判断插入是否成功</strong><br>通过insert函数返回的pair类型可判断</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main()&#123;
    map&lt;int, string&gt; mapStudent;
    pair&lt;map&lt;int, string&gt;::iterator, bool&gt; insert_pair;
     insert_pair &#x3D; mapStudent.insert(pair&lt;int,string&gt;(1,&quot;student_one&quot;));
    if(insert_pair.second &#x3D;&#x3D; true)&#123;
        cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl;
    &#125;
    else&#123;
        cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl;
    &#125;
    
     map&lt;int, string&gt;::iterator iter;
     for(iter &#x3D; mapStudent.begin(); iter !&#x3D; mapStudent.end(); iter++)&#123;
          cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;
     &#125;
     return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3、删除-1"><a href="#3、删除-1" class="headerlink" title="3、删除"></a>3、删除</h4><ul>
<li>erase(target)函数<br>当target为key时，返回删除的元素个数；<br>当target为迭代器时，删除的是target指向的value，返回void；     </li>
<li>erase(b,e)<br>表示删除迭代器b和e之间的元素</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main()&#123;
    map&lt;int, string&gt; mapStudent;
	mapStudent[1]&#x3D;&quot;student_one&quot;;
	mapStudent[2]&#x3D;&quot;student_two&quot;;
	mapStudent[3]&#x3D;&quot;student_three&quot;;
	mapStudent[4]&#x3D;&quot;student_four&quot;;	
    map&lt;int, string&gt;::iterator iter&#x3D;mapStudent.begin();
    for(;iter!&#x3D;mapStudent.end();)&#123;
	    if((*iter).second&#x3D;&#x3D;&quot;student_one&quot;)&#123;
	        mapStudent.erase(iter++);
	    &#125;
	    else&#123;
	        ++iter;
	    &#125;
	&#125;	
    for(iter&#x3D;mapStudent.begin();iter!&#x3D;mapStudent.end();iter++)&#123;
	    cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;
	&#125;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4、反向遍历"><a href="#4、反向遍历" class="headerlink" title="4、反向遍历"></a>4、反向遍历</h4><p>rbegin()、rend()函数</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main()&#123;
    map&lt;int,string&gt; mapStudent;
    mapStudent[1] &#x3D;  &quot;student_one&quot;; 
    mapStudent[2] &#x3D;  &quot;student_two&quot;; 
    mapStudent[3] &#x3D;  &quot;student_three&quot;;
     map&lt;int, string&gt;::reverse_iterator   iter;
     for(iter &#x3D; mapStudent.rbegin(); iter !&#x3D; mapStudent.rend(); iter++)&#123;
          cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;
     &#125;
     return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-9、hastMap散列表的实现原理"><a href="#3-3-9、hastMap散列表的实现原理" class="headerlink" title="3.3.9、hastMap散列表的实现原理"></a>3.3.9、hastMap散列表的实现原理</h3><h4 id="1、发展背景"><a href="#1、发展背景" class="headerlink" title="1、发展背景"></a>1、发展背景</h4><p>最初的C++标准库之中并没有hashMap的实现，只是不同的实现者根据自己的需求提供了非标准的hashMap，由于这些实现不是遵循标准编写的，所以他们在功能和性能上表现不一。<br>从C++11开始，hashMap的实现被加入到标准库之中，为了防止与已开发的代码存在冲突，决定使用替代名称 unordered_map。这个名字其实更具描述性，因为它暗示了该类元素的无序性。</p>
<h4 id="2、hash"><a href="#2、hash" class="headerlink" title="2、hash"></a>2、hash</h4><p>hash 就是把任意长度的输入，通过hash函数变换成固定长度的输出（通常是整型），该输出就是哈希值。</p>
<p>这是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间。不同的输入可能会散列成相同的输出，因此不能从散列值来唯一地确定输入值。</p>
<h4 id="3、hash冲突"><a href="#3、hash冲突" class="headerlink" title="3、hash冲突"></a>3、hash冲突</h4><p>不同key关键字通过hash函数计算出相同的hashcode，该种现象称为hash冲突或hash碰撞。  </p>
<p><font color=red><strong>PS:<br>不论如何定义hash函数，当数据量达到一定范围时，必定会发生hash冲突，这是无法避免的，只能最大限度的减少hash冲突的情况</strong></font></p>
<h4 id="4、hash函数"><a href="#4、hash函数" class="headerlink" title="4、hash函数"></a>4、hash函数</h4><p>将key按照一定规则转换成hashcode的函数，hash函数为避免hash冲突需要遵循一定的规则：</p>
<ul>
<li>hash函数计算出来的hashcode能均匀分布在整个空间中（最大限度减少冲突）；</li>
</ul>
<h4 id="5、数据结构"><a href="#5、数据结构" class="headerlink" title="5、数据结构"></a>5、数据结构</h4><p>hashMap的数据结构采用的是<code>hashtable + bucket</code>，键-值对(key-value)存储于bucket之中，而bucket又存储于hashtable之中。   </p>
<ul>
<li>hashtable是一个数组，实际上就是动态数组vector；</li>
<li>bucket是一个链表；</li>
</ul>
<h4 id="6、hash策略"><a href="#6、hash策略" class="headerlink" title="6、hash策略"></a>6、hash策略</h4><p>hashMap采⽤bucket的形式存储key-value对，每⼀个key-value对组成的实体称作Entry。bucket实际上就是链表,Entry就是链表的组成节点。  </p>
<p><font color=purple>hashtable与bucket之间是如何映射的？<br>key与hashtable之间的映射关系？</font>   </p>
<p>hashMap对存放进来的key首先利用hash函数计算出hashcode，但是这个值很大，不可以直接作为hashtable下标，此时使用’按位’取余的方法生成下标：   </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">key.hashcode % hashtable.length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对于任意的一个key值，进行这样的操作以后，其值都落在 <code>0 - (hashtable.length - 1) </code>中，这里的’按位’取余的方法不同于直接取余操作’%’，因为直接取余操作’%’速度较慢，采用位运算的方式更加高效，具体的方法是：<br><code>将hashcode与hashtable的length - 1进行按位与操作</code>  </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">举个例子：
hashtable的length为16
0001 0000    &#x2F;&#x2F; 16的二进制
0000 1111    &#x2F;&#x2F; 15的二进制
0000 1110    &#x2F;&#x2F; 14的二进制
hashcode &#x3D; 01001011 01011001

- hashcode与16按位与的结果始终是0,；
- hashcode与14按位与，由于最后一位是0，按位与的结果最后一位也永远是0；
类似以上两种情况，按位与取余的结果都不能使hashtable的数组空间得到充分利用，而目标值15就可以充分利用hashtable 0 - 15的空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>取余运算的结果即是其在hashtable之中的数组索引index，这也就解释了为何hashtable的vector数组长度以及扩容长度为<code>2的n次方</code></p>
<p>散列表将键-值对存储在桶中，每个桶都有索引，标识它在散列表中的相对位置，索引是使用散列函数根据键计算得到：<br>Index = HashFunc(key, tablesize);<br>如果HashFunc函数设计不佳，会出现索引重复，进而导致整体性能的下降。</p>
<h4 id="7、get-put过程"><a href="#7、get-put过程" class="headerlink" title="7、get\put过程"></a>7、get\put过程</h4><p>put过程：</p>
<ul>
<li>输入key；</li>
<li>通过 hash 函数得到 hashcode 值；</li>
<li>对hashcode取余获取其在hashtable内的位置索引index；</li>
<li>以key-value对作为entry存入bucket内（发生冲突，用比较函数解决）；</li>
</ul>
<p>get过程：</p>
<ul>
<li>输入 key</li>
<li>通过 hash 函数得到 hashcode 值；</li>
<li>对hashcode取余获取其在hashtable内的位置索引index；</li>
<li>比较桶的内部元素是否与 key 相等，若都不相等，则没有找到；</li>
<li>取出匹配的key-value对；</li>
</ul>
<h4 id="8、hashtable为何采用动态数组存储"><a href="#8、hashtable为何采用动态数组存储" class="headerlink" title="8、hashtable为何采用动态数组存储"></a>8、hashtable为何采用动态数组存储</h4><p>数组的访问与插入性能为O(1)，但其删除性能很差，那么hashtable为何会选择数组形式存储呢？<br>这里就需要正确理解hashtable之中的删除操作了，删除一个key-value对实际上是删除bucket的相应节点，而对于hashtable而言，并不会删除key对应的index位置，故不存在删除性能的问题。</p>
<h4 id="9、hash函数与比较函数的实现"><a href="#9、hash函数与比较函数的实现" class="headerlink" title="9、hash函数与比较函数的实现"></a>9、hash函数与比较函数的实现</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; *****示例一*****
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;unordered_map&gt;

struct Key
&#123;
	std::string first;
	std::string second;
	
	&#x2F;&#x2F;hash
	std::size_t operator()(const Key&amp; k) const
	&#123;
		return std::hash&lt;std::string&gt;()(k.first) ^
			(std::hash&lt;std::string&gt;()(k.second) &lt;&lt; 1);
	&#125;
	
	&#x2F;&#x2F;compay
	bool operator()(const Key&amp; lhs, const Key&amp; rhs) const
	&#123;
		return lhs.first &#x3D;&#x3D; rhs.first &amp;&amp; lhs.second &#x3D;&#x3D; rhs.second;
	&#125;
&#125;;

int main(void)
&#123;

	std::unordered_map&lt;Key, std::string, Key, Key&gt; m6 &#x3D;
	&#123; &#123; &#123; &quot;John&quot;, &quot;Doe&quot; &#125;, &quot;example&quot; &#125;, &#123; &#123; &quot;Mary&quot;, &quot;Sue&quot; &#125;, &quot;another&quot; &#125; &#125;;

	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; *****示例二*****

&#x2F;&#x2F; 类的总大小是32+32+4+4&#x3D;72字节，size_t是8字节，hash函数返回：每16字节的累计按位与值
class SipCall_IP_Port
&#123;
public:
	char cSrcIP[32];
	char cDestIP[32];
	uint32_t nSrcPort;
	uint32_t nDestPort;

	size_t operator()(const SipCall_IP_Port&amp; s) const
	&#123;
		size_t hash &#x3D; 0;
		size_t *data &#x3D; (size_t*)&amp;s;
		for (size_t i &#x3D; 0; i &lt; 72 &#x2F; sizeof(size_t); ++i)
			hash ^&#x3D; data[i];
		return hash;
	&#125;
	bool operator()(const SipCall_IP_Port&amp; s1, const SipCall_IP_Port&amp; s2) const
	&#123;
		return memcmp(&amp;s1, &amp;s2, 72) &#x3D;&#x3D; 0;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-10、红黑树-Red-Black-Tree"><a href="#3-3-10、红黑树-Red-Black-Tree" class="headerlink" title="3.3.10、红黑树(Red-Black Tree)"></a>3.3.10、红黑树(Red-Black Tree)</h3><p><strong>定义</strong><br>R-B Tree全称是Red-Black Tree，又称为红黑树，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。    </p>
<p>红黑树的特性:</p>
<ul>
<li>1、每个节点或者是黑色，或者是红色</li>
<li>2、根节点是黑色</li>
<li>3、每个叶子节点（NIL）是黑色[注意：这里叶子节点是指为空(NIL或NULL)的叶子节点！]</li>
<li>4、如果一个节点是红色的，则它的子节点必须是黑色的</li>
<li>5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>特性(3)中的叶子节点，是只为空(NIL或null)的节点</li>
<li>特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对接近平衡的二叉树</li>
</ul>
<p><strong>红黑树的应用</strong><br>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<p><strong>基本操作</strong><br>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而可能是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：<strong>左旋和右旋</strong>    </p>
<p><strong>1、左旋</strong><br><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/E46E373FB6044D2EB66A69A2B717E7BF/30950" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/C6831FBE58B34EB7B5F8F92FA837FD99/30960" alt="image"></p>
<p>对x进行左旋，意味着”将x变成一个左节点”<br>代码实现：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 
 * 对红黑树的节点(x)进行左旋转
 *
 * 左旋示意图(对节点x进行左旋)：
 *      px                              px
 *     &#x2F;                               &#x2F;
 *    x                               y                
 *   &#x2F;  \      --(左旋)--&gt;           &#x2F; \                #
 *  lx   y                          x  ry     
 *     &#x2F;   \                       &#x2F;  \
 *    ly   ry                     lx  ly  
 *
 *
 *&#x2F;
template &lt;class T&gt;
void RBTree&lt;T&gt;::leftRotate(RBTNode&lt;T&gt;* &amp;root, RBTNode&lt;T&gt;* x)
&#123;
    &#x2F;&#x2F; 设置x的右孩子为y
    RBTNode&lt;T&gt; *y &#x3D; x-&gt;right;

    &#x2F;&#x2F; 将 &quot;y的左孩子&quot; 设为 &quot;x的右孩子&quot;；
    &#x2F;&#x2F; 如果y的左孩子非空，将 &quot;x&quot; 设为 &quot;y的左孩子的父亲&quot;
    x-&gt;right &#x3D; y-&gt;left;
    if (y-&gt;left !&#x3D; NULL)
        y-&gt;left-&gt;parent &#x3D; x;

    &#x2F;&#x2F; 将 &quot;x的父亲&quot; 设为 &quot;y的父亲&quot;
    y-&gt;parent &#x3D; x-&gt;parent;

    if (x-&gt;parent &#x3D;&#x3D; NULL)
    &#123;
        root &#x3D; y;            &#x2F;&#x2F; 如果 &quot;x的父亲&quot; 是空节点，则将y设为根节点
    &#125;
    else
    &#123;
        if (x-&gt;parent-&gt;left &#x3D;&#x3D; x)
            x-&gt;parent-&gt;left &#x3D; y;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为&quot;x的父节点的左孩子&quot;
        else
            x-&gt;parent-&gt;right &#x3D; y;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为&quot;x的父节点的左孩子&quot;
    &#125;
    
    &#x2F;&#x2F; 将 &quot;x&quot; 设为 &quot;y的左孩子&quot;
    y-&gt;left &#x3D; x;
    &#x2F;&#x2F; 将 &quot;x的父节点&quot; 设为 &quot;y&quot;
    x-&gt;parent &#x3D; y;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><strong>2、右旋</strong></p>
<p><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/B097D20CA2144A61B456853240FFE9D0/30966" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/13E85D1483C14E4EA943CE986E777E53/30968" alt="image">  </p>
<p>对y进行右旋，意味着将y变成右节点<br>代码实现：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 
 * 对红黑树的节点(y)进行右旋转
 *
 * 右旋示意图(对节点y进行左旋)：
 *            py                               py
 *           &#x2F;                                &#x2F;
 *          y                                x                  
 *         &#x2F;  \      --(右旋)--&gt;            &#x2F;  \                     #
 *        x   ry                           lx   y  
 *       &#x2F; \                                   &#x2F; \                   #
 *      lx  rx                                rx  ry
 * 
 *&#x2F;
template &lt;class T&gt;
void RBTree&lt;T&gt;::rightRotate(RBTNode&lt;T&gt;* &amp;root, RBTNode&lt;T&gt;* y)
&#123;
    &#x2F;&#x2F; 设置x是当前节点的左孩子。
    RBTNode&lt;T&gt; *x &#x3D; y-&gt;left;

    &#x2F;&#x2F; 将 &quot;x的右孩子&quot; 设为 &quot;y的左孩子&quot;；
    &#x2F;&#x2F; 如果&quot;x的右孩子&quot;不为空的话，将 &quot;y&quot; 设为 &quot;x的右孩子的父亲&quot;
    y-&gt;left &#x3D; x-&gt;right;
    if (x-&gt;right !&#x3D; NULL)
        x-&gt;right-&gt;parent &#x3D; y;

    &#x2F;&#x2F; 将 &quot;y的父亲&quot; 设为 &quot;x的父亲&quot;
    x-&gt;parent &#x3D; y-&gt;parent;

    if (y-&gt;parent &#x3D;&#x3D; NULL) 
    &#123;
        root &#x3D; x;            &#x2F;&#x2F; 如果 &quot;y的父亲&quot; 是空节点，则将x设为根节点
    &#125;
    else
    &#123;
        if (y &#x3D;&#x3D; y-&gt;parent-&gt;right)
            y-&gt;parent-&gt;right &#x3D; x;    &#x2F;&#x2F; 如果 y是它父节点的右孩子，则将x设为&quot;y的父节点的右孩子&quot;
        else
            y-&gt;parent-&gt;left &#x3D; x;    &#x2F;&#x2F; (y是它父节点的左孩子) 将x设为&quot;x的父节点的左孩子&quot;
    &#125;

    &#x2F;&#x2F; 将 &quot;y&quot; 设为 &quot;x的右孩子&quot;
    x-&gt;right &#x3D; y;

    &#x2F;&#x2F; 将 &quot;y的父节点&quot; 设为 &quot;x&quot;
    y-&gt;parent &#x3D; x;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>红黑树的代码实现</strong>详见网址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3624291.html">https://www.cnblogs.com/skywang12345/p/3624291.html</a> </p>
<h3 id="3-3-11、std-map与std-unordered-map的比较"><a href="#3-3-11、std-map与std-unordered-map的比较" class="headerlink" title="3.3.11、std::map与std::unordered_map的比较"></a>3.3.11、std::map与std::unordered_map的比较</h3><p>std::map的内部结构是红黑树，std::unordered_map内部结构是hashtable + 链表</p>
<h4 id="1、插入-删除性能"><a href="#1、插入-删除性能" class="headerlink" title="1、插入\删除性能"></a>1、插入\删除性能</h4><p>红黑树的插入、删除、查找性能都是O(logN)，而hash表的插入、删除查找性能理论上是O(1)，在这个对比上来看，红黑树性能远没有hash表优秀。但是值得一提的是红黑树是相对稳定的数据结构，最差情况下也是高效的，而相对于hash表数据结构而言，它的插入、删除操作理论上时间复杂度是常数时间，但前提是不发生数据碰撞。在发生碰撞时，最坏的情况是插入、删除时间复杂度高达O(n)。<br>对于实际应用，当然一个相对稳定且快速的数据结构是比较理想的选择</p>
<h4 id="2、结构特性"><a href="#2、结构特性" class="headerlink" title="2、结构特性"></a>2、结构特性</h4><p>红黑树是基于平衡二叉树的结构，插入、删除操作很方便，并且它是一种自动有序的数据结构，插入、删除节点会进行自旋，可以保证在3次旋转之内使当前红黑树节点重新有序。</p>
<h3 id="3-3-12、栈与队列"><a href="#3-3-12、栈与队列" class="headerlink" title="3.3.12、栈与队列"></a>3.3.12、栈与队列</h3><ul>
<li>栈-stack：先入后出，只允许在栈顶添加和删除元素，称为出栈和入栈；</li>
<li>队列-queue：先入先出，在队首取元素，在队尾添加元素，称为出队和入队；</li>
</ul>
<p><img src="http://note.youdao.com/yws/public/resource/20a67e1bc7bb981e1990a97c7d7c3225/xmlnote/WEBRESOURCE7ce84b15d37bf5272d57551d7cbb9eb5/41260" alt="image01"></p>
<ul>
<li>常见栈的应用场景包括函数调用、递归实现、深度优先遍历 DFS 等；</li>
<li>常见的队列的应用场景包括消息缓冲队列的管理、广度优先遍历 BFS 等。<br>翻一下源码，就知道 stack 和 queue 的底层其实就是使用 deque，用 deque 为底层容器封装。</li>
</ul>
<h4 id="1、栈的top函数"><a href="#1、栈的top函数" class="headerlink" title="1、栈的top函数"></a>1、栈的top函数</h4><p>由于top函数返回的是栈顶元素的引用，所以当栈为空时，top返回的引用为空，如果返回用于表达式，则会报错<code>Segmentation fault</code>，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stack&gt;

int main()
&#123;
    std::stack&lt;int32_t&gt; st;
    if (st.top() &#x3D;&#x3D; 1) &#123;
        std::cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; std::endl;
    &#125;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-3-13、-STL相关文章收录"><a href="#3-3-13、-STL相关文章收录" class="headerlink" title="3.3.13、 STL相关文章收录"></a>3.3.13、 STL相关文章收录</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zU9YuKWtGyXjBqBp5ihaNA">2万字 + 20张图带你手撕STL容器源码</a></li>
</ul>
<h2 id="3-4、STL常见算法"><a href="#3-4、STL常见算法" class="headerlink" title="3.4、STL常见算法"></a>3.4、STL常见算法</h2><h3 id="3-4-1、分类"><a href="#3-4-1、分类" class="headerlink" title="3.4.1、分类"></a>3.4.1、分类</h3><p>两大类：变序算法、非变序算法</p>
<h4 id="1、非变序算法"><a href="#1、非变序算法" class="headerlink" title="1、非变序算法"></a>1、非变序算法</h4><p>不改变容器中元素的顺序和内容</p>
<ul>
<li>统计计数<ul>
<li>count：指定范围内查找与目标值匹配的所有元素个数；</li>
<li>count_if：指定范围内查找满足条件的所有元素个数；</li>
</ul>
</li>
<li>查找算法<ul>
<li>search：指定范围内查找目标值或满足二元谓词算法的第一个元素，目标值也可以是个序列；</li>
<li>search_n：指定范围内查找目标值或满足二元谓词算法的前N个元素，目标值也可以是个序列；</li>
<li>find：指定范围内查找目标值的第一个元素；</li>
<li>find_if：指定范围内查找满足指定条件的第一个元素；</li>
<li>find_end：指定范围内查找满足指定条件的最后一个元素；</li>
</ul>
</li>
</ul>
<h4 id="2、变序算法"><a href="#2、变序算法" class="headerlink" title="2、变序算法"></a>2、变序算法</h4><p>可能会改变容器中元素的顺序或内容</p>
<ul>
<li>初始化算法<ul>
<li>fill：将指定值分配给指定范围中的每一个元素；</li>
<li>fill_n：将指定值分配给指定范围中的前n个元素；</li>
<li>generate：类似fill；</li>
<li>generate_n：类似fill_n；</li>
</ul>
</li>
<li>复制算法<ul>
<li>copy：将指定范围复制到目标范围；</li>
<li>copy_backward：将指定范围复制到目标范围，在目标范围内将顺序反转；</li>
</ul>
</li>
<li>删除算法<br>与erase函数的不同之处详见<strong>3.4.7</strong>节<ul>
<li>remove：删除所有目标值；</li>
<li>remove_if：删除满足一元谓词算法的所有目标值；</li>
<li>remove_copy：将源范围中除目标值外的所有元素复制到目标范围；</li>
<li>remove_copy_if：将源范围中除满足指定一元谓词算法外的所有元素复制到目标范围；</li>
<li>unique：比较指定范围内的相邻元素，并删除重复元素。该算法还有一个重载版本，使用二元谓词算法来判断需要删除的目标值 [ 需要结合erase最终删除 ]；</li>
<li>unique_copy：将源范围的所有元素复制到目标范围，但相邻的重复元素除外素[需要结合erase最终删除]；</li>
</ul>
</li>
<li>替换算法<ul>
<li>replace：用一个值替换指定范围中与目标值匹配的所有元素；</li>
<li>replace_if：用一个值替换指定范围中满足指定条件的所有元素；</li>
</ul>
</li>
<li>排序算法<ul>
<li>sort：使用指定的排序标准对指定范围的元素进行排序。排序标准由二元谓词决定，但可能改变相等元素的相对位置；</li>
<li>stable_sort：与sort功能类似，但不会改变相等元素的相对位置</li>
<li>partial_sort：将源范围内指定数量的元素进行排序；</li>
<li>partial_sort_copy：将源范围内的元素复制到目标范围，同时对它们进行排序；</li>
</ul>
</li>
<li>分区算法<ul>
<li>partition：在指定范围内，将元素分为两组：满足指定一元谓词的元素放在第一个组中，其他元素放在第二个组中。不一定会保持集合中元素的相对位置；</li>
<li>stable_partition：功能与partition类似，但会保持集合中元素的相对位置；</li>
</ul>
</li>
<li>适用于有序容器的算法<ul>
<li>binary_search：有序容器中查找目标值；</li>
<li>lower_bound：根据元素的值或二元谓词判断可能插入到排序集合中的第一个位置，并返回该位置的迭代器；</li>
<li>upper_bound：根据元素的值或二元谓词判断可能插入到排序集合中的最后一个位置，并返回该位置的迭代器；</li>
</ul>
</li>
</ul>
<h3 id="3-4-2、find、find-if查找"><a href="#3-4-2、find、find-if查找" class="headerlink" title="3.4.2、find、find_if查找"></a>3.4.2、find、find_if查找</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main()
&#123;
   using namespace std;
   vector&lt;int&gt; vecIntegers;

   &#x2F;&#x2F; Inserting sample values -9 to 9
   for (int SampleValue &#x3D; -9; SampleValue &lt; 10; ++ SampleValue) 
      vecIntegers.push_back (SampleValue);

   cout &lt;&lt; &quot;Enter number to find in collection: &quot;;
   int NumToFind &#x3D; 0;
   cin &gt;&gt; NumToFind;

   auto iElementFound &#x3D; find ( vecIntegers.cbegin () &#x2F;&#x2F; Start of range
                             , vecIntegers.cend ()   &#x2F;&#x2F; End of range
                             , NumToFind );          &#x2F;&#x2F; Element to find

   &#x2F;&#x2F; Check if find succeeded
   if ( iElementFound !&#x3D; vecIntegers.cend ())
      cout &lt;&lt; &quot;Result: Value &quot; &lt;&lt; *iElementFound &lt;&lt; &quot; found!&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;Result: No element contains value &quot; &lt;&lt; NumToFind &lt;&lt; endl;

   cout &lt;&lt; &quot;Finding the first even number using find_if: &quot; &lt;&lt; endl;

   auto iEvenNumber &#x3D; find_if ( vecIntegers.cbegin () &#x2F;&#x2F; Start of range
                              , vecIntegers.cend ()  &#x2F;&#x2F; End of range
                 , [](int element) &#123; return (element % 2) &#x3D;&#x3D; 0; &#125; );

   if (iEvenNumber !&#x3D; vecIntegers.cend ())
   &#123;
      cout &lt;&lt; &quot;Number &#39;&quot; &lt;&lt; *iEvenNumber &lt;&lt; &quot;&#39; found at position [&quot;;
      cout &lt;&lt; distance (vecIntegers.cbegin (), iEvenNumber);
      cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;
   &#125;

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-3、search、search-n查找"><a href="#3-4-3、search、search-n查找" class="headerlink" title="3.4.3、search、search_n查找"></a>3.4.3、search、search_n查找</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents (const T&amp; Input)
&#123;
   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11 
     ; iElement !&#x3D; Input.cend()
     ; ++ iElement )
     cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;

   cout &lt;&lt; endl;
&#125;

int main ()
&#123;
   &#x2F;&#x2F; A sample container - vector of integers - containing -9 to 9
   vector &lt;int&gt; vecIntegers;
   for (int nNum &#x3D; -9; nNum &lt; 10; ++ nNum)
      vecIntegers.push_back (nNum);

   &#x2F;&#x2F; Insert some more sample values into the vector
   vecIntegers.push_back (9);
   vecIntegers.push_back (9);

   &#x2F;&#x2F; Another sample container - a list of integers from -4 to 4
   list &lt;int&gt; listIntegers;
   for (int nNum &#x3D; -4; nNum &lt; 5; ++ nNum)
      listIntegers.push_back (nNum);

   cout &lt;&lt; &quot;The contents of the sample vector are: &quot; &lt;&lt; endl;
   DisplayContents (vecIntegers);

   cout &lt;&lt; &quot;The contents of the sample list are: &quot; &lt;&lt; endl;
   DisplayContents (listIntegers);

   cout &lt;&lt; &quot;search() for the contents of list in vector:&quot; &lt;&lt; endl;
   auto iRange &#x3D; search ( vecIntegers.begin () &#x2F;&#x2F; Start of range
              , vecIntegers.end ()     &#x2F;&#x2F; End of range to search in
              , listIntegers.begin ()  &#x2F;&#x2F; Start of range to search for
              , listIntegers.end () ); &#x2F;&#x2F; End of range to search for

   &#x2F;&#x2F; Check if search found a match
   if (iRange !&#x3D; vecIntegers.end ())
   &#123;
      cout &lt;&lt; &quot;Sequence in list found in vector at position: &quot;;
      cout &lt;&lt; distance (vecIntegers.begin (), iRange) &lt;&lt; endl;
   &#125;

   cout &lt;&lt; &quot;Searching &#123;9, 9, 9&#125; in vector using search_n(): &quot; &lt;&lt; endl;
   auto iPartialRange &#x3D; search_n ( vecIntegers.begin () &#x2F;&#x2F; Start range
                     , vecIntegers.end ()   &#x2F;&#x2F; End range
                     , 3      &#x2F;&#x2F; Count of item to be searched for
                     , 9 );   &#x2F;&#x2F; Item to search for

   if (iPartialRange !&#x3D; vecIntegers.end ())
   &#123;
      cout &lt;&lt; &quot;Sequence &#123;9, 9, 9&#125; found in vector at position: &quot;;
      cout &lt;&lt; distance (vecIntegers.begin (), iPartialRange) &lt;&lt; endl;
   &#125;
   
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-4、count、count-if统计计数"><a href="#3-4-4、count、count-if统计计数" class="headerlink" title="3.4.4、count、count_if统计计数"></a>3.4.4、count、count_if统计计数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

&#x2F;&#x2F; A unary predicate for the *_if functions
template &lt;typename elementType&gt;
bool IsEven (const elementType&amp; number)
&#123;
   return ((number % 2) &#x3D;&#x3D; 0); &#x2F;&#x2F; true, if even
&#125;

int main ()
&#123;
   using namespace std;
   vector &lt;int&gt; vecIntegers;

   cout &lt;&lt; &quot;Populating a vector&lt;int&gt; with values from -9 to 9&quot; &lt;&lt; endl;
   for (int nNum &#x3D; -9; nNum &lt; 10; ++ nNum) 
      vecIntegers.push_back (nNum);

   &#x2F;&#x2F; Use count to determine the number of &#39;0&#39;s in the vector
   size_t nNumZeroes &#x3D; count (vecIntegers.begin (),vecIntegers.end (),0);
   cout &lt;&lt; &quot;Number of instances of &#39;0&#39;: &quot; &lt;&lt; nNumZeroes &lt;&lt; endl &lt;&lt; endl;

   &#x2F;&#x2F; Use the count_if algorithm with the unary predicate IsEven:
   size_t nNumEvenElements &#x3D; count_if (vecIntegers.begin (), 
      vecIntegers.end (), IsEven &lt;int&gt; );

   cout &lt;&lt; &quot;Number of even elements: &quot; &lt;&lt; nNumEvenElements &lt;&lt; endl;
   cout &lt;&lt; &quot;Number of odd elements: &quot;;
   cout &lt;&lt; vecIntegers.size () - nNumEvenElements &lt;&lt; endl;

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-4-5、fill、fill-n以目标值进行初始化"><a href="#3-4-5、fill、fill-n以目标值进行初始化" class="headerlink" title="3.4.5、fill、fill_n以目标值进行初始化"></a>3.4.5、fill、fill_n以目标值进行初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

int main ()
&#123;
   using namespace std;

   &#x2F;&#x2F; Initialize a sample vector with 3 elements
   vector &lt;int&gt; vecIntegers (3);

   &#x2F;&#x2F; fill all elements in the container with value 9
   fill (vecIntegers.begin (), vecIntegers.end (), 9);

   &#x2F;&#x2F; Increase the size of the vector to hold 6 elements
   vecIntegers.resize (6);

   &#x2F;&#x2F; Fill the three elements starting at offset position 3 with value -9
   fill_n (vecIntegers.begin () + 3, 3, -9);

   cout &lt;&lt; &quot;Contents of the vector are: &quot; &lt;&lt; endl;
   for (size_t nIndex &#x3D; 0; nIndex &lt; vecIntegers.size (); ++ nIndex)
   &#123;
      cout &lt;&lt; &quot;Element [&quot; &lt;&lt; nIndex &lt;&lt; &quot;] &#x3D; &quot;;
      cout &lt;&lt; vecIntegers [nIndex] &lt;&lt; endl; 
   &#125;

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-4-6、copy、copy-if、copy-backward复制及安全复制"><a href="#3-4-6、copy、copy-if、copy-backward复制及安全复制" class="headerlink" title="3.4.6、copy、copy_if、copy_backward复制及安全复制"></a>3.4.6、copy、copy_if、copy_backward复制及安全复制</h3><p>copy、copy_if、copy_backward：返回值为目标容器的目标范围内最后一个元素位置之后的迭代器；<br><strong>此处需要特别注意</strong>：<br>目标容器的size必须要足够容纳被复制的元素数量，不足时会报错，需要resize，不仅仅是capacity</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents(const T&amp; Input)
&#123;
   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11
        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11 
        ; ++ iElement) 
      cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;

   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;
&#125;
int main ()
&#123;
   list &lt;int&gt; listIntegers;
   for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)
      listIntegers.push_back (nCount);

   cout &lt;&lt; &quot;Source (list) contains:&quot; &lt;&lt; endl;
   DisplayContents(listIntegers);

   &#x2F;&#x2F; Initialize the vector to hold twice as many elements as the list
   vector &lt;int&gt; vecIntegers (listIntegers.size () * 2);

   auto iLastPos &#x3D; copy ( listIntegers.begin ()  &#x2F;&#x2F; start source range
                        , listIntegers.end ()     &#x2F;&#x2F; end source range
                        , vecIntegers.begin () );&#x2F;&#x2F; start dest range

   &#x2F;&#x2F; copy odd numbers from list into vector
   copy_if ( listIntegers.begin(), listIntegers.end()
           , iLastPos 
           , [](int element)&#123;return ((element % 2) &#x3D;&#x3D; 1);&#125;);

   cout &lt;&lt; &quot;Destination (vector) after copy and copy_if:&quot; &lt;&lt; endl;
   DisplayContents(vecIntegers);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>容器中”对元素进行复制行为”的泛型算法，例如：copy、unique_copy等，都要确保目的容器的size足够大，否则会出现复制报错error，STL提供了三个现有的函数。    </p>
<p>以下三个函数需要包含头文件：#include <iterator>      </p>
<ul>
<li>back_inserter会以容器的push_back函数取代assigment运算符，传入back_inserter的参数就是目的容器本身。assigment运算符=vector的数组访问方式或at访问方式；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">vect&lt;int&gt; dest_vec;
unique_copy (ivec.begin(), ivec.end(), back_inserter(dest_vec));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>inserter函数会以容器的insert函数取代assignment运算符，inserter函数接受两个参数，一个是容器，另一个是iterator，指向容器内的插入操作起点；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">vect&lt;int&gt; dest_vec;
unique_copy (ivec.begin(), ivec.end(), inserter(dest_vec, dest_vec.begin()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>front_inserter会以容器的push_front函数取代assigment运算符，不过它只适用于list、deque；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">list&lt;int&gt; dest_vec;
unique_copy (ilist.begin(), ilist.end(), inserter(dest_list));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="3-4-7、remove、remove-if删除"><a href="#3-4-7、remove、remove-if删除" class="headerlink" title="3.4.7、remove、remove_if删除"></a>3.4.7、remove、remove_if删除</h3><p>remove、remove_if：返回一个指向容器最后一个元素(已初始化内存位置)位置之后的迭代器<br><strong>注意</strong>：<br>此时容器一直未调整size大小，size()返回值并未变化，删除动作会引起其他元素向前移动，但并未删除该元素的占位（虽然内存占位还在，但已被反向初始化，不能进行直接访问），此时需要调用erase删除该迭代器至容器尾部的无效元素，才能真正释放其内存占用</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents(const T&amp; Input)
&#123;
   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11
        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11 
        ; ++ iElement) 
      cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;

   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;
&#125;
int main ()
&#123;
   list &lt;int&gt; listIntegers;
   for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)
      listIntegers.push_back (nCount);

   cout &lt;&lt; &quot;Source (list) contains:&quot; &lt;&lt; endl;
   DisplayContents(listIntegers);

   &#x2F;&#x2F; Initialize the vector to hold twice as many elements as the list
   vector &lt;int&gt; vecIntegers (listIntegers.size () * 2);


   &#x2F;&#x2F; Remove all instances of &#39;0&#39;, resize vector using erase()
   auto iNewEnd &#x3D; remove (vecIntegers.begin (), vecIntegers.end (), 0);
   vecIntegers.erase (iNewEnd, vecIntegers.end ());  &#x2F;&#x2F;remove

   &#x2F;&#x2F; Remove all odd numbers from the vector using remove_if
   iNewEnd &#x3D; remove_if (vecIntegers.begin (), vecIntegers.end (), 
             [](int element) &#123;return ((element % 2) &#x3D;&#x3D; 1);&#125; ); &#x2F;&#x2F;predicate

   vecIntegers.erase (iNewEnd , vecIntegers.end ());  &#x2F;&#x2F; resizing

   cout &lt;&lt; &quot;Destination (vector) after remove, remove_if, erase:&quot; &lt;&lt; endl;
   DisplayContents(vecIntegers);
   
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-8、replace、replace-if替换"><a href="#3-4-8、replace、replace-if替换" class="headerlink" title="3.4.8、replace、replace_if替换"></a>3.4.8、replace、replace_if替换</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents(const T&amp; Input)
&#123;
   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11
        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11 
        ; ++ iElement) 
      cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;

   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;
&#125;

int main ()
&#123;
   vector &lt;int&gt; vecIntegers (6);

   &#x2F;&#x2F; fill first 3 elements with value 8, last 3 with 5
   fill (vecIntegers.begin (), vecIntegers.begin () + 3, 8);
   fill_n (vecIntegers.begin () + 3, 3, 5);

   &#x2F;&#x2F; shuffle the container
   random_shuffle (vecIntegers.begin (), vecIntegers.end ());
   
   cout &lt;&lt; &quot;The initial contents of the vector are: &quot; &lt;&lt; endl;
   DisplayContents(vecIntegers);

   cout &lt;&lt; endl &lt;&lt; &quot;Using &#39;std::replace&#39; to replace value 5 by 8&quot; &lt;&lt; endl;
   replace (vecIntegers.begin (), vecIntegers.end (), 5, 8);

   cout &lt;&lt; &quot;Using &#39;std::replace_if&#39; to replace even values by -1&quot; &lt;&lt; endl;
   replace_if (vecIntegers.begin (), vecIntegers.end ()
	   , [](int element) &#123;return ((element % 2) &#x3D;&#x3D; 0); &#125;, -1);

   cout &lt;&lt; endl &lt;&lt; &quot;Contents of the vector after replacements:&quot; &lt;&lt; endl;
   DisplayContents(vecIntegers);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-9、unique去除重复元素"><a href="#3-4-9、unique去除重复元素" class="headerlink" title="3.4.9、unique去除重复元素"></a>3.4.9、unique去除重复元素</h3><p>unique函数只去除相邻的重复值，所以对于非排序容器，最好先使用sort进行排序，然后再unique去除重复值，返回值是一个指向容器最后一个元素(已初始化的内存位置)位置之后的迭代器；</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents(const T&amp; Input)
&#123;
   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11
        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11 
        ; ++ iElement) 
      cout &lt;&lt; *iElement &lt;&lt; endl;
&#125;

int main ()
&#123;
   vector&lt;string&gt; vecNames;

   vecNames.push_back (&quot;John Doe&quot;);
   vecNames.push_back (&quot;Jack Nicholson&quot;);
   vecNames.push_back (&quot;Sean Penn&quot;);
   vecNames.push_back (&quot;Anna Hoover&quot;);

   &#x2F;&#x2F; insert a duplicate into the vector
   vecNames.push_back (&quot;Jack Nicholson&quot;);

   cout &lt;&lt; &quot;The initial contents of the vector are:&quot; &lt;&lt; endl;
   DisplayContents(vecNames);

   cout &lt;&lt; &quot;The sorted vector contains names in the order:&quot; &lt;&lt; endl;
   sort (vecNames.begin (), vecNames.end ());
   DisplayContents(vecNames);

   &#x2F;&#x2F; Erase adjacent duplicates
   auto iNewEnd &#x3D; unique (vecNames.begin (), vecNames.end ());
   vecNames.erase (iNewEnd, vecNames.end ());

   cout &lt;&lt; &quot;The contents of the vector after using &#39;unique&#39;:&quot; &lt;&lt; endl;
   DisplayContents(vecNames);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-10、binary-search有序容器查找"><a href="#3-4-10、binary-search有序容器查找" class="headerlink" title="3.4.10、binary_search有序容器查找"></a>3.4.10、binary_search有序容器查找</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
void DisplayContents(const T&amp; Input)
&#123;
   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11
        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11 
        ; ++ iElement) 
      cout &lt;&lt; *iElement &lt;&lt; endl;
&#125;

int main ()
&#123;
   vector&lt;string&gt; vecNames;

   vecNames.push_back (&quot;John Doe&quot;);
   vecNames.push_back (&quot;Jack Nicholson&quot;);
   vecNames.push_back (&quot;Sean Penn&quot;);
   vecNames.push_back (&quot;Anna Hoover&quot;);

   &#x2F;&#x2F; insert a duplicate into the vector
   vecNames.push_back (&quot;Jack Nicholson&quot;);

   cout &lt;&lt; &quot;The initial contents of the vector are:&quot; &lt;&lt; endl;
   DisplayContents(vecNames);

   cout &lt;&lt; &quot;The sorted vector contains names in the order:&quot; &lt;&lt; endl;
   sort (vecNames.begin (), vecNames.end ());
   DisplayContents(vecNames);

   cout &lt;&lt; &quot;Searching for \&quot;John Doe\&quot; using &#39;binary_search&#39;:&quot; &lt;&lt; endl;
   bool bElementFound &#x3D; binary_search (vecNames.begin (), vecNames.end (),
                                       &quot;John Doe&quot;);

   if (bElementFound)
      cout &lt;&lt; &quot;Result: \&quot;John Doe\&quot; was found in the vector!&quot; &lt;&lt; endl;
   else
      cout &lt;&lt; &quot;Element not found &quot; &lt;&lt; endl;

   return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-11、all-of、any-of、none-of范围真假遍历"><a href="#3-4-11、all-of、any-of、none-of范围真假遍历" class="headerlink" title="3.4.11、all_of、any_of、none_of范围真假遍历"></a>3.4.11、all_of、any_of、none_of范围真假遍历</h3><pre class="line-numbers language-none"><code class="language-none">template&lt; class InputIt, class UnaryPredicate &gt;
bool all_of( InputIt first, InputIt last, UnaryPredicate p );

template&lt; class InputIt, class UnaryPredicate &gt;
bool any_of( InputIt first, InputIt last, UnaryPredicate p );

template&lt; class InputIt, class UnaryPredicate &gt;
bool none_of( InputIt first, InputIt last, UnaryPredicate p );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>all_of检查区间[first，last)中是否所有元素都满足一元判断式，满足返回true；<br>any_of检查区间[first，last)，只要有一个元素满足一元判断式，满足返回true；<br>none_of检查区间[first，last)中是否所有元素都不满足一元判断式，返回true；<br>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
&#123;
    std::vector&lt;int&gt; v(10, 2);
    std::partial_sum(v.cbegin(), v.cend(), v.begin());
    std::cout &lt;&lt; &quot;Among the numbers: &quot;;
    std::copy(v.cbegin(), v.cend(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
    std::cout &lt;&lt; &#39;\n&#39;;

    if (std::all_of(v.cbegin(), v.cend(), [](int i)&#123; return i % 2 &#x3D;&#x3D; 0; &#125;)) &#123;
        std::cout &lt;&lt; &quot;All numbers are even\n&quot;;
    &#125;
    if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus&lt;int&gt;(), 
                                                     std::placeholders::_1, 2))) &#123;
        std::cout &lt;&lt; &quot;None of them are odd\n&quot;;
    &#125;
    struct DivisibleBy
    &#123;
        const int d;
        DivisibleBy(int n) : d(n) &#123;&#125;
        bool operator()(int n) const &#123; return n % d &#x3D;&#x3D; 0; &#125;
    &#125;;

    if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) &#123;
        std::cout &lt;&lt; &quot;At least one number is divisible by 7\n&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre class="line-numbers language-none"><code class="language-none">Among the numbers: 2 4 6 8 10 12 14 16 18 20 
All numbers are even
None of them are odd
At least one number is divisible by 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-12、std-iota生成有序整形序列"><a href="#3-4-12、std-iota生成有序整形序列" class="headerlink" title="3.4.12、std::iota生成有序整形序列"></a>3.4.12、std::iota生成有序整形序列</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;numeric&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
&#123;
    vector&lt;int&gt;  v(4);
    
    std::iota(v.begin(), v.end(), 1);
    for_each(v.begin(), v.end(), [](int c)&#123;cout&lt;&lt;c&lt;&lt;endl;&#125;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-13、max-element、min-element、minmax-element获取最大、最小值"><a href="#3-4-13、max-element、min-element、minmax-element获取最大、最小值" class="headerlink" title="3.4.13、max_element、min_element、minmax_element获取最大、最小值"></a>3.4.13、max_element、min_element、minmax_element获取最大、最小值</h3><pre class="line-numbers language-none"><code class="language-none">template&lt; class ForwardIt &gt; 
ForwardIt max_element( ForwardIt first, ForwardIt last );


template&lt; class ForwardIt &gt; 
std::pair&lt;ForwardIt,ForwardIt&gt; 
minmax_element( ForwardIt first, ForwardIt last );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

static bool abs_compare(int a, int b)
&#123;
    return (std::abs(a) &lt; std::abs(b));
&#125;

int main()
&#123;
    std::vector&lt;int&gt; v&#123; 3, 1, -14, 1, 5, 9 &#125;; 
    std::vector&lt;int&gt;::iterator result;

    result &#x3D; std::max_element(v.begin(), v.end());
    std::cout &lt;&lt; &quot;max element at: &quot; &lt;&lt; std::distance(v.begin(), result) &lt;&lt; &#39;\n&#39;;

    result &#x3D; std::max_element(v.begin(), v.end(), abs_compare);
    std::cout &lt;&lt; &quot;max element (absolute) at: &quot; &lt;&lt; std::distance(v.begin(), result);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre class="line-numbers language-none"><code class="language-none">max element at: 5
max element (absolute) at: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>




<pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
&#123;
    std::vector&lt;int&gt; v &#x3D; &#123; 3, 9, 1, 4, 2, 5, 9 &#125;;

    auto result &#x3D; std::minmax_element(v.begin(), v.end());
    std::cout &lt;&lt; &quot;min element at: &quot; &lt;&lt; (result.first - v.begin()) &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;max element at: &quot; &lt;&lt; (result.second - v.begin()) &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre class="line-numbers language-none"><code class="language-none">min element at: 2
max element at: 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="3-4-14、is-sorted、is-sorted-until判断容器是否有序"><a href="#3-4-14、is-sorted、is-sorted-until判断容器是否有序" class="headerlink" title="3.4.14、is_sorted、is_sorted_until判断容器是否有序"></a>3.4.14、is_sorted、is_sorted_until判断容器是否有序</h3><p>is_sorted判断某个序列是否有序<br>is_sorted_until返回前面已经排序好的序列</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
&#123;
    vectot&lt;int&gt; v &#x3D; &#123;1,2,5,7,9,4&#125;;
    auto pos &#x3D; is_sorted_until(v.begin(), v.end());
    
    for(auto it &#x3D; v.begin(); it!&#x3D;pos;++it )
    cout&lt;&lt;*it&lt;&lt;endl;
    
    bool is_sort &#x3D; is_sorted(v.begin(), v.end());
    cout&lt;&lt;is_sort&lt;&lt;endl;
    return 0 ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-15、for、for-each容器遍历"><a href="#3-4-15、for、for-each容器遍历" class="headerlink" title="3.4.15、for、for_each容器遍历"></a>3.4.15、for、for_each容器遍历</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
&#123;
    vectot&lt;int&gt; vct01 &#x3D; &#123;1,2,5,7,9,4&#125;;
    &#x2F;&#x2F; 常规遍历
    for (const auto&amp; iter &#x3D; vct01.cbegin(); iter !&#x3D; vct01.cend(); ++iter) &#123;
        std::cout &lt;&lt; *iter &lt;&lt; &quot;, &quot;;
    &#125;
    
    &#x2F;&#x2F; 简单遍历
    &#x2F;*
    n表示v中的一个元素，类型为int，冒号之后是需要遍历的目标容器;   
    n是只读的，如果需要在遍历的时候做修改，可以使用引用auto&amp;n；
    可以用continue语句来跳过循环的本次迭代，用break语句来跳出整个循环；
    *&#x2F;
    for(auto n:vct01)
    &#123;
        cout&lt;&lt;n&lt;&lt;endl;
    &#125;
    
    &#x2F;&#x2F; for_each遍历
    for_each(vct01.cbegin(), vct01.cend(), []());
    return 0 ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-16、STL的sort排序函数"><a href="#3-4-16、STL的sort排序函数" class="headerlink" title="3.4.16、STL的sort排序函数"></a>3.4.16、STL的sort排序函数</h3><p>参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengcc/p/5256337.html">STL sort 函数实现详解</a><br>函数原型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;algorithm&gt;
 
template&lt; class RandomIt &gt;
void sort( RandomIt first, RandomIt last );
 
template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>源码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class _RandomAccessIter&gt;
inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;
  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,
                 _LessThanComparable);
  if (__first !&#x3D; __last) &#123;
    __introsort_loop(__first, __last,
                     __VALUE_TYPE(__first),
                     __lg(__last - __first) * 2);
    __final_insertion_sort(__first, __last);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>有两个重载版本，一是两个参数的默认升序版本，二是三个参数的带自定义比较函数的版本；</li>
<li>前两个参数均是表示范围的迭代器，且只支持进行随机访问的容器的迭代器，如vector、string、dequeue、基础类型的数组；</li>
</ul>
<p><code>STL</code>提供的比较函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>less</td>
<td>小于，升序</td>
</tr>
<tr>
<td>greater</td>
<td>大于，降序</td>
</tr>
<tr>
<td>equal_to</td>
<td>等于</td>
</tr>
<tr>
<td>not_equal_to</td>
<td>不等于</td>
</tr>
<tr>
<td>less_equal</td>
<td>小于等于</td>
</tr>
<tr>
<td>greater_equal</td>
<td>大于等于</td>
</tr>
</tbody></table>
<h4 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h4><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化外，它还结合了插入排序和堆排序，根据不同的数量级别以及不同情况，能自动选用合适的排序方法：</p>
<ul>
<li>使用introsort内省式排序防止快速排序的恶化情况，达到优化快速排序的目的，详见下方说明：</li>
<li>当数据量较大时采用快速排序，分段递归，若序列数据里较小则直接采用插入排序；</li>
<li>一旦分段后的数据量小于某个阀值<code>__stl_threshold</code>，为避免递归调用带来过大的额外负荷，便会改用插入排序；</li>
<li>如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序；</li>
</ul>
<h4 id="2、快速排序原理"><a href="#2、快速排序原理" class="headerlink" title="2、快速排序原理"></a>2、快速排序原理</h4><p>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p>
<ul>
<li>如果<code>S</code>中的元素只有0个或1个，结束;</li>
<li>取<code>S</code>中的任何一个元素作为枢轴<code>pivot</code>;</li>
<li>将<code>S</code>分割为<code>L、R</code>两端，使L内的元素都小于等于<code>pivot</code>，<code>R</code>内的元素都大于等于<code>pivot</code>;</li>
<li>对<code>L、R</code>递归执行上述过程;</li>
</ul>
<p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称<code>为median-of-three</code>，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p>
<p>分割的方法通常采用两个迭代器<code>head</code>和<code>tail</code>，<code>head</code>从头端往尾端移动，<code>tail</code>从尾端往头端移动，当<code>head</code>遇到大于等于<code>pivot</code>的元素就停下来，<code>tail</code>遇到小于等于<code>pivot</code>的元素也停下来，若<code>head</code>迭代器仍然小于<code>tail</code>迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p>
<h4 id="3、Introsort-内省式排序"><a href="#3、Introsort-内省式排序" class="headerlink" title="3、Introsort 内省式排序"></a>3、Introsort 内省式排序</h4><p>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 <code>O(n2)</code>。为避免此种情况出现，stl使用了内省式排序，其行为大部分与上面所说的<code>median-of-three Quick Sort</code>完全相同，是当分割行为有恶化为<code>O(n2)</code>的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 <code>O(nlgn)</code>，又比一开始就使用堆排序来得好。</p>
<p>如函数源码，其中，<code>__introsort\_loop</code>便是内省式排序，第三个参数所调用的函数<code>__lg()</code>便是用来判断分割恶化情况，代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class Size&gt;
inline Size __lg(Size n) &#123;
	Size k;
	for (k &#x3D; 0; n &gt; 1; n &gt;&gt;&#x3D; 1) ++k;
	return k;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即求<code>lg(n)</code>（取下整），意味着快速排序的递归调用最多 <code>2*lg(n)</code> 层。</p>
<h4 id="4、stable-sort稳定排序"><a href="#4、stable-sort稳定排序" class="headerlink" title="4、stable_sort稳定排序"></a>4、stable_sort稳定排序</h4><p>对于相等元素，在排序后保证相对位置不变</p>
<h2 id="3-5、元编程"><a href="#3-5、元编程" class="headerlink" title="3.5、元编程"></a>3.5、元编程</h2><p>依赖于语言自身提供的模板机制</p>
<h2 id="3-6、模板类型推导"><a href="#3-6、模板类型推导" class="headerlink" title="3.6、模板类型推导"></a>3.6、模板类型推导</h2><p>详见第<strong>10</strong>章节</p>
<h2 id="3-7、std-function-amp-amp-std-bind函数封装器"><a href="#3-7、std-function-amp-amp-std-bind函数封装器" class="headerlink" title="3.7、std::function&amp;&amp;std::bind函数封装器"></a>3.7、std::function&amp;&amp;std::bind函数封装器</h2><p>std::function也称作仿函数，属于C++的一种模板类，是一种通用、多态的函数封装器，对可调用实体进行统一封装，封装后的std::function实例可以进行存储、复制和调用，且是一种类型安全的包裹。  </p>
<p>可调用对象包括：</p>
<ul>
<li>普通函数指针;</li>
<li>lambda表达式</li>
<li>函数对象(重载operator()符);</li>
<li>类成员函数指针；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;functional&gt;
#include &lt;iostream&gt;
using namespace std;

std::function&lt; int(int)&gt; Functional;

&#x2F;&#x2F; 普通函数
int TestFunc(int a)
&#123;
    return a;
&#125;

&#x2F;&#x2F; Lambda表达式
auto lambda &#x3D; [](int a)-&gt;int&#123; return a; &#125;;

&#x2F;&#x2F; 函数对象
class Functor
&#123;
public:
    int operator()(int a)
    &#123;
        return a;
    &#125;
&#125;;

&#x2F;&#x2F; 1.类成员函数
&#x2F;&#x2F; 2.类静态函数
class TestClass
&#123;
public:
    int ClassMember(int a) &#123; return a; &#125;
    static int StaticMember(int a) &#123; return a; &#125;
&#125;;

int main()
&#123;
    &#x2F;&#x2F; 普通函数
    Functional &#x3D; TestFunc;
    int result &#x3D; Functional(10);
    cout &lt;&lt; &quot;普通函数：&quot;&lt;&lt; result &lt;&lt; endl;

    &#x2F;&#x2F; Lambda表达式
    Functional &#x3D; lambda;
    result &#x3D; Functional(20);
    cout &lt;&lt; &quot;Lambda表达式：&quot;&lt;&lt; result &lt;&lt; endl;

    &#x2F;&#x2F; 类对象
    Functor testFunctor;
    Functional &#x3D; testFunctor;
    result &#x3D; Functional(30);
    cout &lt;&lt; &quot;仿函数：&quot;&lt;&lt; result &lt;&lt; endl;

    &#x2F;&#x2F; 类成员函数
    TestClass testObj;
    Functional &#x3D; std::bind(&amp;TestClass::ClassMember, testObj, std::placeholders::_1);
    result &#x3D; Functional(40);
    cout &lt;&lt; &quot;类成员函数：&quot;&lt;&lt; result &lt;&lt; endl;

    &#x2F;&#x2F; 类静态函数
    Functional &#x3D; TestClass::StaticMember;
    result &#x3D; Functional(50);
    cout &lt;&lt; &quot;类静态函数：&quot;&lt;&lt; result &lt;&lt; endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>std::bind</strong><br>用来将可调用对象与其参数一起绑定，，绑定后的结果可以使用function进行保存。<br>基本用法：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;functional&gt;

void call_when_even(int x, const std::function&lt;void(int)&gt;&amp; f)
&#123;
	if (!(x &amp; 1))  &#x2F;&#x2F;x % 2 &#x3D;&#x3D; 0
	&#123;
		f(x);
	&#125;
&#125;

void output(int x)
&#123;
	std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;
&#125;

void output_add_2(int x)
&#123;
	std::cout &lt;&lt; x + 2 &lt;&lt; &quot; &quot;;
&#125;

int main(void)
&#123;
	&#123;
		auto fr &#x3D; std::bind(output, std::placeholders::_1);
		for (int i &#x3D; 0; i &lt; 10; ++i)
		&#123;
			call_when_even(i, fr);
		&#125;

		std::cout &lt;&lt; std::endl;
	&#125;
	&#123;
	auto fr &#x3D; std::bind(output_add_2, std::placeholders::_1);

	for (int i &#x3D; 0; i &lt; 10; ++i)
	&#123;
		call_when_even(i, fr);
	&#125;

	std::cout &lt;&lt; std::endl;
&#125;

	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>std::placeholders::_1是占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;functional&gt;

void output(int x, int y)
&#123;
	std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;
&#125;

int main(void)
&#123;
	std::bind(output, 1, 2)();  &#x2F;&#x2F;输出1 2
	std::bind(output, std::placeholders::_1, 2)(1);&#x2F;&#x2F;输出1 2
	std::bind(output, 2, std::placeholders::_1)(1);&#x2F;&#x2F;输出2 1

	std::bind(output, 2, std::placeholders::_2)(1);  &#x2F;&#x2F;error:调用时没有第二个参数

	std::bind(output, 2, std::placeholders::_2)(1, 2);  &#x2F;&#x2F;输出 2 2   调用时第一个参数被吞掉了
	
	std::bind(output, std::placeholders::_1, std::placeholders::_2)(1, 2);  &#x2F;&#x2F;输出 1 2
	std::bind(output, std::placeholders::_2, std::placeholders::_1)(1, 2);  &#x2F;&#x2F;输出 2 1


	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>bind和function配合使用</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;functional&gt;

class A
&#123;
public:
	int i_ &#x3D; 0;

	void output(int x, int y)
	&#123;
		std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;
	&#125;
&#125;;

int main(void)
&#123;
	A a;
	std::function&lt;void(int, int)&gt; fr &#x3D;
		std::bind(&amp;A::output, &amp;a, std::placeholders::_1, std::placeholders::_2);
	fr(1, 2);  &#x2F;&#x2F;输出 1 2

	std::function&lt;int&amp;(void)&gt; fr_i &#x3D; std::bind(&amp;A::i_, &amp;a);  &#x2F;&#x2F;vs13的bug，绑定成员变量要报错
	fr_i() &#x3D; 123;

	std::cout &lt;&lt; a.i_ &lt;&lt; std::endl;  &#x2F;&#x2F;输出 123

	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>fr表示将A的成员函数output的指针和对象a绑定</p>
<h2 id="3-8、std-tuple"><a href="#3-8、std-tuple" class="headerlink" title="3.8、std::tuple"></a>3.8、std::tuple</h2><p>是一个模板类，用于构造成员量较少的轻量临时结构体struct</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

struct B
&#123;
	int a;
	int b;
&#125;;

int main()
&#123;
	tuple&lt;int, string,double&gt; bb &#x3D; make_tuple(24, &quot;Hello&quot;, 1.265);
	cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;0&gt;(bb) &lt;&lt; endl;
	cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;1&gt;(bb) &lt;&lt; endl;
	cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;2&gt;(bb) &lt;&lt; endl;
	B bt;	
	bt.a &#x3D; 2;
	bt.b &#x3D; 3;
	tuple&lt;int, B&gt; aa &#x3D; make_tuple(12,bt);
	cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; get&lt;0&gt;(aa) &lt;&lt; endl;
	cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; (get&lt;1&gt;(aa)).a &lt;&lt; endl;
	cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; (get&lt;1&gt;(aa)).b &lt;&lt; endl;

	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="4、面向对象编程"><a href="#4、面向对象编程" class="headerlink" title="4、面向对象编程"></a>4、面向对象编程</h1><ul>
<li><strong>类与对象</strong><br>类是对象的模板，一个类可以创建多个相同的对象；对象是类的实例，是按照类的规则创建的。   </li>
<li><strong>封装</strong><br>封装指的是将数据以及使用它们的方法进行逻辑编组，简单的说就是：<font color=red>数据隐藏和提供访问接口</font>。为实现类的封装性，类的类型定义提供了三种访问权限：公有，私有，受保护</li>
</ul>
<p><strong>面向对象的基本特征</strong></p>
<ul>
<li><p><strong>1、抽象</strong><br>抽象就是找出对象的共性，然后将这些对象抽象成类。因此，类是对象的抽象，对象是类的具体表现形式。寻找共性，提出特性。    </p>
</li>
<li><p><strong>2、封装</strong><br>封装是指把类的属性和方法隐藏在内部，对外只提供访问数据的接口。这样使用者只需关心对象对外提供的接口，无需了解具体的实现形式。</p>
</li>
<li><p><strong>3、继承</strong><br>继承可以使一个类拥有其他类的功能，在无需重复实现同样功能的前提下扩展自身的新增功能。</p>
</li>
<li><p><strong>4、多态</strong><br>多态是指不同对象对同样的消息作出的不同响应，比如发出吃饭的指令，中国人用筷子，美国人用刀叉。通过运行时绑定绑定实现多态，在将子类对象的地址赋给父类，在调用方法时，根据具体的对象类型执行相应子类的方法。</p>
</li>
</ul>
<h2 id="4-1、继承与派生"><a href="#4-1、继承与派生" class="headerlink" title="4.1、继承与派生"></a>4.1、继承与派生</h2><p>从同一个基类派生出类似的类，在基类中实现通用功能，并在派生类中实现特有功能，以实现每个类的独一无二；<br>派生类中包含两大部分内容：从基类继承而来的和派生类新增的。</p>
<h3 id="4-1-1、继承的类型"><a href="#4-1-1、继承的类型" class="headerlink" title="4.1.1、继承的类型"></a>4.1.1、继承的类型</h3><p>在访问属性中，不仅要考虑基类成员所声明的访问属性，还要考虑派生类所声明的对基类的继承方式，根据这两个因素共同决定基类成员在派生类中的访问属性：</p>
<ul>
<li>公有继承：基类的公有成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有；    </li>
<li>私有继承：基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有；     </li>
<li>保护继承：基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有。保护成员的意思是：不能被类外部使用(<strong>类外</strong>)，但能够被派生类继承；    </li>
</ul>
<p>总的来说：    </p>
<ul>
<li>私有成员只能被基类访问，不能被派生类继承；    </li>
<li>保护成员不能被类外访问，但可以被继承；    </li>
<li>基类与派生类之间是is-a的关系，比如黑色的马是马的一种；</li>
</ul>
<p><strong>需要注意的是</strong>：<br>在继承时如果不显示指明public、private、protected，<strong>class默认是private继承，而struct默认是public继承</strong>。</p>
<h3 id="4-1-2、构造函数、析构函数"><a href="#4-1-2、构造函数、析构函数" class="headerlink" title="4.1.2、构造函数、析构函数"></a>4.1.2、构造函数、析构函数</h3><p><font color=green><strong>默认构造函数</strong></font>   </p>
<ul>
<li>当用户未显式定义构造函数时，编译器会为其生成默认构造函数，默认构造函数是无参数类型；   </li>
<li>当用户定义了构造函数时，编译器不会为其生成默认构造函数；   <h4 id="1、执行顺序"><a href="#1、执行顺序" class="headerlink" title="1、执行顺序"></a>1、执行顺序</h4>只讨论构造函数，不涉及非类类型成员     </li>
</ul>
<p><font color=purple>构造函数执行顺序</font><br>按照先后顺序主要有三大部分：</p>
<ul>
<li>派生类自身的static静态成员部分；</li>
<li>继承部分；</li>
<li>派生类自身的类类型对象成员部分，不包括static类对象成员，但包括const类类型对象成员；</li>
<li>派生类自身剩余部分；</li>
</ul>
<p><font color=red><strong>细节展开如下:</strong></font></p>
<ul>
<li>静态类类型成员构造函数，如果有多个，则按照声明顺序；</li>
<li>虚继承基类的构造函数，如果有多个，则按照继承顺序；</li>
<li>抽象基类的构造函数，如果有多个，则按照继承顺序；</li>
<li>普通基类的构造函数，如果有多个，则按照继承顺序；</li>
<li>普通类类型成员的构造函数(包括const类类型成员)，如果有多个，则按照声明顺序；</li>
<li>派生类自己的构造函数；</li>
</ul>
<p>示例：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;抽象类A
class A
&#123;
public:
	A()
	&#123;
		cout&lt;&lt;&quot;抽象类A的构造函数&quot;&lt;&lt;endl;
	&#125;
	&#x2F;&#x2F;纯虚函数fun
	virtual void fun1() &#x3D; 0;
&#125;;
 
&#x2F;&#x2F;抽象类B
class B
&#123;
public:
	B()
	&#123;
		cout&lt;&lt;&quot;抽象类B的构造函数&quot;&lt;&lt;endl;
	&#125;
	&#x2F;&#x2F;纯虚函数fun
	virtual void fun2() &#x3D; 0;
&#125;;
 
&#x2F;&#x2F;普通类C
class C
&#123;
public:
	C()
	&#123;
		cout&lt;&lt;&quot;类C的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
&#x2F;&#x2F;普通类D
class D
&#123;
public:
	D()
	&#123;
		cout&lt;&lt;&quot;类D的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
&#x2F;&#x2F;普通类E
class E
&#123;
public:
	E()
	&#123;
		cout&lt;&lt;&quot;类E的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
&#x2F;&#x2F;普通类F
class F
&#123;
public:
	F()
	&#123;
		cout&lt;&lt;&quot;类F的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
&#x2F;&#x2F;普通类G
class G
&#123;
public:
	G()
	&#123;
		cout&lt;&lt;&quot;类G的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
&#x2F;&#x2F;普通类H
class H
&#123;
public:
	H()
	&#123;
		cout&lt;&lt;&quot;类H的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
&#x2F;&#x2F;普通类M
class M
&#123;
public:
	M()
	&#123;
		cout&lt;&lt;&quot;类M的构造函数&quot;&lt;&lt;endl;
	&#125;
&#125;;
 
class Test: public A,public B,virtual public C,virtual public D,public E,public F
&#123;
public:
	Test():B(),A(),D(),C(),F(),E(),m(M())
	&#123;
		cout&lt;&lt;&quot;类Test的构造函数&quot;&lt;&lt;endl;
	&#125;
	void fun1()
	&#123;
	&#125;
	void fun2()
	&#123;
	&#125;
private:
	G g;
	static H h;
	const M m;
&#125;;


H Test::h;


int main()
&#123;
    Test test;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：   </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">类H的构造函数
类C的构造函数
类D的构造函数
抽象类A的构造函数
抽象类B的构造函数
类E的构造函数
类F的构造函数
类G的构造函数
类M的构造函数
类Test的构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p><font color=liceblue>析构函数的执行顺序与构造函数相反</font></p>
<h4 id="2、抛出异常"><a href="#2、抛出异常" class="headerlink" title="2、抛出异常"></a>2、抛出异常</h4><p>可以抛出异常，但不建议使用，会造成内存资源泄漏</p>
<ul>
<li>构造函数<br>对象只有在构造函数执行完毕之后才算是完全构造妥当，如果在构造函数内抛出异常，控制权就会被转移出构造函数之外，由于对象没有被正常构造完毕，之后的析构函数便不会被调用，进而造成内存泄漏。</li>
<li>析构函数<br>如果析构函数内抛出异常，而且没有被自身捕捉的话，那么它的执行是不完整的，没有完成它应该执行的每一步事情，会导致不可预期的错误</li>
</ul>
<h3 id="4-1-3、拷贝构造函数"><a href="#4-1-3、拷贝构造函数" class="headerlink" title="4.1.3、拷贝构造函数"></a>4.1.3、拷贝构造函数</h3><ul>
<li>普通拷贝构造函数；</li>
<li>移动拷贝构造函数；</li>
</ul>
<h4 id="1、普通拷贝构造函数"><a href="#1、普通拷贝构造函数" class="headerlink" title="1、普通拷贝构造函数"></a>1、普通拷贝构造函数</h4><p>对于用户自定义类且没有显式实现普通拷贝构造函数时，编译器会生成默认拷贝构造函数，默认拷贝构造函数是浅拷贝操作。C++内置类通常会根据实际场景实现拷贝构造函数，比如std::string类，它的普通拷贝构造函数就不是浅拷贝，而是深拷贝</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A
&#123;
public:
    A():ptr_m_(new int(10 + construct_count))&#123;
        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;
    &#125;
    static int construct_count;
    int *ptr_m_;

    ~A()
    &#123;
        delete ptr_m_;
        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;



int main()
&#123;
    A a01;
    A a02 &#x3D; a01;  &#x2F;&#x2F; 调用拷贝构造函数
    std::cout &lt;&lt; *(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; std::endl;

    std::string str01 &#x3D; &quot;hello&quot;;
    std::string str02 &#x3D; str01;
    std::cout &lt;&lt; str01 &lt;&lt; &quot; &quot; &lt;&lt; str02 &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 1
10 10
hello hello
destructor

*** Error in &#96;.&#x2F;main&#39;: double free or corruption (fasttop): 0x0000000001b5cc20 ***
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7f75f5d297e5]
&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7f75f5d3237a]
&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(cfree+0x4c)[0x7f75f5d3653c]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类A是用户自定义类，编译器生成默认拷贝构造函数，由于是浅拷贝，a01与a02中的成员指针ptr_m_均指向同一块堆空间，会被析构两次，error。<br>而C++内置类型string的拷贝构造函数实现了深拷贝，故str01与str02中的成员char数组是两块不相干的堆空间，只是存放的内容一样而已</p>
<h4 id="2、移动拷贝构造函数"><a href="#2、移动拷贝构造函数" class="headerlink" title="2、移动拷贝构造函数"></a>2、移动拷贝构造函数</h4><p>详见<strong>第5、引用</strong></p>
<h3 id="4-1-4、继承构造函数"><a href="#4-1-4、继承构造函数" class="headerlink" title="4.1.4、继承构造函数"></a>4.1.4、继承构造函数</h3><p>如果基类中存在多个构造函数，通常需要在继承类中声明相同数量的构造函数，以便在构造函数的初始化列表中完成基类的实例化，例如：   </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Human
&#123;
public:
    Human(int32_t age):age_(age)&#123;&#125;
    Human(std::string name):name_(name)&#123;&#125;
    
    int32_t getAge()
    &#123;
        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;
    &#125;

    int32_t getName()
    &#123;
        std::cout &lt;&lt; &quot;My name is: &quot; &lt;&lt; name_ &lt;&lt; std::endl;
    &#125;

protected:
    int32_t age_;
    std::string name_;
&#125;;

class Children : public Human
&#123;
public:
    Children(int32_t age):Human(age)&#123;&#125;
    Children(std::string name):Human(name)&#123;&#125;
&#125;;

int main()
&#123;
    Children child01(10);
    child01.getAge();
    Children child02(&quot;Jack&quot;);
    child02.getName();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">I am 10 years old
My name is: Jack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样的实现会很繁琐，C++11之后可以使用继承构造函数解决这一问题，关键字using</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Human
&#123;
public:
    Human(int32_t age):age_(age)&#123;&#125;
    Human(std::string name):name_(name)&#123;&#125;
    
    int32_t getAge()
    &#123;
        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;
    &#125;

    int32_t getName()
    &#123;
        std::cout &lt;&lt; &quot;My name is: &quot; &lt;&lt; name_ &lt;&lt; std::endl;
    &#125;

protected:
    int32_t age_;
    std::string name_;
&#125;;

class Children : public Human
&#123;
public:
    using Human::Human;
&#125;;

int main()
&#123;
    Children child01(10);
    child01.getAge();
    Children child02(&quot;Jack&quot;);
    child02.getName();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><font color=darkred><strong>注意</strong></font></p>
<ul>
<li>因为调用的是基类的构造函数，对于派生类中的成员，如果需要初始化，就需要自行解决；</li>
<li>继承构造函数是隐式声明的，即如果一个基类的构造函数不被使用，编译器是不会为其生成真实代码的；</li>
<li>对于多个基类的情况，需要注意继承构造函数冲突的问题，类似下面例1；</li>
<li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数；</li>
<li>一旦使用了继承构造函数， 编译器就不会再为派生类生成默认构造函数了；</li>
</ul>
<p>例1：</p>
<pre class="line-numbers language-none"><code class="language-none">struct A&#123;A(int)&#123;&#125;&#125;;
struct B&#123;B(int)&#123;&#125;&#125;;
struct C:A,B&#123;
using A::A;
using B::B;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法是，显示定义继承类的冲突构造函数</p>
<pre class="line-numbers language-none"><code class="language-none">struct C:A,B&#123;
using A::A;
using B::B;
C(int)&#123;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-1-5、虚继承"><a href="#4-1-5、虚继承" class="headerlink" title="4.1.5、虚继承"></a>4.1.5、虚继承</h3><p>虚继承用于解决菱形继承中的二义性问题，比如：<br>B、C分别继承自A，而D又同时继承自B和C，那么当通过D访问A中的成员时，就无法确定是通过B继承自A的成员，还是通过C继承自A的成员。    </p>
<p>此时就需要让B和C虚继承A，这样D中就只有一份A。   </p>
<p>虚继承中的父类称作<font color=darkred>虚基类(注意区别于概念：抽象类)</font></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A 
&#123;
    public:
    char c1;
    A()
    &#123;
        c1 &#x3D; &#39;A&#39;;
        std::cout &lt;&lt; &quot;A default constructor&quot; &lt;&lt; std::endl;
    &#125;
    A(char c1)
    &#123;
        this-&gt;c1 &#x3D; c1;
        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class B:public virtual A
&#123;
    public:
    char c2;
    B()
    &#123;
        c2 &#x3D; &#39;B&#39;;
        std::cout &lt;&lt; &quot;B default constructor&quot; &lt;&lt; std::endl;
    &#125;
    B(char c1, char c2):A(c1)
    &#123;
        this-&gt;c2 &#x3D; c2;
        std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class C:public virtual A
&#123;
    public:
    char c3;
    C()
    &#123;
        c3 &#x3D; &#39;C&#39;;
        std::cout &lt;&lt; &quot;C default constructor&quot; &lt;&lt; std::endl;
    &#125;
    C(char c1, char c3):A(c1)
    &#123;
        this-&gt;c3 &#x3D; c3;
        std::cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class D:public B, public C
&#123;
    public:
    char c4;
    D()
    &#123;
        c4 &#x3D; &#39;D&#39;;
        std::cout &lt;&lt; &quot;D default constructor&quot; &lt;&lt; std::endl;
    &#125;
    D(char c1, char c2,char c3, char c4):B(c1,c2), C(c3,c3)
    &#123;
        this-&gt;c4 &#x3D; c4;
        std::cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

int main()
&#123;
    D obj(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;);
    std::cout &lt;&lt; &quot;\nresult:\n&quot; &lt;&lt; obj.c1 &lt;&lt; obj.c2 &lt;&lt; obj.c3 &lt;&lt; obj.c4 &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">A default constructor
B constructor
C constructor
D constructor

result:
Abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1、虚继承的本质"><a href="#1、虚继承的本质" class="headerlink" title="1、虚继承的本质"></a>1、虚继承的本质</h4><p>虚继承的本质类似于虚函数的原理，通过虚表指针 + 虚基类表实现。<br>编译器在编译阶段会为虚继承关系的派生类生成虚表指针 + 虚基类表，在运行阶段使虚表指针指向虚基类表。<br>虚基类表存放的是虚表指针到共有基类内存地址的偏移量，详见下方<strong>第2节的内存布局分析</strong></p>
<h4 id="2、虚继承关系中对象的内存布局"><a href="#2、虚继承关系中对象的内存布局" class="headerlink" title="2、虚继承关系中对象的内存布局"></a>2、虚继承关系中对象的内存布局</h4><p><code>环境：ubuntu 64bit + gdb</code><br>gdb查看内存布局方法参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43374723/article/details/107128204">Linux 下利用 gdb 查看 C++ 对象内存分布</a>   </p>
<ul>
<li><p>先查看菱形继承时对象内存布局情况:   </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;

class A
&#123;
public:
    int32_t data_a_;
&#125;;  &#x2F;&#x2F; sizeof(A) &#x3D; 4

class B : public A
&#123;
public:
    int32_t data_b_;
&#125;;  &#x2F;&#x2F; sizeof(B) &#x3D; 4 + 4

class C : public A
&#123;
public:
    int32_t data_c_;
&#125;;  &#x2F;&#x2F; sizeof(C &#x3D; 4 + 4

class D : public B, public C
&#123;
public:
    int32_t data_d_;
&#125;;  &#x2F;&#x2F; sizeof(D) &#x3D;  (4 + 4) + (4 + 4) + 4


int main()
&#123;
    std::cout &lt;&lt; &quot;sizeof(A) &#x3D; &quot; &lt;&lt; sizeof(A)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(B) &#x3D; &quot; &lt;&lt; sizeof(B)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(C) &#x3D; &quot; &lt;&lt; sizeof(C)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(D) &#x3D; &quot; &lt;&lt; sizeof(D)&lt;&lt; std::endl;
    A a;
    B b;
    C c;
    D d;
    &#x2F;&#x2F;d.data_a_ &#x3D; 10;
    d.data_b_ &#x3D; 20;
    d.data_c_ &#x3D; 30;
    d.data_d_ &#x3D; 40;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sizeof(A) &#x3D; 4
sizeof(B) &#x3D; 8
sizeof(C) &#x3D; 8
sizeof(D) &#x3D; 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用gdb查看内存布局</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(gdb) p d
$1 &#x3D; &#123;
  &lt;B&gt; &#x3D; &#123;
    &lt;A&gt; &#x3D; &#123;
      data_a_ &#x3D; 0
    &#125;,
    members of B:
    data_b_ &#x3D; 20
  &#125;,
  &lt;C&gt; &#x3D; &#123;
    &lt;A&gt; &#x3D; &#123;
      data_a_ &#x3D; 1431654656
    &#125;,
    members of C:
    data_c_ &#x3D; 30
  &#125;,
  members of D:
  data_d_ &#x3D; 40
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到对象的d中有两份class A</p>
</li>
<li><p>再来对比虚继承关系中的内存布局：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;

class A
&#123;
public:
    int32_t data_a_;
&#125;;  &#x2F;&#x2F; sizeof(A) &#x3D; 4

class B : virtual public A
&#123;
public:
    int32_t data_b_;
&#125;;  &#x2F;&#x2F; sizeof(B) &#x3D; 8 + 4 + 4

class C : virtual public A
&#123;
public:
    int32_t data_c_;
&#125;;  &#x2F;&#x2F; sizeof(C &#x3D; 8 + 4 + 4

class D : public B, public C
&#123;
public:
    int32_t data_d_;
&#125;;  &#x2F;&#x2F; sizeof(D) &#x3D; （8 + 4） + （8 + 4） + 4 + 4


int main()
&#123;
    std::cout &lt;&lt; &quot;sizeof(A) &#x3D; &quot; &lt;&lt; sizeof(A)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(B) &#x3D; &quot; &lt;&lt; sizeof(B)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(C) &#x3D; &quot; &lt;&lt; sizeof(C)&lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;sizeof(D) &#x3D; &quot; &lt;&lt; sizeof(D)&lt;&lt; std::endl;
    A a;
    B b;
    C c;
    D d;
    d.data_a_ &#x3D; 10;
    d.data_b_ &#x3D; 20;
    d.data_c_ &#x3D; 30;
    d.data_d_ &#x3D; 40;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sizeof(A) &#x3D; 4
sizeof(B) &#x3D; 16
sizeof(C) &#x3D; 16
sizeof(D) &#x3D; 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里注意到一点，sizeof(D)的结果为40，这是由编译器的内存对齐原则引起的，如果设置为4byte对齐规则的话，sizeof(D)的结果就与预期的32一致。<br>通过gdb查看对象d的内存布局如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(gdb) p d
$1 &#x3D; &#123;
  &lt;B&gt; &#x3D; &#123;
    &lt;A&gt; &#x3D; &#123;
      data_a_ &#x3D; 10
    &#125;,
    members of B:
    _vptr.B &#x3D; 0x555555557c40 &lt;vtable for D+24&gt;,
    data_b_ &#x3D; 20
  &#125;,
  &lt;C&gt; &#x3D; &#123;
    members of C:
    _vptr.C &#x3D; 0x555555557c58 &lt;VTT for D&gt;,
    data_c_ &#x3D; 30
  &#125;,
  members of D:
  data_d_ &#x3D; 21845
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到对象d内只有一份class A，基类B、C中各有一个虚表指针指向各自的虚基类表，而各自的虚基类表之中存放的是各自虚表指针到共有基类A的内存偏移量。<br>虚基类表的内容看参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiejingfa/article/details/48028491">【C++拾遗】 从内存布局看C++虚继承的实现原理</a><br>文章基于VS编译，可以直观的看到虚基类表存放的内容。<br><font color=red>PS：至于虚基类在内存中的布局，由编译器决定，比如g++编译器，虚基类的内存位置于首先声明的子类B之中，而VS编译器则位于子类B、C的后面，单独存放。</font></p>
<h3 id="4-1-6、默认函数"><a href="#4-1-6、默认函数" class="headerlink" title="4.1.6、默认函数"></a>4.1.6、默认函数</h3><p>类提供的默认函数：</p>
</li>
<li><p>构造函数</p>
</li>
<li><p>拷贝构造函数</p>
</li>
<li><p>赋值运算符（operator=）</p>
</li>
<li><p>移动构造函数</p>
</li>
<li><p>移动拷贝函数</p>
</li>
<li><p>移动赋值运算符</p>
</li>
<li><p>析构函数</p>
</li>
</ul>
<p>默认操作符函数：</p>
<ul>
<li>operator ,</li>
<li>operator ＆</li>
<li>operator ＆＆</li>
<li>operator *</li>
<li>operator -＞</li>
<li>operator -＞*</li>
<li>operator new</li>
<li>operator delete </li>
</ul>
<p>其中默认构造函数、析构函数、拷贝构造函数、赋值操作符均是public且inline；</p>
<h4 id="1、默认函数的添加与删除"><a href="#1、默认函数的添加与删除" class="headerlink" title="1、默认函数的添加与删除"></a>1、默认函数的添加与删除</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Car
&#123;
public:
    Car() &#x3D; default;  &#x2F;&#x2F; 在用户自定义构造函数的情况下，再要求编译器提供默认版本
    Car(int32_t color);
    Car(const Car&amp;) &#x3D; delete;  &#x2F;&#x2F; 删除拷贝构造函数
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="4-2、多态"><a href="#4-2、多态" class="headerlink" title="4.2、多态"></a>4.2、多态</h2><h3 id="4-2-1、概念"><a href="#4-2-1、概念" class="headerlink" title="4.2.1、概念"></a>4.2.1、概念</h3><p>多态分为两种：</p>
<ul>
<li>编译时多态：函数的重载、模板的实现，静态绑定；</li>
<li>运行时多态：虚函数机制，动态绑定；</li>
</ul>
<p>多态，顾名思义就是一个事物有多种形态。在C++程序设计中，多态是指在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p>
<p>多态可以简单概括为”一个接口，多种实现”。向不同的对象发送同一个消息会产生不同的行为。也就是说，每个对象可以用自己的方式去响应共同的消息，这体现了面向对象编程的抽象机制。    </p>
<ul>
<li>virtual声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个一维的虚函数表称作虚表，该类的每一个对象都包含一个指向虚表的虚指针；</li>
<li>虚函数表对应类，虚函数指针对应类的对象；</li>
<li>类的多态是基于虚函数的动态绑定机制；</li>
<li>类的多态性只发生在对象的指针或引用操作中，因为普通对象在传递时会发生截断现象；</li>
</ul>
<h3 id="4-2-2、原理"><a href="#4-2-2、原理" class="headerlink" title="4.2.2、原理"></a>4.2.2、原理</h3><p><strong>先看一下普通例子：</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C"> 1 #include &quot;stdafx.h&quot;
 2 #include &lt;iostream&gt; 
 3 #include &lt;stdlib.h&gt;
 4 using namespace std; 
 5 
 6 class Father
 7 &#123;
 8 public:
 9     void Face()
10     &#123;
11         cout &lt;&lt; &quot;Father&#39;s face&quot; &lt;&lt; endl;
12     &#125;
13 
14     void Say()
15     &#123;
16         cout &lt;&lt; &quot;Father say hello&quot; &lt;&lt; endl;
17     &#125;
18 &#125;;
19 
20 
21 class Son:public Father
22 &#123;
23 public:     
24     void Say()
25     &#123;
26         cout &lt;&lt; &quot;Son say hello&quot; &lt;&lt; endl;
27     &#125;
28 &#125;;
29 
30 void main()
31 &#123;
32     Son son;
33     Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换
34     pFather-&gt;Say();
35 &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果为：<br>Father say hello   </p>
<p><strong>从编译角度而言：</strong><br>在编译阶段要确定每个对象调用函数（非虚函数）的地址，称作静态绑定，当我们将Son类的对象son的地址赋给pFather时，编译器进行了类型转换，此时编译器认为变量pFather指向的就是Father类对象，当发生pFather-&gt;Say()调用时,调用的自然是Father对象的Say函数。  </p>
<p><strong>从内存角度：</strong><br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE935ccb384dcbed26f643dbac8a50cf8c/38320" alt="image02"></p>
<p>将Son类对象转换为Father类型时，该对象就被认为是原对象整个内存模型的上半部分，也就是上图中”Father类对象内存空间”，当发生pFather-&gt;Say()调用时,调用的自然是Father对象的Say函数。</p>
<p><strong>多态例子：</strong>   </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stdafx.h&quot;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
using namespace std;

class Father
&#123;
public:
    void Face()
    &#123;
        cout &lt;&lt; &quot;Father&#39;s face&quot; &lt;&lt; endl;
    &#125;

    virtual void Say()
    &#123;
        cout &lt;&lt; &quot;Father say hello&quot; &lt;&lt; endl;
    &#125;
&#125;;


class Son:public Father
&#123;
public:
    void Say()
    &#123;
        cout &lt;&lt; &quot;Son say hello&quot; &lt;&lt; endl;
    &#125;
&#125;;

void main()
&#123;
    Son son;
    Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换
    pFather-&gt;Say();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果为：<br>Son say hello    </p>
<p>编译阶段编译器会为Father类和Son类各自生成一张虚函数表，用于存放各自虚函数Say的地址<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCEf70f5819e509a0107c4092904c1359eb/39917" alt="image03"></p>
<p>如何定位虚函数表？<br>编译阶段编译器会为类对象生成一个虚指针vptr(尚未初始化)，该指针用于指向对象所属类的虚函数表。   </p>
<p>虚表指针何时指向虚函数表？<br>对象构造时虚表指针完成初始化，指向虚函数表内存地址</p>
<p><font color=red><strong>编译期行为</strong></font>   </p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void main()
&#123;
    Son son;
    Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换
    pFather-&gt;Say();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管pFather是基类类型的指针，但编译阶段编译器会判断Say函数是否是虚函数，如果不是，则在编译期就能确定Say的调用地址；如果是，则编译器会为其指定虚表指针vptr，运行阶段通过虚函数表查找并调用真实的Say函数</p>
<ul>
<li> <font color=red>虚表可以继承：如果子类没有实现虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数；</font></li>
<li>派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同；</li>
</ul>
<h3 id="4-2-3、虚函数的继承原则"><a href="#4-2-3、虚函数的继承原则" class="headerlink" title="4.2.3、虚函数的继承原则"></a>4.2.3、虚函数的继承原则</h3><p>派生类中虚函数的实现四原则：函数名、参数列表、返回类型、常量性const与基类的完全一致。     </p>
<p>**==四原则有一个例外就是返回类型==**，当基类的返回类型是基类的指针或引用时，派生类中的返回类型可以是派生类的指针或引用；<br>**==另一个例外就是==**：虚析构函数，基类与派生类的析构函数名字就不一样；</p>
<h3 id="4-2-4、纯虚函数与抽象类"><a href="#4-2-4、纯虚函数与抽象类" class="headerlink" title="4.2.4、纯虚函数与抽象类"></a>4.2.4、纯虚函数与抽象类</h3><p>在虚函数后添加关键字”= 0”声明纯虚函数：</p>
<ul>
<li>纯虚函数通常不需要定义，只要声明即可；   </li>
</ul>
<p><font color=red><strong>ps：纯虚函数是可以有定义的</strong></font></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 纯虚函数可以有定义体
class Animal
&#123;
public:
    Animal()&#123;std::cout &lt;&lt; &quot;animal constructer&quot; &lt;&lt; std::endl;&#125;
    ~Animal()&#123;&#125;;
    virtual void Breather() &#x3D; 0;
&#125;;

void Animal::Breather()
&#123;
    std::cout &lt;&lt; &quot;animal can breather&quot; &lt;&lt; std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>基类中即使实现了纯虚函数的定义，该基类依然是抽象类；</li>
<li>包含纯虚函数的类称作抽象类；</li>
<li>抽象类不能实例化对象，ps：准确的说是不能直接实例化，在继承关系中，抽象基类的构造函数会在派生类中执行；</li>
<li>抽象类不能实例化是指不能通过静态或动态的方式直接构建类的对象，但可以定义抽象类的指针，因为指针并不是类的对象，而是指向类对象的地址；</li>
<li>纯虚函数多用在基类中声明一个接口，在派生类中做具体实现，所以抽象类要求其派生类必须实现纯虚函数；</li>
<li>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象；</li>
</ul>
<p>例如Animal类定义纯虚函数breather，在派生类Dog、Fish、Bird中实现具体的呼吸方式</p>
<p><strong>==纯虚函数存在的意义==</strong><br>定义纯虚函数的真正目的是为了定义抽象类，而并不是函数本身。与之相比，在Java中，定义抽象类的语法是 abstract class，也就是在类的一级直接指定（当然虚函数前也还是要加上abstract关键字），这样似乎更合理一些。</p>
<p><strong>==抽象类存在的意义==</strong><br>抽象类在继承关系中提供统一的接口，而在派生类中根据需要完成接口的具体实现<br>比如基类Animal、派生类Dog，Dog可以实例化为各种对象，比如big dog、small dog等等，这是合理的，但对于Animal实例化一个对象就没有什么实际意义，于是干脆就拒绝此类实例化对象。避免基类实例化就是抽象类存在的实际意义。</p>
<h3 id="4-2-5、正确理解：抽象类不能实例化对象"><a href="#4-2-5、正确理解：抽象类不能实例化对象" class="headerlink" title="4.2.5、正确理解：抽象类不能实例化对象"></a>4.2.5、正确理解：抽象类不能实例化对象</h3><p>“抽象类不能实例化对象”这句话并不是十分正确，应该说是不能直接实例化对象，在继承关系中，抽象基类的构造函数会在派生类的构造函数之中执行，例如</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Animal
&#123;
public:
    Animal()&#123;std::cout &lt;&lt; &quot;animal constructer&quot; &lt;&lt; std::endl;&#125;
    ~Animal()&#123;&#125;
    virtual void Breather() &#x3D; 0;
&#125;;

class Dog : public Animal
&#123;
public:
    Dog()&#123;std::cout &lt;&lt; &quot;dog constructer&quot; &lt;&lt; std::endl;&#125;
    ~Dog()&#123;&#125;
    void Breather()
    &#123;
        std::cout &lt;&lt; &quot;dog can breather&quot; &lt;&lt; std::endl;
    &#125;
&#125;;


int main()
&#123;
    Animal a;  &#x2F;&#x2F; error
    Animal *pAnimal &#x3D; new Dog;
    pAnimal-&gt;Breather();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main函数中对象a的构造会导致编译报错，因为抽象类Animal不能够实例化对象a；<br>关闭<code>Animal a</code>后代码运行结果是：    </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">animal constructer
dog constructer
dog can breather<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>说明在派生类Dog构造时链式调用了抽象基类的构造函数，为基类申请了运行时空间。</p>
<h3 id="4-2-6、虚函数与构造函数、析构函数"><a href="#4-2-6、虚函数与构造函数、析构函数" class="headerlink" title="4.2.6、虚函数与构造函数、析构函数"></a>4.2.6、虚函数与构造函数、析构函数</h3><ul>
<li><p>==构造函数==<br>构造函数不能为virtual，因为</p>
<ul>
<li>多态性是基于对象的指针或引用的类型来调用正确的重载函数，而构造函数执行时，该对象还未构造完成，内存空间尚未申请完毕，自然无从知晓其类型是什么；    </li>
<li>对象中指向vtable的虚指针vptr是存在于对象的内存空间之中的，此时对象尚未构造完成，vptr是无法指向vtable；</li>
</ul>
</li>
<li><p>==析构函数==<br>普通析构函数在继承关系中可能存在内存泄漏的问题，示例：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Fish
&#123;
public:
~ Fish()
&#123;
&#125;
&#125;

class Carp : public Fish
&#123;
public:
~ Carp()
&#123;
&#125;
&#125;

void DeleteMem(Fish *input)
&#123;
delete input;
&#125;
Carp *myDinner &#x3D; new Carp;
DeleteMem(myDinner);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>DeleteMem调用时，派生类对象指针myDinner会隐式转换为基类Fish，当delete操作时调用的是基类的析构函数，派生类的析构函数并未调用，出现内存泄漏。   </p>
</li>
<li><p><em>==基类的析构函数建议声明为virtual==</em>*</p>
</li>
<li><p>==析构函数可以为纯虚函数==<br>纯虚析构函数必须实现其定义，否则会在继承关系的链接时报错：undefined reference to ****，这是因为例如构造函数、析构函数等，不同于其他成员函数，在编译时会生成一个调用链，当需要生成基类析构函数调用链时发现并未定义此析构函数，就会报错。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base
&#123;
public:
   Base()
   &#123;
   &#125;
   virtual ~Base() &#x3D; 0; &#x2F;&#x2F;pure virtual
&#125;;

Base::~Base()&#x2F;&#x2F;function body
&#123;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>==构造函数、析构函数内是否可以调用继承关系里的虚函数？==<br>可以调用，但不建议如此编程，即使调用虚函数，动态绑定也不会生效，因为</p>
<ul>
<li>在继承关系中，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，由于此时子类还没有构造，所以此时的对象还是父类的，不会触发多态，调用的是父类相关函数；</li>
<li>析构函数也是一样，子类先进行析构，如果有虚函数的话，由于子类对象已经被析构了，此时执行的是父类的相关函数函数；</li>
</ul>
</li>
</ul>
<p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是该构造函数或析构函数自身类型定义的版本。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Car
&#123;
public:
    Car(int32_t num):wheel_num_(num)
    &#123;
        show();
    &#125;

    ~Car()
    &#123;
        show();
    &#125;

    virtual void show() 
    &#123;
        printf(&quot;Car has %d wheels\n&quot;, wheel_num_);
    &#125;
    int32_t wheel_num_;
&#125;;

class BigCar : public Car
&#123;
public:
    BigCar(int32_t num): window_num_(num), Car(num)
    &#123;
        show();
    &#125;
    ~BigCar()
    &#123;
        show();
    &#125;

    void show()
    &#123;
        printf(&quot;BigCar has %d windows\n&quot;, window_num_);
    &#125;
    int32_t window_num_;
&#125;;

int main()
&#123;
    std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl;
    BigCar *ptr_big &#x3D; new BigCar(4);
    std::cout &lt;&lt; &quot;\ndestruct&quot; &lt;&lt; std::endl;
    delete ptr_big;
    &#x2F;&#x2F;Car *ptr &#x3D; ptr_big;
    &#x2F;&#x2F;ptr-&gt;show();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行结果</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">construct
Car has 4 wheels
BigCar has 4 windows

destruct
BigCar has 4 windows
Car has 4 wheels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-2-7、虚函数与inline"><a href="#4-2-7、虚函数与inline" class="headerlink" title="4.2.7、虚函数与inline"></a>4.2.7、虚函数与inline</h3><p>==<strong>虚函数是否可以声明为inline？</strong>==   </p>
<p>首先要明白virtual与inline的作用是什么：   </p>
<ul>
<li>虚函数用于实现运行时的多态，或称作动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，在调用内联函数的地方就地代码展开，不生成独立汇编代码，避免频繁调用的开销；</li>
<li>虚函数在运行期动态绑定，而内联函数在编译期进行代码展开；   </li>
</ul>
<p>==结论：==<br>虚函数可以申明为inline，但要具体到编译期的实际情况：</p>
<ul>
<li>如果编译器在编译的时候就可以确定该虚函数的决议，则编译器以inline方式静态决议该虚函数；</li>
<li>如果编译器在编译的时候不能决定，则必须在运行时决议虚函数，此时虚函数不能以inline函数的方式调用；</li>
</ul>
<h2 id="4-3、友元"><a href="#4-3、友元" class="headerlink" title="4.3、友元"></a>4.3、友元</h2><h3 id="4-3-1、友元函数"><a href="#4-3-1、友元函数" class="headerlink" title="4.3.1、友元函数"></a>4.3.1、友元函数</h3><p>在类外定义、不属于当前类的函数且可以访问当前类的所有成员，包括 public、protected、private，称作友元函数。<br>友元函数并不是类的成员函数，所以不可以在类内定义，仅声明即可。    </p>
<p><strong>==一个函数可以是多个类的友元函数==</strong></p>
<p>友元函数可以是：</p>
<ul>
<li>普通全局函数，非类的成员函数；</li>
<li>其他类的成员函数</li>
</ul>
<h4 id="1、非类的成员函数作为友元函数"><a href="#1、非类的成员函数作为友元函数" class="headerlink" title="1、非类的成员函数作为友元函数"></a>1、非类的成员函数作为友元函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;
using namespace std;
class Student&#123;
public:
    Student(char *name, int age, float score);
public:
    friend void show(Student *pstu);  &#x2F;&#x2F;将show()声明为友元函数
private:
    char *m_name;
    int m_age;
    float m_score;
&#125;;
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;
&#x2F;&#x2F;非成员函数
void show(Student *pstu)&#123;
    cout&lt;&lt;pstu-&gt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;pstu-&gt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;pstu-&gt;m_score&lt;&lt;endl;
&#125;
int main()&#123;
    Student stu(&quot;小明&quot;, 15, 90.6);
    show(&amp;stu);  &#x2F;&#x2F;调用友元函数
    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);
    show(pstu);  &#x2F;&#x2F;调用友元函数
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>show是一个全局范围内的非成员函数，声明为friend之后，可以访问类的所有成员。<br>但show仍不同与成员函数，它并不能直接访问类的成员，需要借助类的对象进行访问</p>
<h4 id="2、其他类的成员函数声明为友元函数"><a href="#2、其他类的成员函数声明为友元函数" class="headerlink" title="2、其他类的成员函数声明为友元函数"></a>2、其他类的成员函数声明为友元函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;
using namespace std;
class Address;  &#x2F;&#x2F;提前声明Address类
&#x2F;&#x2F;声明Student类
class Student&#123;
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
&#125;;
&#x2F;&#x2F;声明Address类
class Address&#123;
private:
    char *m_province;  &#x2F;&#x2F;省份
    char *m_city;  &#x2F;&#x2F;城市
    char *m_district;  &#x2F;&#x2F;区（市区）
public:
    Address(char *province, char *city, char *district);
    &#x2F;&#x2F;将Student类中的成员函数show()声明为友元函数
    friend void Student::show(Address *addr);
&#125;;
&#x2F;&#x2F;实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;
void Student::show(Address *addr)&#123;
    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;
    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;
&#125;
&#x2F;&#x2F;实现Address类
Address::Address(char *province, char *city, char *district)&#123;
    m_province &#x3D; province;
    m_city &#x3D; city;
    m_district &#x3D; district;
&#125;
int main()&#123;
    Student stu(&quot;小明&quot;, 16, 95.5f);
    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);
    stu.show(&amp;addr);
   
    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);
    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);
    pstu -&gt; show(paddr);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-3-2、友元类"><a href="#4-3-2、友元类" class="headerlink" title="4.3.2、友元类"></a>4.3.2、友元类</h3><p>友元类中的所有成员函数都是另外一个类的友元函数。</p>
<p>例如将类 B 声明为类 A的友元类，那么类B中的所有成员函数都是类A的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;
using namespace std;
class Address;  &#x2F;&#x2F;提前声明Address类
&#x2F;&#x2F;声明Student类
class Student&#123;
public:
    Student(char *name, int age, float score);
public:
    void show(Address *addr);
private:
    char *m_name;
    int m_age;
    float m_score;
&#125;;
&#x2F;&#x2F;声明Address类
class Address&#123;
public:
    Address(char *province, char *city, char *district);
public:
    &#x2F;&#x2F;将Student类声明为Address类的友元类
    friend class Student;
private:
    char *m_province;  &#x2F;&#x2F;省份
    char *m_city;  &#x2F;&#x2F;城市
    char *m_district;  &#x2F;&#x2F;区（市区）
&#125;;
&#x2F;&#x2F;实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;
void Student::show(Address *addr)&#123;
    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;
    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;
&#125;
&#x2F;&#x2F;实现Address类
Address::Address(char *province, char *city, char *district)&#123;
    m_province &#x3D; province;
    m_city &#x3D; city;
    m_district &#x3D; district;
&#125;
int main()&#123;
    Student stu(&quot;小明&quot;, 16, 95.5f);
    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);
    stu.show(&amp;addr);
   
    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);
    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);
    pstu -&gt; show(paddr);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-4、函数重载"><a href="#4-4、函数重载" class="headerlink" title="4.4、函数重载"></a>4.4、函数重载</h2><ul>
<li>函数重载是指同一个作用域内，一组具有不同参数列表的同名函数；</li>
<li>函数重载有效的解决了由于参数类型不同而造成的函数名的数量膨胀问题；</li>
</ul>
<p><font color=red><strong>函数的返回值类型与函数重载没有关系</strong></font>     </p>
<h3 id="4-4-1、C-语言不支持函数重载的原因"><a href="#4-4-1、C-语言不支持函数重载的原因" class="headerlink" title="4.4.1、C 语言不支持函数重载的原因"></a>4.4.1、C 语言不支持函数重载的原因</h3><p>C++在编译时会对函数进行重命名，而C语言则保留原始函数名。<br>C++函数重命名的规则是：**(返回值类型+)作用域 + 原始函数名 + 参数列表**     </p>
<ul>
<li><strong>作用域</strong>包括函数的命名空间和所属类；    </li>
<li><strong>返回值类型</strong>根据编译器的不同可加可不加；   </li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">using namespace test
&#123;
    int Calc::add(int a,int b); &#x3D;&gt; int_test_Calc_add_int_int
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>PS：函数重命名虽然可能带上返回值类型，但C++语法上并不会将返回值类型当做重载条件，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class B
&#123;
public:
    int32_t data_b_;
    void compare()
    &#123;
        std::cout &lt;&lt; &quot;from inherit class B call&quot; &lt;&lt; std::endl;
    &#125;
    int32_t compare()
    &#123;
        std::cout &lt;&lt; &quot;from inherit class B call&quot; &lt;&lt; std::endl;
        return 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>compare重载就会报错</p>
<h3 id="4-4-2、const与函数重载"><a href="#4-4-2、const与函数重载" class="headerlink" title="4.4.2、const与函数重载"></a>4.4.2、const与函数重载</h3><p>判断B，C，D是否是函数重载？</p>
<pre class="line-numbers language-none"><code class="language-none">B:  int calcA(int a, int b);
    int calcA(const int a, const int b);
    
C:  int calcA(int *a, int *b);
    int calcA(int * const a, int * const b);  

D:  int calcA(int *a, int *b);
    int calcA(const int *a, const int * b);      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><font color=red><strong>函数重载时，是不会考虑参数本身的const修饰符</strong></font><br>比如B和C中cosnt都是修饰参数a，b本身的，所以不属于函数重载，而D中cosnt 是修饰int*，是函数重载。<br>B与C项中的形参本质上是按值传递，在函数体内形参只是实参的一个副本，做任何修改对实参都没有影响。</p>
<h3 id="4-4-3、overload、override、overwrite"><a href="#4-4-3、overload、override、overwrite" class="headerlink" title="4.4.3、overload、override、overwrite"></a>4.4.3、overload、override、overwrite</h3><p><font color=green><strong>overload重载</strong></font></p>
<ul>
<li>相同的范围（在同一个类中或同一个作用域中）；</li>
<li>函数名字相同；</li>
<li>参数不同；</li>
</ul>
<p><font color=green><strong>override覆盖</strong></font><br>是指派生类函数覆盖基类函数，特征是：</p>
<ul>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>函数名字相同；</li>
<li>参数相同；</li>
<li>基类函数必须有virtual 关键字；</li>
</ul>
<p><font color=green><strong>overwrite重写/隐藏</strong></font><br>是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p>
<ul>
<li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏；</li>
<li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)；</li>
</ul>
<h2 id="4-5、运算符重载"><a href="#4-5、运算符重载" class="headerlink" title="4.5、运算符重载"></a>4.5、运算符重载</h2><p>运算符重载的方式有两种：</p>
<ul>
<li>类成员函数方式；</li>
<li>友元函数方式；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">class Step
&#123;
    private:
    int num;
    public:
    Step(int num)&#123;this-&gt;num &#x3D; num;&#125;
    Step&amp; operator ++();  &#x2F;&#x2F; 前自增
    friend Step operator+(const Step &amp;p1, const Step &amp;p2);
&#125;;

Step&amp; Step::operator ++()
&#123;
    num++;
    return *this;
&#125;

Step operator+(const Step &amp;p1, const Step &amp;p2)
&#123;
    return Step(p1.num + p2.num);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>通常，单目运算符重载使用类成员函数形式，双目运算符重载使用友元函数形式；</li>
<li>但是()和[]必须使用类成员函数，&lt;&lt;和&gt;&gt;必须使用友元方式；</li>
<li>重载后的运算符不能改变操作数的个数和运算符优先级，所以运算符的参数类别不能有默认值；</li>
<li>不是所有运算符都能重载，详见<strong>C++零的1.11节</strong>；</li>
</ul>
<p><font color=purple>‘.*‘指向类成员的指针操作符,详见<strong>4.9.10</strong>节</font></p>
<h3 id="4-5-1、前自增和后自增运算符"><a href="#4-5-1、前自增和后自增运算符" class="headerlink" title="4.5.1、前自增和后自增运算符"></a>4.5.1、前自增和后自增运算符</h3><pre class="line-numbers language-none"><code class="language-none">class Step
&#123;
    private:
    int num;
    public:
    Step(int num)&#123;this-&gt;num &#x3D; num;&#125;
    Step&amp; operator ++();  &#x2F;&#x2F;前自增
    Step operator ++(int);  &#x2F;&#x2F;后自增
&#125;;

Step&amp; Step::operator ++()
&#123;
    num++;
    return *this;
&#125;

Step Step::operator ++(int)
&#123;
    Step temp &#x3D; *this;
    ++*this;
    return temp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如果只重载了前自增运算符，那么后自增操作会与前自增操作绑定，使两者的行为相同；</li>
<li>为了区分前自增和后自增运算符重载函数，后自增重载函数的参数列表需要增加一个int以示区别，在使用中完全可以忽略这个参数，编译器会对其进行特殊处理；</li>
</ul>
<h3 id="4-5-2、函数对象"><a href="#4-5-2、函数对象" class="headerlink" title="4.5.2、函数对象"></a>4.5.2、函数对象</h3><p>可以通过重载函数调用符operator()实现函数对象，详见<strong>4.9.7</strong>节</p>
<h3 id="4-5-3、operator-赋值运算符重载"><a href="#4-5-3、operator-赋值运算符重载" class="headerlink" title="4.5.3、operator=赋值运算符重载"></a>4.5.3、operator=赋值运算符重载</h3><ul>
<li><font color=red><strong>operator=返回reference to *this</strong></font>   </li>
</ul>
<p>对于赋值操作，通常需要支持链式操作：</p>
<pre class="line-numbers language-none"><code class="language-none">int x,y,z;
x&#x3D;y&#x3D;z&#x3D;15;
x&#x3D;(y&#x3D;(z&#x3D;15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这里15首先被赋值给z，然后将其结果再赋值给y，为了实现”链式赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参，这是class实现赋值操作符应该遵守的协议：</p>
<pre class="line-numbers language-none"><code class="language-none">class Wideget
&#123;
    public;
    ......
    
    Wideget&amp; operator&#x3D;(const Widget &amp;rhs)
    &#123;
        ......
        return *this;
    &#125;
    
    Wideget&amp; operator+&#x3D;(const Widget &amp;rhs)
    &#123;
        ......
        return *this;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个规则，对于内置类型和标准容器string、vector等都是默认支持的。   </p>
<p><font color=red><strong>“自我赋值”和”异常安全”</strong></font><br>在赋值操作时可能会出现自己赋值给自己的情况，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">class Bitmap 
&#123;
    ......
&#125;

class Widget
&#123;
    ......
    private:
    Bitmap *pb;   &#x2F;&#x2F;动态内存
&#125;

&#x2F;&#x2F; 一份不安全的operator&#x3D;实现
Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)
&#123;
    delete pb;
    pb &#x3D; new Bitmap(*rhs.bp);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当出现自我赋值时，*this与rhs是同一个对象，operator=中delete pb的操作使得pb变成一个指向被删除的Bitmap的指针，第二步的new操作时，rhs.pb已经是一个不确定的指针了，这样是危险的。改进方法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 不具备&quot;异常安全&quot;的operator&#x3D;实现
Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)
&#123;
    if(this &#x3D;&#x3D; &amp;rhs) return *this;
    delete pb;
    pb &#x3D; new Bitmap(*rhs.bp);
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一步虽然进行了自我检查，但仍然存在问题，因为，在delete pb之后，new操作可能出现异常（内存不足或Bitmap构造异常），最终会导致pb变成一个不确定的指针<br><font color=green>在C语言中使用 malloc/calloc 等分配内存的函数时，可以通过检查其返回值判断内存申请是否成，但C++ 里，如果 new 分配内存失败，默认是抛出异常的，会自动跳过后面的代码。</font>   </p>
<p>改进方式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)
&#123;
    if(this &#x3D;&#x3D; &amp;rhs) return *this;
    Bitmap *temp &#x3D;pb;
    pb &#x3D; new Bitmap(*rhs.bp);
    delete temp;
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一步是自我检查，第二步是备份一个this的pb，即使第三步的new异常，this中的pb仍然保持不变，是安全的的</p>
<h2 id="4-9、其他"><a href="#4-9、其他" class="headerlink" title="4.9、其他"></a>4.9、其他</h2><h3 id="4-9-1、is-a和has-a"><a href="#4-9-1、is-a和has-a" class="headerlink" title="4.9.1、is-a和has-a"></a>4.9.1、is-a和has-a</h3><ul>
<li><p>继承类与派生类之间是is-a关系，比如黑色的马是马的一种；</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Horse
&#123;
    ......
&#125;;

class WitheHorse : public Horse
&#123;
    ......
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>汽车与轮胎之间是has-a关系</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Tyre
&#123;
    ......
&#125;;

class Car
&#123;
    class Tyre;
    ......
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>友元的关系是单向的，如果声明了类 B 是类 A 的友元类，不等于类 A是类B的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员；</p>
</li>
<li><p>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类；</p>
</li>
<li><p>友元关系不能继承，基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类，PS：   </p>
<ul>
<li>不能继承是指派生类自身的成员函数不能继承友元权限；</li>
<li>但派生类可以通过基类的接口间接访问友元关系，比如派生类继承的基类成员函数<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt; 
using namespace   std; 
class B; 
class A 
&#123; 
	int a; 
public: 
	A(int x&#x3D;0) &#123; a&#x3D;x; &#125; 
	friend class B; 
&#125;; 
class B 
&#123; 
	int b; 
public: 
	void fun(A&amp; ob)&#123; cout &lt;&lt; ob.a &lt;&lt; endl;&#125; 
&#125;; 
 
class C:public B
&#123; 
public: 
	&#x2F;&#x2F;void fun2(A&amp; ob)&#123; cout &lt;&lt;ob.a &lt;&lt;endl;&#125;   &#x2F;&#x2F;派生类新加的函数却不能访问A，此句会报错
&#125;; 
 
void   main() 
&#123; 
	A a(55); 
	C c; 
	c.fun(a); &#x2F;&#x2F;C是B的派生类   通过基类B的函数fun仍然可以访问 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h3 id="4-9-2、const之于函数重载"><a href="#4-9-2、const之于函数重载" class="headerlink" title="4.9.2、const之于函数重载"></a>4.9.2、const之于函数重载</h3><ul>
<li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参，则这个时候无论加不加const对实参不会产生任何影响；</li>
<li>但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。所以，引用、指针传递具备const重载性，而值传递的const不具备重载性；</li>
</ul>
<h3 id="4-9-3、类成员初始化"><a href="#4-9-3、类成员初始化" class="headerlink" title="4.9.3、类成员初始化"></a>4.9.3、类成员初始化</h3><p>1、类成员初始化主要有两种方式：   </p>
<ul>
<li>默认初始化：在构造函数中，未进入构造函数代码块之前，会对类成员进行默认初始化（编译器会在编译期生成相应代码，在运行期执行）</li>
<li>列表初始化：在构造函数中，未进入构造函数代码块之前，为类成员分配内存空间之时，且在冒号后面存在类成员的赋值表达式；</li>
</ul>
<p><strong>==2、列表初始化顺序==</strong><br>第一顺序是类类型成员，然后是普通类型成员，然后由各自的声明顺序决定，并不是冒号后的初始化列表中的顺序。</p>
<p><strong>==3、必须使用列表初始化的情况==</strong></p>
<ul>
<li>初始化引用成员；</li>
<li>初始化常量成员；</li>
<li>当发生基类构造函数调用时，且其拥有一组参数；</li>
<li>当发生类成员构造函数调用时，且其拥有一组参数；</li>
</ul>
<h3 id="4-9-5、只能动态创建或只能静态创建类对象"><a href="#4-9-5、只能动态创建或只能静态创建类对象" class="headerlink" title="4.9.5、只能动态创建或只能静态创建类对象"></a>4.9.5、只能动态创建或只能静态创建类对象</h3><p>类对象的创建方式有两种：</p>
<ul>
<li>静态创建，例如ClassA a<br>静态创建一个对象就是由编译器在栈空间上分配内存，直接调用构造函数</li>
<li>动态创建，例如ClassA *pa = new ClassA()<br>动态创建就是由new操作符在堆空间上分配内存，分为两步：<ul>
<li>operator new()在堆上搜索并申请一块空间；</li>
<li>在申请的这块堆上调用构造函数创建类对象</li>
</ul>
</li>
</ul>
<h4 id="1、只静态创建"><a href="#1、只静态创建" class="headerlink" title="1、只静态创建"></a>1、只静态创建</h4><p>就是关闭动态创建类对象的途径，只需将new、delete操作符声明为private即可</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A  
&#123;  
private:  
     void* operator new(size_t t)&#123;&#125;          &#x2F;&#x2F;注意函数的第一个参数和返回值都是固定的  
     void operator delete(void* ptr)&#123;&#125;       &#x2F;&#x2F;重载了new就需要重载delete  
public:  
     A()&#123;&#125;  
     ~A()&#123;&#125;  
&#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>且其派生类也无法动态创建对象</p>
<h4 id="2、只动态创建"><a href="#2、只动态创建" class="headerlink" title="2、只动态创建"></a>2、只动态创建</h4><p>不能静态分配，即不能直接调用类的构造函数。   </p>
<p>怎样才能实现类的构造函数不能被直接调用呢？首先想到的就是将类的构造函数设为private，这样就无法在类外部调用构造函数来构造对象了，只能使用new运算符动态创建。但是，这种做法行不通。因为new运算符过程分为两步，C++提供new运算符的重载，其实只允许重载operator new()函数，而operator new()函数用于内存分配，无法提供构造函数功能。因此，将构造函数设为private不可行。    </p>
<p>从另外一个角度分析，对象静态分配时，是由编译器调用构造函数在栈空间中构造对象。当对象使用完毕，编译器又会调用析构函数来释放栈空间中的类对象。如果编译器无法调用类的析构函数，会怎样呢？其实，编译器在为类对象分配栈空间时，同时也会检查类的析构函数的访问性（其实不光是析构函数，只要是非静态的函数，编译器都会进行检查）。如果类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存。    </p>
<p>因此，可以将析构函数设为private，这样就无法在栈上建立类对象了。实现如下：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A  
&#123;  
public:  
     A()&#123;&#125;  
     void destory()&#123;delete this;&#125;  
private:  
     ~A()&#123;&#125;  
&#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此方法虽然能实现只能动态建立对象，但是有一个缺点：无法实现继承。因为如果A作为基类的话，则析构函数通常要设为virtual，然后在子类中被重写，以实现多态。因此析构函数不能设为private。    </p>
<p>将析构函数设为protected即可，这样类外无法访问protected成员，同时也可解决继承问题</p>
<h3 id="4-9-6、对象调用成员变量、成员函数的原理"><a href="#4-9-6、对象调用成员变量、成员函数的原理" class="headerlink" title="4.9.6、对象调用成员变量、成员函数的原理"></a>4.9.6、对象调用成员变量、成员函数的原理</h3><p>先看一个例子：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base
&#123;
public:
    void print()&#123;std::cout &lt;&lt; m &lt;&lt; std::endl;&#125;
    void show()&#123;std::cout &lt;&lt; &quot;Base class&quot; &lt;&lt; std::endl;&#125;
    int m;
&#125;;

int main()
&#123;
    Base *pBase &#x3D; nullptr;
    pBase-&gt;print();
    pBase-&gt;show();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行结果会怎样？  </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pBase-&gt;print();  &#x2F;&#x2F; 报错
pBase-&gt;show();  &#x2F;&#x2F; 正常执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>指针pBase为nullptr，在没有构造Base对象的情况下它是如何调用show函数、print函数又为何会报错？这就要看一看在编译期类发生了什么：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 伪代码
class Base
&#123;
    int m;
&#125;；

void _Base_print(Base *this)
&#123;
    ......
    this-&gt;m;
    ......
&#125;

void _Base_show(Base *this)
&#123;
    ......
    ......
    ......
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>在编译期，除了虚函数，其他的成员方法都被静态编译了，函数地址已经确定；  </li>
<li>对非虚函数的成员函数调用，并不需要this指针，与对象是否构造自然就无关联了；   </li>
<li>只有在访问对象的非静态成员时才会检查this指针，如果为null则报错：<ul>
<li>这就引出另一个问题，如果上述例子中pBase未初始化，pBase-&gt;print()调用不会报错，只是此时对象的成员m是个不确定值；</li>
</ul>
</li>
<li>虚函数的调用是通过虚表指针vptr指向虚表vtable进而动态绑定，而vptr是在构造函数执行期间进行的初始化，故虚函数的动态绑定依赖于对象的构造；</li>
</ul>
<h3 id="4-9-7、函数对象"><a href="#4-9-7、函数对象" class="headerlink" title="4.9.7、函数对象"></a>4.9.7、函数对象</h3><p>从概念上来说，函数对象是可以如函数一样使用的对象；从实现上来说，函数对象是重载了函数调用符operator()的类对象</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;

using namespace std;

&#x2F;&#x2F; struct that behaves as a unary function
template &lt;typename elementType&gt;
struct DisplayElement
&#123;
    void operator () (const elementType&amp; element) const
    &#123;
        cout &lt;&lt; element &lt;&lt; &#39; &#39;;
    &#125;
&#125;;

int main ()
&#123;
    vector &lt;int&gt; vecIntegers;

    for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)
        vecIntegers.push_back (nCount);

    list &lt;char&gt; listChars;
    for (char nChar &#x3D; &#39;a&#39;; nChar &lt; &#39;k&#39;; ++nChar)
        listChars.push_back (nChar);

    cout &lt;&lt; &quot;Displaying the vector of integers: &quot; &lt;&lt; endl;

    &#x2F;&#x2F; Display the array of integers
    for_each ( vecIntegers.begin ()    &#x2F;&#x2F; Start of range
          , vecIntegers.end ()        &#x2F;&#x2F; End of range
          , DisplayElement &lt;int&gt; () ); &#x2F;&#x2F; Unary function object

    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; &quot;Displaying the list of characters: &quot; &lt;&lt; endl;

    &#x2F;&#x2F; Display the list of characters
    for_each ( listChars.begin ()        &#x2F;&#x2F; Start of range
          , listChars.end ()        &#x2F;&#x2F; End of range
          , DisplayElement &lt;char&gt; () );&#x2F;&#x2F; Unary function object

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="1、优势"><a href="#1、优势" class="headerlink" title="1、优势"></a>1、优势</h4><ul>
<li>对象可以在内部修改而不用改动外部接口，因此设计更灵活，更富有弹性；</li>
<li>函数对象具备存储先前调用结果的优势，利用类的成员实现存储；</li>
<li>函数对象会被编译器以内联形式实现，从而更进一步增强了性能；</li>
</ul>
<h3 id="4-9-8、static静态成员变量与函数"><a href="#4-9-8、static静态成员变量与函数" class="headerlink" title="4.9.8、static静态成员变量与函数"></a>4.9.8、static静态成员变量与函数</h3><ul>
<li>static成员变量只属于类，不属于任何对象，故static成员变量不占据对象内存空间；</li>
<li>对于类成员而言，static关键字只需在声明处添加，定义处不用添加；</li>
<li>static成员函数只能访问static成员变量；</li>
<li>详见<strong>7.1</strong>节；</li>
</ul>
<h3 id="4-9-9、类的内存空间占用"><a href="#4-9-9、类的内存空间占用" class="headerlink" title="4.9.9、类的内存空间占用"></a>4.9.9、类的内存空间占用</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#pragma pack(1)
class Empty  &#x2F;&#x2F; 只占1byte，用于占位符
&#123;

&#125;;


class Human  &#x2F;&#x2F; members &#x3D; int32_t
&#123;
public:
    Human(int32_t age):age_(age)&#123;&#125;
    
    int32_t getAge()
    &#123;
        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;
    &#125;

protected:
    int32_t age_;
&#125;;

class Children : public Human &#x2F;&#x2F; members &#x3D; int32_t + int32_t
&#123;
public:
   Children(int32_t age):Human(age)&#123;&#125;
   int32_t scores_;
&#125;;

class Student : public virtual Human  &#x2F;&#x2F; members &#x3D; int32_t + int32_t + int64_t(point is 64bit)
&#123;
public:
   Student(int32_t age):Human(age)&#123;&#125;
   int32_t class_no_;
&#125;;

class Expressor : public Human  &#x2F;&#x2F; members &#x3D; int32_t + int64_t(point is 64bit)
&#123;
public:
    Expressor(int32_t age):Human(age)&#123;&#125;
    virtual void who()
    &#123;
        std::cout &lt;&lt; &quot;I am is an expresser&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

class Worker : public Human  &#x2F;&#x2F; members &#x3D; int32_t
&#123;
public:
    Worker(int32_t age):Human(age)&#123;&#125;
    static int32_t company_no_;
&#125;;

int32_t Worker::company_no_ &#x3D; 0;

int main()
&#123;
    int32_t *ptr;
    std::cout &lt;&lt; &quot;point size is: &quot; &lt;&lt;  sizeof(ptr) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;empty class size is: &quot; &lt;&lt; sizeof(Empty) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;human class size is: &quot; &lt;&lt; sizeof(Human) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;derived children class size is: &quot; &lt;&lt; sizeof(Children) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;derived and virtual inheried Student class size is: &quot; &lt;&lt; sizeof(Student) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;derived and virtual function Expressor class size is: &quot; &lt;&lt; sizeof(Expressor) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;derived and static member Worker class size is: &quot; &lt;&lt; sizeof(Worker) &lt;&lt; std::endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">point size is: 8
empty class size is: 1
human class size is: 4
derived children class size is: 8
derived and virtual inheried Student class size is: 16
derived and virtual function Expressor class size is: 12
derived and static member Worker class size is: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-9-10、’-’指向类成员的指针运算符"><a href="#4-9-10、’-’指向类成员的指针运算符" class="headerlink" title="4.9.10、’.*’指向类成员的指针运算符"></a>4.9.10、’.*’指向类成员的指针运算符</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
 
class Testpm &#123;
public:
   void _func1() &#123; cout &lt;&lt; &quot;_func1\n&quot;; &#125;
   int _num;
&#125;;
 
&#x2F;&#x2F; 定义指针pmfunc and pmdate，分别指向成员函数_func1()以及成员变量_num。
void (Testpm::*pmfunc)() &#x3D; &amp;Testpm::_func1;
int Testpm::*pmdata &#x3D; &amp;Testpm::_num;
 
int main() 
&#123;
   Testpm aTestpm;
   Testpm *pTestpm &#x3D; new Testpm;
 
    &#x2F;&#x2F; 访问成员函数
   (aTestpm.*pmfunc)();
   (pTestpm-&gt;*pmfunc)(); 
 
    &#x2F;&#x2F; 访问成员数据
   aTestpm.*pmdata &#x3D; 1;
   pTestpm-&gt;*pmdata &#x3D; 2;
 
   cout  &lt;&lt; aTestpm.*pmdata &lt;&lt; endl
         &lt;&lt; pTestpm-&gt;*pmdta &lt;&lt; endl;
   delete pTestpm;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：  </p>
<pre class="line-numbers language-none"><code class="language-none">_func1
_func1
1
2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-9-11、对象构造时的线程安全"><a href="#4-9-11、对象构造时的线程安全" class="headerlink" title="4.9.11、对象构造时的线程安全"></a>4.9.11、对象构造时的线程安全</h3><p>构造期间不要泄漏this指针：</p>
<ul>
<li>不要在构造函数中注册任何回调函数；</li>
<li>不要在构造函数中将this指针传递给其他对象(子对象除外)，更不能传递给跨线程的对象；</li>
</ul>
<p>这是因为构造函数执行期间对象尚未初始化完成，此时别的对象可能访问一个半成品，导致难以预料的行为。</p>
<h3 id="4-9-12、对象销毁时的线程安全问题"><a href="#4-9-12、对象销毁时的线程安全问题" class="headerlink" title="4.9.12、对象销毁时的线程安全问题"></a>4.9.12、对象销毁时的线程安全问题</h3><p>如果互斥器作为成员，它可以起到保护函数临界区的作用，但是析构函数却破坏了这一规则，因为它会把互斥器析构掉：</p>
<pre class="line-numbers language-none"><code class="language-none">Foo:~FOO()
&#123;
    MutexLockGuard(mutex_)
    &#x2F;&#x2F; delete,free etc  (1)
&#125;

FOO::update()
&#123;
    MutexLockGuard(mutex_)  &#x2F;&#x2F; (2)
    &#x2F;&#x2F; make use  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假如线程A、B都能看到Foo对象x</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; thread A
delete x;
x&#x3D;NULL;

&#x2F;&#x2F; thread B
if(x)
&#123;
    x.update();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>线程A执行到了析构函数的(1)处，已经持有了互斥锁，而B已经通过了if(x)检查，阻塞在了(2)处。<br>当B重新获得mutex_时mutex_已经被析构释放了，就会发生不确定行为，这个例子同时也说明了:  </p>
<ul>
<li>delete后将指针置为NULL并不能防止二次释放;</li>
<li>类成员mutex不能保护对象的析构；</li>
</ul>
<h1 id="5、引用"><a href="#5、引用" class="headerlink" title="5、引用"></a>5、引用</h1><p>引用就是某一目标的别名，这个目标可以是左值，对应的就是左值引用，若目标是右值，对应的就是右值引用</p>
<h2 id="5-1、左值与右值"><a href="#5-1、左值与右值" class="headerlink" title="5.1、左值与右值"></a>5.1、左值与右值</h2><ul>
<li>C++11中所有的值必属于左值、右值两者之一；</li>
<li>C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值<br>,举个例子:<ul>
<li>int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作也是不允许的；</li>
</ul>
</li>
<li>C++11对C++98中的右值进行了扩充,C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）:<ul>
<li>纯右值，指的是临时变量包括表达式的值、函数返回值、原始字面量、lambda表达式等；</li>
<li>将亡值则是C++11新增的与右值引用相关，通常是将要被移动的对象，比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值</li>
</ul>
</li>
</ul>
<h2 id="5-2、引用的特点"><a href="#5-2、引用的特点" class="headerlink" title="5.2、引用的特点"></a>5.2、引用的特点</h2><ul>
<li>引用只是一个目标的别名，不分配内存空间；</li>
<li>引用不能为空，必须要初始化；</li>
<li>引用只能初始化一次，且初始化之后不能再成为其他目标的别名；</li>
<li>右值引用不接受左值，左值引用通常不能接受右值，但常量左值引用是个例外，它是万能引用，可以接受常量左值，非常量左值、右值；</li>
<li><strong>==具名右值引用视作左值==</strong><pre class="line-numbers language-C" data-language="C"><code class="language-C">void PrintValue(int&amp; i)
&#123;
    cout&lt;&lt;&quot;left&quot;&lt;&lt;endl;
&#125;

void PrintValue(int&amp;&amp; i)
&#123;
    cout&lt;&lt;&quot;right&quot;&lt;&lt;endl;
&#125;

void Forward(int&amp;&amp; i)
&#123;
    PrintValue(i);
&#125;

&#x2F;&#x2F; 当调用Forward(2)时，调用的是PrintValue(int&amp; i)，因为此时原始字面量2变成了具名变量i，即左值引用，输出结果便是&quot;left&quot;。

int &amp;&amp;var01 &#x3D; 20;  &#x2F;&#x2F; OK，右值引用
int &amp;&amp;var02 &#x3D; var01;  &#x2F;&#x2F; error，var01虽然是字面常量20的右值引用，但在当前表达式中它是具名变量，就变成了左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="5-3、左值引用"><a href="#5-3、左值引用" class="headerlink" title="5.3、左值引用"></a>5.3、左值引用</h2><h2 id="5-4、右值引用"><a href="#5-4、右值引用" class="headerlink" title="5.4、右值引用"></a>5.4、右值引用</h2><p>**==对右值引用的理解==**：<br>右值引用本身只是一种类型而已，它真正的作用是在与右值引用相关的操作，例如移动构造函数、移动赋值运算符等。对占用内存较大的类对象，比如内含指向较大内存空间的成员指针、容器等，当它们作为临时值时，离开表达式之会便会被销毁，右值引用可以延长它们的生命周期、避免内存的拷贝(需要根据场景用户自行管理内存)：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A
&#123;
public:
    A():ptr_m_(new int(10 + construct_count))&#123;
        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;
    &#125;
    static int construct_count;
    int *ptr_m_;

    ~A()
    &#123;
        delete ptr_m_;
        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;

A get()
&#123;
    A a;
    return a; 
&#125;

int main()
&#123;
    A &amp;&amp;a01 &#x3D; get();  &#x2F;&#x2F; a01作为右值引用延长了get返回的类A临时对象的生命周期，避免了一次类A对象的构造过程
    A a02 &#x3D; get();  &#x2F;&#x2F; 调用类A的移动构造函数，但成员指针ptr_m_默认是浅拷贝，用户需要根据实际场景决定ptr_m_指向的内存空间在两个对象之间是浅拷贝还是深拷贝，通常的做法是用户在移动构造函数内部自行实现设置原始对象ptr_m_&#x3D;nullptr
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-5、std-move及移动拷贝构造函数"><a href="#5-5、std-move及移动拷贝构造函数" class="headerlink" title="5.5、std::move及移动拷贝构造函数"></a>5.5、std::move及移动拷贝构造函数</h2><ul>
<li>std::move的作用是将左值转化为右值（严格意义上来说并不是转化，而是左值作为std::move的参数，然后返回其右值形式），用于实现目标对象右值引用的相关操作，比如移动拷贝构造函数的调用、右值引用的重载函数等，对左值本身并无任何实质性操作；  </li>
<li>std::move只是将原始对象左值转化为目的对象右值，至于原始对象与目标对象之间存在何种关联，由移动拷贝构造函数、右值引用的重载函数等的具体实现而定；</li>
<li>std::move的操作不会发生内存的搬迁或者内存拷贝。<br>示例：<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A
&#123;
public:
    A():ptr_m_(new int(10 + construct_count))&#123;
        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;
    &#125;
    static int construct_count;
    int *ptr_m_;

    ~A()
    &#123;
        delete ptr_m_;
        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;




int main()
&#123;
    A a01;
    A &amp;&amp;a02 &#x3D; std::move(a01);
    A a03 &#x3D; std::move(a01);
    std::cout &lt;&lt; &quot;before: &quot; &lt;&lt;*(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a03.ptr_m_) &lt;&lt; std::endl;
    *(a01.ptr_m_) &#x3D; 20;
    std::cout &lt;&lt; &quot;now: &quot; &lt;&lt;*(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a03.ptr_m_) &lt;&lt; std::endl;
    
    std::string str01 &#x3D; &quot;hello&quot;;
    std::vector&lt;std::string&gt; vec01;
    vec01.push_back(str01);
    vec01.push_back(std::move(str01));
    std::cout &lt;&lt; &quot;class string before: &quot;;
    for(auto &amp;iter : vec01)
    &#123;
        std::cout &lt;&lt; iter &lt;&lt; &quot; &quot;;
    &#125;

    str01 &#x3D; &quot;hello_world&quot;;

    std::cout &lt;&lt; std::endl &lt;&lt; &quot;now: &quot;;
    for(auto &amp;iter : vec01)
    &#123;
        std::cout &lt;&lt; iter &lt;&lt; &quot; &quot;;
    &#125;
    
    std::cout &lt;&lt; std::endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
运行结果：<pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 1
before: 10 10 10
now: 20 20 20
class string before: hello hello 
now: hello hello 
destructor
*** Error in &#96;.&#x2F;main&#39;: double free or corruption (fasttop): 0x0000000001288c20 ***
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7fe157eee7e5]
&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7fe157ef737a]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
class A：<br>对于a03，std::move仅仅是返回a01的右值形式，进而调用class A的移动拷贝构造函数。由于class A使用的是默认移动拷贝构造函数，对于成员变量ptr_m_是直接浅拷贝，故会a01、a03会重复delete，error。    </li>
</ul>
<p>std::string:<br>第一个push_back调用的是std::string类的普通拷贝构造函数<br>第二个push_back调用的是std::string类的移动拷贝构造函数，其中实现了成员char数组的深拷贝操作，所以不会出现重复delete的错误，而且之后修改str01也并不会影响vector内的元素</p>
<h3 id="5-5-1、移动拷贝构造函数"><a href="#5-5-1、移动拷贝构造函数" class="headerlink" title="5.5.1、移动拷贝构造函数"></a>5.5.1、移动拷贝构造函数</h3><h4 id="1、设计初衷"><a href="#1、设计初衷" class="headerlink" title="1、设计初衷"></a>1、设计初衷</h4><p>在用对象a初始化对象b时存在这样的场景：初始化表达式结束之后对象a就不再被使用。但是对象a在被析构之前仍然存在，既然构造函数就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了构造函数引起的新的空间分配操作，大大降低了构造的成本与效率，移动拷贝构造函数就此应运而生。   std::move可以为移动拷贝构造函数提供某些实际场景的使用。</p>
<h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><ul>
<li>普通拷贝构造函数中，对于指针，一定要采用深层复制，否则会出现重复delete的问题。而移动构造函数中，对于指针采用浅复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要在移动构造函数的实现中将其中一个指针置为NULL即可；</li>
<li>移动构造函数的参数和普通拷贝构造函数不同，普通拷贝构造函数的参数是左值引用，而移动构造函数是右值引用。意味着，向移动构造函数传递的实参是一个纯右值或者将亡值。也就是说，只有右值实参才会触发移动构造函数的调用；</li>
</ul>
<h2 id="5-6、右值引用与类型推导：引用折叠、未决议引用universal-reference"><a href="#5-6、右值引用与类型推导：引用折叠、未决议引用universal-reference" class="headerlink" title="5.6、右值引用与类型推导：引用折叠、未决议引用universal reference"></a>5.6、右值引用与类型推导：引用折叠、未决议引用universal reference</h2><p>引用折叠与未决议引用是同一概念，发生在类型推导场合：<br>模板参数类型推导、auto自动类型推导，且声明形式仅为T&amp;&amp;，不加任何类型修饰语</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; **********************模板参数
template&lt;typename T&gt;
void func02(T&amp;&amp; param);  &#x2F;&#x2F; 未决议引用

func02(10);  &#x2F;&#x2F;param是右值
int x &#x3D; 10;
func02(x);  &#x2F;&#x2F;param是左值

template&lt;typename T&gt;
void func03(const T&amp;&amp; param);  &#x2F;&#x2F; 形参包含额外修饰语，故是右值引用，不是未决议引用

func03(10);  &#x2F;&#x2F;param是右值
int var01 &#x3D; 10;
func03(var01);  &#x2F;&#x2F; 报错，左值var01不能绑在右值引用param上


template&lt;typename T&gt;
void func03(std::vector&lt;T&gt;&amp;&amp; param);  &#x2F;&#x2F; 形参包含额外修饰语，故是右值引用，不是未决议引用

&#x2F;&#x2F; **********************auto类型推导
int var02 &#x3D; 10;
auto &amp;&amp;var03 &#x3D; 30;  &#x2F;&#x2F; var03为右值引用，未决议引用
auto &amp;&amp;var04 &#x3D; var02;  &#x2F;&#x2F; var04为左值引用，未决议引用
const auto &amp;&amp;var05 &#x3D; var02;  &#x2F;&#x2F; 报错，包含额外修饰符，var05是右值引用，不能绑定左值var02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>引用折叠规则：</p>
<table>
<thead>
<tr>
<th>实参</th>
<th>形参</th>
<th>result</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;</td>
<td>&amp; // 错误，非常量左值不能接收右值</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
<td>&amp;&amp;</td>
</tr>
</tbody></table>
<p>可以看出任意一个引用为左值引用时结果均为左值，只有在两个引用均为右值引用时才是右值引用。</p>
<h2 id="5-7、std-forward完美转发"><a href="#5-7、std-forward完美转发" class="headerlink" title="5.7、std::forward完美转发"></a>5.7、std::forward完美转发</h2><p>右值引用类型在发生自动类型推导时的不确定性，可以通过std::forward解决。<br>首先要明白std::forward完美转发的对象实际上是实参的类型</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;

void PrintT(int&amp; t)
&#123;
	std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;
&#125;

template &lt;typename T&gt;
void PrintT(T&amp;&amp; t)
&#123;
	std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;
&#125;

template &lt;typename T&gt;
void TestForward(T&amp;&amp; v)
&#123;
	PrintT(v);
	PrintT(std::forward&lt;T&gt;(v));
	PrintT(std::move(v));
&#125;

void Test()
&#123;
	TestForward(1);
	int x &#x3D; 1;
	TestForward(x);
	TestForward(std::forward&lt;int&gt;(x));
&#125;

int main(void)
&#123;
	Test();

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lvalue
rvalue
rvalue

lvalue
lvalue
rvalue

lvalue
rvalue
rvalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TestForward的前两次调用很容易理解，对于第三次调用std::forward<int>(x)就很好的阐释了完美转发的对象实际上是实参，局部变量x在std::forward语句中扮演的是形参的角色，转发的是字面量’1’的类型。     </p>
<p><font color=red><strong>疑问</strong></font><br>修改后的代码运行结果为何是下面这样：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;

void PrintT(int&amp; t)
&#123;
	std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;
&#125;

template &lt;typename T&gt;
void PrintT(T&amp;&amp; t)
&#123;
	std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;
&#125;

template &lt;typename T&gt;
void TestForward(T&amp;&amp; v)
&#123;
	PrintT(v);
	PrintT(std::forward&lt;T&gt;(v));
	PrintT(std::move(v));
&#125;

void Test()
&#123;
	int x &#x3D; 1;
	int y &#x3D; x;
	TestForward(std::forward&lt;int&gt;(y));
&#125;

int main(void)
&#123;
	Test();

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lvalue
rvalue
rvalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>std::forward<int>(y)中的y作为形参的话，它的实参x是个左值，为何std::forward<int>(y)转发结果确实右值？</p>
<h2 id="5-8、万能引用：右值引用与常量左值引用"><a href="#5-8、万能引用：右值引用与常量左值引用" class="headerlink" title="5.8、万能引用：右值引用与常量左值引用"></a>5.8、万能引用：右值引用与常量左值引用</h2><p>万能引用通常是指右值引用在发生类型推导时的使用场景：模板类型推导、auto自动类型推导。<br>且声明形式仅为T&amp;&amp;，不带任何修饰符</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;
void func01(T&amp;&amp; num)
&#123;
    std::cout &lt;&lt; num &lt;&lt; std::endl;
&#125;

int main()
&#123;
    int32_t i &#x3D; 10;
    func01(i);  &#x2F;&#x2F; OK，接收左值i
    func01(20);  &#x2F;&#x2F; OK，接收右值20
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>模板函数func01在是实例化时即可接收左值也可接收右值，称作万能引用。<br>若T&amp;&amp;改成const T&amp;&amp;则不是万能引用，只能接收右值</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;
void func01(const T&amp;&amp; num)
&#123;
    std::cout &lt;&lt; num &lt;&lt; std::endl;
&#125;

int main()
&#123;
    int32_t i &#x3D; 10;
    func01(i);  &#x2F;&#x2F; error，不接收左值i
    func01(20);  &#x2F;&#x2F; OK，接收右值20
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>引申</strong><br>若按照是否能同时接收左值、右值到规则，那么常量左值引用也可称作万能引用</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;
void func01(const T&amp; num)
&#123;
    std::cout &lt;&lt; num &lt;&lt; std::endl;
&#125;

int main()
&#123;
    int32_t i &#x3D; 10;
    func01(i);  &#x2F;&#x2F; OK，接收左值i
    func01(20);  &#x2F;&#x2F; OK，接收右值20
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-9、引用作为函数返回值"><a href="#5-9、引用作为函数返回值" class="headerlink" title="5.9、引用作为函数返回值"></a>5.9、引用作为函数返回值</h2><ul>
<li>引用作为函数返回值时，需要在函数定义和声明处添加&amp;；</li>
<li>引用作为函数返回值的最大好处是可以避免返回值的临时变量生成</li>
</ul>
<p>普通函数调用时返回值的内存走向：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int func()
&#123;
    int local_a;
    return lcoal_a;
&#125;

int obj_a &#x3D; func();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE7391efdff74cc063e907f9705fdfef84/38326" alt="image05"></p>
<ul>
<li><p>避免返回临时变量的引用<br>语法上可以返回临时变量的引用，但这样的操作很危险，因为在离开函数作用域之后函数体内的临时变量就会消亡，此时它的引用就是一块未定义内存空间，会引发不可预知行为。通常情况下编译器会抛出warning：返回临时变量的引用不被允许</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A
&#123;
public:
    A():value_(10)&#123;
        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;
    &#125;
    static int construct_count;
    &#x2F;&#x2F;int *ptr_m_;
    int value_;

    ~A()
    &#123;
        &#x2F;&#x2F;delete ptr_m_;
        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;



A global_a;

int A::construct_count &#x3D; 0;

A&amp; getLeftLocal()
&#123;
     A local_a;
    return local_a;
&#125;

A&amp;&amp; getRightLocal()
&#123;
     A local_a;
    return std::move(local_a);
&#125;

int main()
&#123;
    A a02 &#x3D; getLeftLocal();
    A a04 &#x3D; getRightLocal();
    eturn 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译期间就会报错：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">move_cpye.cpp: In function &#39;A&amp; getLeftLocal()&#39;:
move_cpye.cpp:15:8: warning: reference to local variable &#39;local_a&#39; returned [-Wreturn-local-addr]
      A local_a;
        ^
move_cpye.cpp: In function &#39;A&amp;&amp; getRightLocal()&#39;:
move_cpye.cpp:27:29: warning: function may return address of local variable [-Wreturn-local-addr]
     return std::move(local_a);
                             ^
move_cpye.cpp:26:8: note: declared here
      A local_a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>返回全局变量、局部静态变量的引用</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A
&#123;
public:
    A():value_(10)&#123;
        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;
    &#125;
    static int construct_count;
    &#x2F;&#x2F;int *ptr_m_;
    int value_;

    ~A()
    &#123;
        &#x2F;&#x2F;delete ptr_m_;
        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;
    &#125;
&#125;;



A global_a;

int A::construct_count &#x3D; 0;

A&amp; getLeftGlobal()
&#123;
    return global_a;
&#125;

A&amp;&amp; getRightGlobal()
&#123;
    return std::move(global_a);
&#125;

int main()
&#123;
    A a01 &#x3D; getLeftGlobal();  &#x2F;&#x2F; 调用普通拷贝构造函数
    A &amp;a02 &#x3D; getLeftGlobal();  &#x2F;&#x2F; 不调用构造函数
    A a03 &#x3D; getRightGlobal();  &#x2F;&#x2F; 调用移动拷贝构造函数
    A &amp;&amp;a04 &#x3D; getRightGlobal();  &#x2F;&#x2F; 不调用构造函数
    std::cout &lt;&lt; &quot;a01 &#x3D; &quot; &lt;&lt; a01.value_ &lt;&lt; &quot;\na02 &#x3D; &quot; &lt;&lt; a02.value_ &lt;&lt; &quot;\na03 &#x3D; &quot; &lt;&lt; a03.value_ &lt;&lt; &quot;\na04 &#x3D; &quot; &lt;&lt; a04.value_ &lt;&lt; std::endl;
    
    global_a.value_ &#x3D; 33;
    std::cout &lt;&lt; &quot;after update:&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;a01 &#x3D; &quot; &lt;&lt; a01.value_ &lt;&lt; &quot;\na02 &#x3D; &quot; &lt;&lt; a02.value_ &lt;&lt; &quot;\na03 &#x3D; &quot; &lt;&lt; a03.value_ &lt;&lt; &quot;\na04 &#x3D; &quot; &lt;&lt; a04.value_ &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 1
a01 &#x3D; 10
a02 &#x3D; 10
a03 &#x3D; 10
a04 &#x3D; 10
after update:
a01 &#x3D; 10
a02 &#x3D; 33
a03 &#x3D; 10
a04 &#x3D; 33
destructor
destructor
destructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>a01和a03均调用了类A的构造函数，且拷贝过程中并未有临时类对象的生成，a01是用global_a的左值引用作为参数进而调用普通拷贝构造函数，a03是用global_a的右值引用作为参数进而调用移动拷贝构造函数，从结果来看构造函数调用了一次(global_a的构造函数)，a01和a03调用的是拷贝构造函数，所以一共有三次析构函数。<br>通过修改global_a.value_的值也能看出a01和a03发生了拷贝构造。</p>
</li>
<li><p>避免返回new分配的堆空间引用<br>堆空间虽然可以避免如局部变量离开作用域之后就释放的问题，但如果返回的引用未被其他变量接收，就无法释放，引起内存泄漏，或者返回的引用被继续用于链式调用，也无法释放。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int *&amp;ptr getAdd(int add)
&#123;
    int *ptr &#x3D; new int(add);
    return ptr;
&#125;

int main()
&#123;
    getAdd(10);  &#x2F;&#x2F; 函数返回值未被其他变量接收
    int result &#x3D; (*(getAdd(10))) * (*(getAdd(20)));  &#x2F;&#x2F; 函数返回值被链式调用用于乘法运算
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="5-10、引用占用内存空间"><a href="#5-10、引用占用内存空间" class="headerlink" title="5.10、引用占用内存空间"></a>5.10、引用占用内存空间</h2><p>引用是变量的别名，通常给人的错觉是引用不占用内存空间，就像零长度数组，仅仅只是一个占位符而已，实际则并不是这样的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma pack(1)
class Car
&#123;
public:
   Car(int32_t wheels, int32_t temp, char c_temp):wheels_(wheels), temp_(temp), c_temp_(c_temp)&#123;&#125;
   int32_t wheels_;
   int32_t &amp;temp_;
   char &amp;c_temp_;
   void print()
   &#123;
       std::cout &lt;&lt; &quot;I have 4 wheeves&quot; &lt;&lt; std::endl;
   &#125;
&#125;;
&#x2F;&#x2F;int32_t Car::temp &#x3D; 0;

int main()
&#123;
    Car my_car(4, 10, &#39;f&#39;);
    char c &#x3D; &#39;a&#39;;
    char &amp;r_c &#x3D; c;
    std::cout &lt;&lt; sizeof(Car) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(my_car) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(r_c) &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">20    20    1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类Car的sizeof结果为20Byte = 4 + 8 + 8(CPU是64bit)，说明左值引用是占据内存空间的，而且与指针类型占用内存大小相同。但局部变量r_c的sizeof却是1，这是怎么回事？<br><font color=red>C++编译器在编译的过程中使用常量指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。此规则只在引用作为成员时才会生效，包括class、struct的成员，如果仅仅只是局部引用变量，引用仍是常规所理解的别名，不占据内存空间，这是编译器在编译时的隐藏规则体现</font></p>
<h2 id="5-11、引用的本质"><a href="#5-11、引用的本质" class="headerlink" title="5.11、引用的本质"></a>5.11、引用的本质</h2><p>引用的本质就是指针，而且是一个指针常量，占据内存的大小=指针内存大小，详见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/CKEdPD0tmaPxb8QxqqU_lw">引用的本质</a></p>
<h1 id="6、指针"><a href="#6、指针" class="headerlink" title="6、指针"></a>6、指针</h1><p>指针本身是一种类型，用于指向某一块内存区域，指针的值便是所指内存区域的起始地址，不管指针指向何种数据类型，指针变量自身所占的内存大小是固定的，由CPU的位宽决定，32bit CPU指针占4Byte = 32bit，64bit CPU指针占8Byte = 64bit，这是因为指针变量存放的值是地址，该值的范围要足以访问整个内存空间，而内存空间的大小是由CPU的寻址能力决定的，即CPU的位宽决定CPU的寻址能力。</p>
<h2 id="6-1、一级指针与二级指针理解"><a href="#6-1、一级指针与二级指针理解" class="headerlink" title="6.1、一级指针与二级指针理解"></a>6.1、一级指针与二级指针理解</h2><p>指针和二级指针理解<br>指针本身也是个变量，其值是一个地址，也就是其指向的地址。假如通过一个函数改变指针指向的值，函数外部指针p1，参数p2，当函数调用时，p1传递给函数的依然是一个指针副本：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;一级指针
p1指针本身地址0x10，存放的地址0x20,0x20地址存放的实际值是1,；
p1作为实参传递给函数形参p2，p2指针本身地址0x11，存放的地址0x20，与p1存放的地址一样；    
假如函数内部有一个指针p3，本身地址0x12，存放的地址0x21,0x21存放的实际值是5，如果执行p2&#x3D;p3，只是将p2存放的地址由0x20改成0x21，并不会影响函数外部p1指向的值；    
此时需要执行*p2&#x3D;*p3，这样就将地址0x20存放的值改为0x21的值5，便可达到修改p1指针指向的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;二级指针
p1指针本身地址0x10，存放的地址0x20,0x20地址存放的实际值是1,；
p1取地址，转换为二级指针pp1，本身地址0x40，存放一级指针p1地址0x10，然后作为实参传递给函数形参二级指针p2，p2指针本身地址0x41，存放的地址0x10，与pp1存放的地址一样；    
假如函数内部有一个一级指针p3，本身地址0x12，存放的地址0x21,0x21存放的实际值是5，如果执行p2&#x3D;p3，发生错误，因为p2是二级指针，p3却是一级指针，此时执行*p2&#x3D;p3,是将p2转换为一级指针*p2,这样发生的变化就是p2存放的地址0x10指向了p3存放的地址0x21，亦即p1指针由指向0x20改为指向0x21，达到了修改p1指针指向值的目的；    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include &lt;stdint.h&gt;
using namespace std;

void test(int **p2)
&#123;
	cout &lt;&lt; &quot;2、**********&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;p2自身地址:&quot; &lt;&lt; &amp;p2 &lt;&lt; endl;
	cout &lt;&lt; &quot;p2指向的地址:&quot; &lt;&lt; p2 &lt;&lt; endl;
	cout &lt;&lt; &quot;*p2指向的地址:&quot; &lt;&lt; *p2 &lt;&lt; endl;
	cout &lt;&lt; &quot;*p2自身的地址:&quot; &lt;&lt; &amp;(*p2) &lt;&lt; endl;
	cout &lt;&lt; &quot;**p2指向的值:&quot; &lt;&lt; **p2 &lt;&lt; endl;
	int bb &#x3D; 10;
	int *p3 &#x3D; &amp;bb;
	&#x2F;&#x2F;*p2 &#x3D; p3;
	
	**p2 &#x3D; *p3;
&#125;

int main()
&#123;	
	int aa &#x3D; 9;
	int *p1 &#x3D; &amp;aa;
	cout &lt;&lt; &quot;1、**********&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;p1自身地址:&quot; &lt;&lt; &amp;p1 &lt;&lt; endl;
	cout &lt;&lt; &quot;p1指向的地址:&quot; &lt;&lt; p1 &lt;&lt; endl;
	cout &lt;&lt; &quot;p1指向的值:&quot; &lt;&lt; *p1 &lt;&lt; endl;
	test(&amp;p1);
	cout &lt;&lt; &quot;3、**********&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;02:&quot; &lt;&lt; *p1 &lt;&lt; endl;
	system(&quot;pause&quot;);
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：   </p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、**********
p1自身地址:0x7ffe11911080
p1指向的地址:0x7ffe1191107c
p1指向的值:9
2、**********
p2自身地址:0x7ffe11911048
p2指向的地址:0x7ffe11911080
*p2指向的地址:0x7ffe1191107c
*p2自身的地址:0x7ffe11911080
**p2指向的值:9
3、**********
02:10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里有一个疑问：当把test函数中*p2 = p3放开，*p1的结果就不正确，为何？   </p>
<ul>
<li>这是因为test的函数里*p2改变的是p1指针指向的内存位置，即*p2=p3操作之后，p1就指向了test函数中变量bb的内存位置,此时p1的值就是bb的内存地址。当出了test函数后再对p1解引用(*p1)时，取出的就是原先bb内存地址现在的值，而bb又是test内的临时变量，所以此时该内存地址处存放的就是个不确定值；</li>
<li>为何关闭*p2 = p3，开启**p2=*p3时,又正确了？首先需要注意的就是**p2=*p3并不会像*p2 = p3那样会修改p1指向的内存地址，而是直接修改p1指向内存位置所存放的值，变为*p3，即此时p1指向内存位置的值为bb的值10；</li>
<li>为何同时开启*p2 = p3，**p2=*p3时，就不正确了？结合前两点分析来看，*p2 = p3操作先是修改了p1指向的内存位置（bb的内存地址），然后**p2=*p3操作修改的是此时p1指向的内存位置的值（如果是**p2=20，那么此时的bb值就会变成20），出了test函数之后，实际上p1指向的内存位置变成了bb，而bb又是个临时变量，此时已经被销毁，所以*p1的结果就是个不确定值；</li>
</ul>
<h2 id="6-2、指针与数组"><a href="#6-2、指针与数组" class="headerlink" title="6.2、指针与数组"></a>6.2、指针与数组</h2><p>关于指针与数组的关系最常见的一种说法便是：   </p>
<p>数组名在作为函数参数进行参数传递时，会发生退化，相当于是一个指针。     </p>
<p><font color=red><strong>其实这种说法是不恰当地</strong><br>数组名在作为函数参数传递时，确实传递的是一个地址，但数组名绝不是指针，两者不是同一个东西。数组名用来表征一块连续内存存储空间的地址，编译器并不会为它分配内存，它只是一个占位符，sizeof的结果取决于其表述的是多大一块连续内存空间；而指针是一个变量，编译器要给它单独分配内存空间，用来存放它指向的变量的地址。<br>数组名传递给指针时发生的退化现象，应该理解成以数组所在的连续内存的起始地址对指针进行赋值，并不代表数组名与指针是一回事</font>   </p>
<p>关于数组名是否占用内存空间，零长度数组可以很好的阐明：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例一
#pragma pack(1)

&#x2F;&#x2F; 零长度数组在C语言中通常用来实现变长数组，结合struct使用
struct ZeroAarray01
&#123;
    int32_t value_;
    char c_array_[0];
&#125;;

struct ZeroAarray02
&#123;
    int32_t value_;
    char *ptr;  &#x2F;&#x2F; 64bit CPU, pointer length &#x3D; 64bit
&#125;;

int main()
&#123;
    
    std::cout &lt;&lt; &quot;ZeroAarray01 length &#x3D; &quot; &lt;&lt; sizeof(ZeroAarray01) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;ZeroAarray02 length &#x3D; &quot; &lt;&lt; sizeof(ZeroAarray02) &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ZeroAarray01 length &#x3D; 4
ZeroAarray02 length &#x3D; 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>包含零长度数组的结构体ZeroAarray01的长度为4Byte，说明编译器并不为数组名分配内存，它只是个占位符，所以可以通过ZeroAarray01.c_array_进行访问。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例二
int main()
&#123;
    
    char c_value &#x3D; &#39;a&#39;;
    char c_array[2] &#x3D; &#123;&#39;b&#39;, &#39;c&#39;&#125;;
    char *c_ptr &#x3D; &amp;c_value;

    std::cout &lt;&lt; &quot;c_array length &#x3D; &quot; &lt;&lt; sizeof(c_array) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;c_ptr length &#x3D; &quot; &lt;&lt; sizeof(c_ptr) &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c_array length &#x3D; 2
c_ptr length &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>c_array数组名描述的是2个char型元素的连续内存空间的首地址，所以length为2</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例三
char str1[15] &#x3D; &quot;Hello&quot;;
char str2[15] &#x3D; &quot;Hello&quot;;

char *str3 &#x3D; &quot;Hello&quot;;
char *str4 &#x3D; &quot;Hello&quot;;

printf(&quot;%d\n&quot;, str1&#x3D;&#x3D;str2);  &#x2F;&#x2F;0
printf(&quot;%d\n&quot;, str3&#x3D;&#x3D;str4);  &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>str1和str2都是存放内容为”Hello”的数组，字符串字面常量”Hello”虽然是存储在.rodata区，但str1和str2却是将”Hello”复制到各自的内存区域上，已脱离了”Hello”静态区域的关联，所以str1和str2是两个完全独立的值，二者所表述的地址自然也不相同<br>而str3和str4是两个指针，均指向.rodata区上的”Hello”字符串字面常量，所以str3和str4的值是相同的。PS：知识点，编译阶段编译器会将全局字面常量去重，只保留一份；   </p>
<p><font color=purple>所以数组名只是一段连续内存的地址表述，与指针不是同一种东西，</font><font color=red><strong>数据名不能进行自增、自减操作，但可以进行加减操作；</strong></font>  </p>
<h3 id="6-2-1、数组名、数组地址和数组首元素地址的理解"><a href="#6-2-1、数组名、数组地址和数组首元素地址的理解" class="headerlink" title="6.2.1、数组名、数组地址和数组首元素地址的理解"></a>6.2.1、数组名、数组地址和数组首元素地址的理解</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()
&#123;
    char c_array[2] &#x3D; &#123;&#39;b&#39;, &#39;c&#39;&#125;;
    char *c_ptr_array_name &#x3D; c_array;  &#x2F;&#x2F; OK, c_array is char *
    char *c_ptr_array_address &#x3D; &amp;c_array;  &#x2F;&#x2F; error, &amp;c_array is char (*p)[2]
    char *c_ptr_first_element_address &#x3D; &amp;(c_array[0]);  &#x2F;&#x2F; OK, &amp;(c_array[0]) is char *

    char (*p)[2] &#x3D; &amp;c_array;  &#x2F;&#x2F; OK, &amp;c_array is char (*p)[2]
    p &#x3D; c_array; &#x2F;&#x2F; error, c_array is char *

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>数组名c_array的类型可以理解成char *(实际其与指针char *并不是同一种东西)，故可将其传递给参数类型为char *的函数；</li>
<li> 数组地址&amp;c_array的类型是char (*p)[2]；</li>
<li> 数组首元素的地址&amp;(c_array[0])是char *</li>
</ul>
<p><font color=purple>对数组名类型的进一步理解</font></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()
&#123;
    int32_t i_array_01[2] &#x3D; &#123;1, 2&#125;;
    int32_t *ptr_01 &#x3D; i_array_01;
    int32_t i_array_02[2][3] &#x3D; &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;
    int32_t (*ptr_02)[3] &#x3D; i_array_02;  &#x2F;&#x2F; ptr_02是二级指针
    
    char *c_array[2] &#x3D; &#123;&quot;hello&quot;, &quot;world&quot;&#125;;
    char **ptr_03 &#x3D; c_array;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>i_array_01会退化成int32_t *；</li>
<li>i_array_02会退化成int32_t (*)[3]；</li>
<li>而c_array却退化成了char **，因为数组名退化成的指针存放的是数组首元素的地址，c_array数组首元素是一个char *指针，那么指向它的指针自然就是一个二级指针；<h3 id="6-2-2、指针与二维数组"><a href="#6-2-2、指针与二维数组" class="headerlink" title="6.2.2、指针与二维数组"></a>6.2.2、指针与二维数组</h3>套用指针与一维数组的规则来理解二维数组与指针间的关系。<br>二维数组int aa[n][m]可以理解成n个包含元素数m的一维数组</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">using namespace std;

int main()
&#123;
	int32_t aa[2][3] &#x3D; &#123; &#123;1, 2, 3&#125;, &#123;4, 5,6&#125; &#125;;
	int32_t(*p)[3] &#x3D; aa;

    cout &lt;&lt; &quot;aa length &#x3D; &quot; &lt;&lt; sizeof(aa) &lt;&lt; endl;  &#x2F;&#x2F; 数组所在连续内存空间的大小
    cout &lt;&lt; &quot;01:\t&quot; &lt;&lt; aa &lt;&lt; endl;  &#x2F;&#x2F; 数组名aa作为参数传递时可以退化为指针，故aa的类型是int32_t(*p)[3]
    cout &lt;&lt; &quot;02:\t&quot; &lt;&lt; p &lt;&lt; endl;  &#x2F;&#x2F; p的类型是int32_t(*p)[3]
    cout &lt;&lt; &quot;03:\t&quot; &lt;&lt; &amp;aa &lt;&lt; endl &lt;&lt; endl;  &#x2F;&#x2F; 数组的地址，类型是int32_t [2][3]

    cout &lt;&lt; &quot;04:\t&quot; &lt;&lt; aa + 1 &lt;&lt; endl;
    cout &lt;&lt; &quot;05:\t&quot; &lt;&lt; p + 1 &lt;&lt; endl;
    cout &lt;&lt; &quot;06:\t&quot; &lt;&lt; &amp;aa + 1 &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; &quot;07:\t&quot; &lt;&lt; aa[0] &lt;&lt; endl;  &#x2F;&#x2F; aa[0]指向aa数组的第一行，类型是int32_t *
    cout &lt;&lt; &quot;08:\t&quot; &lt;&lt; &amp;aa[0] &lt;&lt; endl &lt;&lt; endl;  &#x2F;&#x2F; &amp;aa[0]是第一行数组的地址,区别于&amp;aa，类型是int32_t (*p)[3]

    cout &lt;&lt; &quot;09:\t&quot; &lt;&lt; aa[0] + 1 &lt;&lt; endl;
    cout &lt;&lt; &quot;10:\t&quot; &lt;&lt; &amp;aa[0] + 1 &lt;&lt; endl &lt;&lt; endl;
    
    cout &lt;&lt; &quot;11:  &quot; &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F; p &#x3D; aa[0]
	cout &lt;&lt; &quot;12:  &quot; &lt;&lt; *p + 1 &lt;&lt; endl;  &#x2F;&#x2F; aa[0] + 1
	cout &lt;&lt; &quot;13:  &quot; &lt;&lt; **p &lt;&lt; endl;  &#x2F;&#x2F; *p &#x3D; aa[0]  **p &#x3D; aa[0][0]

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aa length &#x3D; 24
01:	0x7ffcc94ae230
02:	0x7ffcc94ae230
03:	0x7ffcc94ae230

04:	0x7ffcc94ae23c
05:	0x7ffcc94ae23c
06:	0x7ffcc94ae248

07:	0x7ffcc94ae230
08:	0x7ffcc94ae230

09:	0x7ffcc94ae234
10:	0x7ffcc94ae23c

11:  0x7ffcc94ae230
12:  0x7ffcc94ae234
13:  1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-2-3、指针数组与二级指针"><a href="#6-2-3、指针数组与二级指针" class="headerlink" title="6.2.3、指针数组与二级指针"></a>6.2.3、指针数组与二级指针</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main()
&#123;
    const char *str[4] &#x3D; &#123;&quot;welcome&quot;, &quot;to&quot;, &quot;new&quot;, &quot;Beijing&quot;&#125;;
    const char **p &#x3D; str;  &#x2F;&#x2F; str相当于二级指针

    std::cout &lt;&lt; &quot;*p&#x3D;\t\t&quot; &lt;&lt; *p &lt;&lt; std::endl;   &#x2F;&#x2F; *p is char *
    std::cout &lt;&lt; &quot;**p&#x3D;\t\t&quot; &lt;&lt; **p &lt;&lt; std::endl;   &#x2F;&#x2F; **p is char
    std::cout &lt;&lt; &quot;(*p++) + 1&#x3D;\t&quot; &lt;&lt; (*p++) + 1 &lt;&lt; std::endl;   &#x2F;&#x2F; (*p++) is char *, 后置++

    &#x2F;&#x2F; 由于(*p++)后*p指向了&quot;to&quot;，故二级指针p也向前移动了一个char *指向str[1]
    std::cout &lt;&lt; &quot;*(p+1)&#x3D;\t\t&quot; &lt;&lt; *(p+1) &lt;&lt; std::endl;   &#x2F;&#x2F; &quot;new&quot;
    std::cout &lt;&lt; &quot;p[1] + 3&#x3D;\t&quot; &lt;&lt; p[1] + 1&lt;&lt; std::endl;   &#x2F;&#x2F; &quot;ew&quot;
	
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*p&#x3D;			welcome
**p&#x3D;		w
(*p++) + 1&#x3D;	elcome
*(p+1)&#x3D;		new
p[1] + 3&#x3D;	ew<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当str退化成数组时相当于一个二级指针，指向一个包含四个char *的一维数组，这四个char *指针内存空间是连续的，但各自指向的字符串字面常量内存空间并不是连续的；</p>
<h2 id="6-3、指针与字面常量"><a href="#6-3、指针与字面常量" class="headerlink" title="6.3、指针与字面常量"></a>6.3、指针与字面常量</h2><p>字面常量包括：整形字面常量、字符串字面常量   </p>
<ul>
<li>字符串字面自身在编译期会被优化，进行去重处理(全局变量 + 局部变量)，全局只会保留一份，所有指向同一个字符串字面常量的指针值都是一样的； </li>
<li>整形字面常量自身并不会做去重处理，所以，包含相同整形字面常量的变量地址是不一样的；</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const char *c1 &#x3D; &quot;hello&quot;;
const char *c2 &#x3D; &quot;hello&quot;;

int32_t i1 &#x3D; 1234;
int32_t i2 &#x3D; 1234;

int main()
&#123;
    const char *c3 &#x3D; &quot;hello&quot;;
    int32_t i3 &#x3D; 1234;
    
    printf(&quot;c1 pointer: %p\n&quot;, c1);
    printf(&quot;c2 pointer: %p\n&quot;, c2);
    printf(&quot;c3 pointer: %p\n&quot;, c3);

    printf(&quot;i1 pointer: %p\n&quot;, &amp;i1);
    printf(&quot;i2 pointer: %p\n&quot;, &amp;i2);
    printf(&quot;i3 pointer: %p\n&quot;, &amp;i3);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c1 pointer: 0x402004
c2 pointer: 0x402004
c3 pointer: 0x402004
i1 pointer: 0x404058
i2 pointer: 0x40405c
i3 pointer: 0x7ffeb65eab64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C与C++之中对于字符串字面常量与指针间的赋值操作规则是不一样的</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;

int main()
&#123;
    char *str &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; C语言中编译、执行均OK，但C++中编译会报错，提示const char *无法赋值给char *，这样来看C++的安全机制更高
    printf(&quot;%s\n&quot;, str);
    char *c_ptr &#x3D; (char*)str;
    c_ptr[1] &#x3D; &#39;c&#39;;  &#x2F;&#x2F; C中编译OK，执行报错，C++中g++编译会报错Segmentation fault,clang++不报错，但结果不符合预期，这是编译器的差异引起，因为str指向的内存区域是.rodata不可更改
    *str &#x3D; &quot;world&quot;;  &#x2F;&#x2F; C中编译OK，执行报错，C++中编译会报错，因为*str是char类型，而&quot;world&quot;是char *
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-3-1、通过指针修改字面常量"><a href="#6-3-1、通过指针修改字面常量" class="headerlink" title="6.3.1、通过指针修改字面常量"></a>6.3.1、通过指针修改字面常量</h3><ul>
<li>整形字面常量</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 整形字面常量赋值的const常量
const int32_t i2 &#x3D; 1234;

int main()
&#123;
    const int32_t i3 &#x3D; 1234;

    int32_t *ptr2 &#x3D; (int32_t *)(&amp;i2);
    *ptr2 &#x3D; *ptr2 + 1;
    std::cout &lt;&lt; ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i2 &lt;&lt; &quot;  &quot; &lt;&lt; i2 &lt;&lt; std::endl;

    int32_t *ptr3 &#x3D; (int32_t *)(&amp;i3);
    *ptr3 &#x3D; *ptr3 + 1;
    std::cout &lt;&lt; ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i3 &lt;&lt; &quot;  &quot; &lt;&lt; i3 &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>g++编译后运行报错Segmentation fault    </p>
<p>clang++编译后运行：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x402004  1234  0x402004  1234
0x7fff71761654  1235  0x7fff71761654  1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>i2与i3仍然输出值1234，说明了被整形字面量赋值的const常量会在编译期以立即数的形式展开，直接编译进.text段，所以后续通过指针间接修改值对其无影响；<br>【编译器差异】不报错，但与预期不符，*ptr2输出1234，而*ptr3输出1235，因为ptr2指向的i2地址空间位于.rodata常量区，不可更改，而ptr3指向的i3位于栈空间，可以通过指针ptr3间接修改；</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 整形字面常量赋值的非const变量
int32_t i2 &#x3D; 1234;

int main()
&#123;
    int32_t i3 &#x3D; 1234;

    int32_t *ptr2 &#x3D; (int32_t *)(&amp;i2);
    *ptr2 &#x3D; *ptr2 + 1;
    std::cout &lt;&lt; ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i2 &lt;&lt; &quot;  &quot; &lt;&lt; i2 &lt;&lt; std::endl;

    int32_t *ptr3 &#x3D; (int32_t *)(&amp;i3);
    *ptr3 &#x3D; *ptr3 + 1;
    std::cout &lt;&lt; ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i3 &lt;&lt; &quot;  &quot; &lt;&lt; i3 &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x404078  1235  0x404078  1235
0x7ffe43290234  1235  0x7ffe43290234  1235<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由于i2与i3只是普通非const变量，故在编译器不会以立即数的形式被优化</p>
<ul>
<li>字符串字面量</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
const char * c1 &#x3D; &quot;hello&quot;;

int main()
&#123;
    const char *c2 &#x3D; &quot;hello&quot;;

    char *c_ptr3 &#x3D; (char *)c1;
    c_ptr3[0] &#x3D; &#39;m&#39;;
    printf(&quot;%p  %s  %p  %s\n&quot;, c_ptr3, c_ptr3, c1, c1);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译OK，运行时报错Segmentation fault，因为c1、c_ptr3指向的是.rodata空间的”hello”，它是不可更改的。   </p>
<p>特例：【编译器差异】若使用clang++编译器，且将c2赋值给c_ptr3，运行时不报错，但运行结果与预期不符</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;
const char * c1 &#x3D; &quot;hello&quot;;

int main()
&#123;
    const char *c2 &#x3D; &quot;hello&quot;;

    char *c_ptr3 &#x3D; (char *)c2;
    c_ptr3[0] &#x3D; &#39;m&#39;;
    printf(&quot;%p  %s  %p  %s\n&quot;, c_ptr3, c_ptr3, c2, c2);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x402004  hello  0x402004  hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<h2 id="6-4、指针常量和常量指针"><a href="#6-4、指针常量和常量指针" class="headerlink" title="6.4、指针常量和常量指针"></a>6.4、指针常量和常量指针</h2><p><strong>指针常量</strong>—可以这么理解”指针是常量”，指针的值不可更改    </p>
<pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 30;
int *const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>常量指针</strong>—可以这么理解”常量的指针”指针指向的值不可更改</p>
<pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 30;
const int *p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="6-5、智能指针"><a href="#6-5、智能指针" class="headerlink" title="6.5、智能指针"></a>6.5、智能指针</h2><p>头文件：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;memory&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>智能指针的原理：在栈上构造一个的智能指针对象，并接受一块申请好的heap地址，当退出栈的作用域后，栈上的智能指针对象自动被销毁，进而调用析构函数，释放动态内存。</p>
<h3 id="6-5-1、std-shared-ptr共享智能指针"><a href="#6-5-1、std-shared-ptr共享智能指针" class="headerlink" title="6.5.1、std::shared_ptr共享智能指针"></a>6.5.1、std::shared_ptr共享智能指针</h3><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存，每拷贝一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。<br><font color=red><strong>shared_ptr内部的引用计数是线程安全的，但是指向堆内存的读写需要线程同步</strong></font></p>
<h4 id="1、初始化-3"><a href="#1、初始化-3" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(1));
std::shared_ptr&lt;int&gt; p2 &#x3D; p;
std::shared_ptr&lt;int&gt; p3;
p3 &#x3D; p;

class Weight
&#123;
public:
    int i;
    Weight()&#123;&#125;
&#125;

std::shared_ptr&lt;Weight&gt; sptr1 &#x3D; std::make_shared&lt;Weight&gt;();  &#x2F;&#x2F; 会自动调用Weight的构造函数，()里也可以放入Weight其他构造函数的初始化参数
std::shared_ptr&lt;int&gt; sptr1 &#x3D; std::make_shared&lt;int&gt;(3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们应该优先使用make_shared来构造智能指针。<br><strong>切记</strong>：在赋值语句”=”中不能使用原始指针直接赋值给一个智能指针，因为原始指针是指针类型，而智能指针是一个类   </p>
<pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p &#x3D; new int(1);  &#x2F;&#x2F; error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="2、获取原始指针"><a href="#2、获取原始指针" class="headerlink" title="2、获取原始指针"></a>2、获取原始指针</h4><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(1));
int *ptr &#x3D; p.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="3、指定删除器"><a href="#3、指定删除器" class="headerlink" title="3、指定删除器"></a>3、指定删除器</h4><pre class="line-numbers language-none"><code class="language-none">void DeletePtr(int *p)
&#123;
    delete p;
&#125;
std::shared_ptr&lt;int&gt; p(new int(10), DeletePtr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当引用计数减为0时，会自动调用DeletePtr函数来释放对象内存。<br><font color=red>由于shared_ptr的默认删除器不支持数组对象</font>，所以需要指定删除器</p>
<pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int[10], [](int *p)&#123;delete[] p&#125;);
&#x2F;&#x2F; 自行封装一个动态数组共享智能指针
template&lt;typename T&gt;
std::shared_ptr&lt;T&gt; make_shared_array(size_t nSize)
&#123;
    return std::shared_ptr&lt;T&gt; (new T[nSize], std::default_delete&lt;T[]&gt;());
&#125;

&#x2F;&#x2F;或者
template&lt;typename T&gt;
std::shared_ptr&lt;T&gt; make_shared_array(size_t nSize)
&#123;
    return std::shared_ptr&lt;T&gt; (new T[nSize], [](T *p)&#123;delete[] p&#125;);
&#125;

std::shared_ptr&lt;int&gt; p &#x3D; make_shared_array&lt;int&gt;(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4、reset"><a href="#4、reset" class="headerlink" title="4、reset"></a>4、reset</h4><p>用于释放已绑定的堆内存，有三个重载版本</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::shared_ptr&lt;int&gt; pt1(new int(2));
std::shared_ptr&lt;int&gt; pt2 &#x3D; pt1;  &#x2F;&#x2F; 引用计数为2
&#x2F;&#x2F; 版本一
pt2.reset();  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，pt2自身引用计数减0，而pt1的引用计数减为1

&#x2F;&#x2F; 版本二
pt2.reset(new int(3));  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，重新绑定新的堆内存int(3)

&#x2F;&#x2F; 版本三 
pt2.reset(new int[10], [](void *p)&#123;delete[] p;&#125;);  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，然后重新绑定新的堆内存int(10)，并指定删除器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5、避免heap对象重复释放"><a href="#5、避免heap对象重复释放" class="headerlink" title="5、避免heap对象重复释放"></a>5、避免heap对象重复释放</h4><ul>
<li>避免用一个原始指针初始化多个shared_ptr</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int *ptr &#x3D; new int(2);
shared_ptr&lt;int&gt; p1(ptr);
shared_ptr&lt;int&gt; p2(ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>避免将this指针作为shared_ptr返回<br>因为this本质上是一个指针，当this作为shared_ptr返回会导致多个shared_ptr对象的构造</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">struct A
&#123;
    shared_ptr&lt;A&gt; GetSelf()
    &#123;
        return shared_ptr&lt;A&gt;(this);
    &#125;
&#125;

int main()
&#123;
    shared_ptr&lt;A&gt; sp1(new A);
    shared_ptr&lt;A&gt; sp2 &#x3D; sp1-&gt;GetSelf();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于同一个指针this构造了两个shared_ptr，引发重复析构。当需要返回对象的shared_ptr时，正确的做法是让目标类通过派生std::enable_shared_from_this<T>类，然后使用基类的成员函数shared_from_this返回：   </p>
<pre class="line-numbers language-none"><code class="language-none">class A: public std::enable_shared_from_this&lt;A&gt;
&#123;
    shared_ptr&lt;A&gt; GetSelf()
    &#123;
        return shared_from_this();
    &#125;
&#125;

int main()
&#123;
    shared_ptr&lt;A&gt; sp1(new A);
    shared_ptr&lt;A&gt; sp2 &#x3D; sp1-&gt;GetSelf();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>std::enable_shared_from_this 能让一个对象（假设其名为t，且已被一个std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。<br> 若一个类T继承std::enable_shared_from_this<T>，则会为该类T提供成员函数：shared_from_this 。 当 T 类型对象t被一个为名为pt的std::shared_ptr<T>类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。<br> std::enable_shared_from_this<T>原理详见<strong>C++壹.6.5.3.2</strong>节</p>
<h4 id="6、避免在函数参数中创建shared-ptr"><a href="#6、避免在函数参数中创建shared-ptr" class="headerlink" title="6、避免在函数参数中创建shared_ptr"></a>6、避免在函数参数中创建shared_ptr</h4><pre class="line-numbers language-none"><code class="language-none">function(shared_ptr&lt;int&gt;(new int(10)), g()); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数的执行顺序因编译器而不同，通常的顺序是从右往左，但也可能是从左往右。所以，可能的情况是，先new int(10)，然后调用g(),最后再创建智能指针对象。如果恰好g()出错，而shared_ptr<int>还未创建，此时int(10)内存泄漏</p>
<h4 id="7、避免循环引用"><a href="#7、避免循环引用" class="headerlink" title="7、避免循环引用"></a>7、避免循环引用</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct A
&#123;
    std::shared_ptr&lt;B&gt; bptr;
    ~A()
    &#123;
        cout&lt;&lt;&quot;A is deleted&quot;&lt;&lt;endl;
    &#125;
&#125;
    
struct B
&#123;
    std::shared_ptr&lt;A&gt; aptr;
    ~B()
    &#123;
        cout&lt;&lt;&quot;B is deleted&quot;&lt;&lt;endl;
    &#125;
&#125;

void Test()
&#123;
    shared_ptr&lt;A&gt; ap(new A);
    shared_ptr&lt;B&gt; bp(new B);
    ap-&gt;bptr &#x3D; bp;
    bp-&gt;aptr &#x3D; ap;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>循环引用导致ap和bp的引用计数为2，当离开函数Test之后，ap和bp的引用计数减1，并不是0，无法调用析构函数，出现内存泄漏。解决此问题需要使用weak_ptr智能指针。  </p>
<h4 id="8、shared-ptr的移动语义"><a href="#8、shared-ptr的移动语义" class="headerlink" title="8、shared_ptr的移动语义"></a>8、shared_ptr的移动语义</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> shared_ptr(shared_ptr&amp;&amp; __r) noexcept
      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) &#123; &#125;
      &#x2F;&#x2F; construct shared_ptr object that takes resource from _r
      
shared_ptr&amp;
      operator&#x3D;(shared_ptr&amp;&amp; __r) noexcept
      &#123;
	this-&gt;__shared_ptr&lt;_Tp&gt;::operator&#x3D;(std::move(__r));
	return *this;
      &#125;
      &#x2F;&#x2F; construct shared_ptr object that takes resource from _r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>shared_ptr的移动赋值运算符、移动构造函数都是使用的move语义，说明它们与_r不是共享关系，而是切换，操作之后_r立即失去了控制权，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;memory&gt;

class Test
&#123;
public:
    Test(int32_t val):val_(val)&#123;&#125;
    int32_t val_;
&#125;;


int main()
&#123;
    std::shared_ptr&lt;Test&gt; ptr1(new Test(10));    
    std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;
    std::shared_ptr&lt;Test&gt; ptr2(std::move(ptr1));
    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;
    std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果</p>
<pre class="line-numbers language-base" data-language="base"><code class="language-base">1
1
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="6-5-2、std-unique-ptr独占智能指针"><a href="#6-5-2、std-unique-ptr独占智能指针" class="headerlink" title="6.5.2、std::unique_ptr独占智能指针"></a>6.5.2、std::unique_ptr独占智能指针</h3><p>独占智能指针不允许其他智能指针共享其内部的heap空间，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr，只允许进行右值相关操作，比如move方式，通过move的方式转移unique_ptr之后，本身就不再拥有原来指针的所有权了：   </p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int&gt; p(new int);
std::unique_ptr&lt;int&gt; p2 &#x3D; p;  &#x2F;&#x2F; error
std::unique_ptr&lt;int&gt; p3 &#x3D; std::move(p);
std::unique_ptr&lt;int&gt; p4；
p4 &#x3D; std::move(p3);  &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从实现上讲，unique_ptr是一个disable了普通拷贝构造函数、普通赋值运算符，但保留了移动拷贝构造函数、移动赋值运算符。程序员仅可以使用右值对unique_ptr对象进行构造，而且一旦构造成功，原unique对象中的heap指针即被”窃取”，即刻失去了对heap指针的”所有权”。”窃取”的操作是在unique_ptr移动拷贝构造函数、移动赋值运算符的定义里实现。    </p>
<h4 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h4><p>unique_ptr和shared_ptr相比，前者可以直接指向一个数组heap，后者指向数组heap时需要指定删除器：   </p>
<pre class="line-numbers language-none"><code class="language-none">unique_ptr&lt;int[]&gt; p(new int[10]);  &#x2F;&#x2F;ok
shared_ptr&lt;int[]&gt; p2(new int[10]);  &#x2F;&#x2F;error，需要指定删除器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>unique_ptr指定删除器的方式也不同于shared_ptr：    </p>
<pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;ok
std::unique_ptr&lt;int&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>unique_ptr在指定删除器时需要确定删除器的类型：   </p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int, void(*)(int *)&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;ok<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>但是要注意</strong>：当上面的lambda表达式不捕获变量时是可以的，但是当捕获变量的时候就报错，因为lambda不捕获变量时是可以直接转换为函数指针，当捕获时就不能转换为函数指针了，此时需要这样写：   </p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int, std::function&lt;void(int *)&gt;&gt; p(new int(2), [&amp;](int *p)&#123;delere p;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-5-3、weak-ptr弱引用智能指针"><a href="#6-5-3、weak-ptr弱引用智能指针" class="headerlink" title="6.5.3、weak_ptr弱引用智能指针"></a>6.5.3、weak_ptr弱引用智能指针</h3><p>它是用来监视shared_ptr的，更像是shared_ptr的助手，不会使引用计数加1。而且其内部并没有重载*和-&gt;，不能操作heap资源。   </p>
<h4 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h4><ul>
<li><strong>使用use_count()获取当前观测资源的引用计数</strong>    </li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));
weak_ptr&lt;int&gt; wp(sp);
wp.use_count();  &#x2F;&#x2F; 输出为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>通过expired()判断所观测的资源是否被释放</strong>   </p>
<pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));
weak_ptr&lt;int&gt; wp(sp);

if(wp.expired())
&#x2F;&#x2F;wp无效，所监视的资源已释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><strong>通过lock获取所监视的shared_ptr</strong><br>原型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::shared_ptr&lt;T&gt; lock() const noexcept;

Creates a new std::shared_ptr that shares ownership of the managed object. If there is no managed object, i.e. *this is empty, then the returned shared_ptr also is empty.   
Effectively returns expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this), executed atomically.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>lock返回的是新shared_ptr，与它所监视的shared_ptr共享所有权，详见<strong>6.5.3.4节</strong></p>
<pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));
weak_ptr&lt;int&gt; wp;
wp &#x3D; sp;

if(wp.expired())
&#x2F;&#x2F;wp无效，所监视的资源已释放
else
&#123;
    auto spt &#x3D; wp.lock();
    *spt;   &#x2F;&#x2F; 结果是10
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="2、std-enable-shared-from-this原理"><a href="#2、std-enable-shared-from-this原理" class="headerlink" title="2、std::enable_shared_from_this原理"></a>2、std::enable_shared_from_this原理</h4><p>enable_shared_from_this类中有一个weak_ptr，这个weak_ptr用来监视继承类的shared_ptr对象，调用shared_from_this成员函数时会调用内部的lock方法，构建新的shared_ptr对象并返回，而不是返回this指针，返回的shared_pt对象与weak_ptr所监视的继承类的shared_ptr对象共享所有权</p>
<p>enable_shared_from_this是一个模板类，头文件<memory>，其原型为：</p>
<p><code>template&lt; class T &gt; class enable_shared_from_this;</code></p>
<p>若一个类 T 继承 <code>std::enable_shared_from_this&lt;T&gt; </code>，则会为该类 T 提供成员函数： <code>shared_from_this</code> 。 当 T 类型对象 t 被一个为名为 pt 的 <code>std::shared_ptr&lt;T&gt;</code> 类对象管理时，调用 <code>T::shared_from_this</code> 成员函数，将会返回一个新的 <code>std::shared_ptr&lt;T&gt; </code>对象，它与 pt 共享 t 的所有权。<br><code>std::enable_shared_from_this</code> 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 <code>std::shared_ptr</code> 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。这也就意味着只有<code>std::shared_ptr</code> 实例才可以调用<code>shared_from_this</code> 成员函数</p>
<ul>
<li>使用场景<br>当类T被share_ptr管理，且在类T的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的<code>share_ptr</code>   </li>
</ul>
<p>那么问题就来了：<br><strong>为何不能直接传递this指针？</strong><br>使用智能指针的初衷就是为了方便资源管理，如果在某些地方使用智能指针，某些地方使用原始指针，很容易破坏智能指针的语义，进而产生各种错误。   </p>
<p>直接传递this在异步场景下，容易出现无法”保活”的问题，即发生异步调用时无从知晓this指向的对象是否已经被析构。此时若使用<code>shared_from_this</code>使引用计数增加，即可确保异步调用期间对象不会被析构，详见下方示例”异步调用场景”。</p>
<p><strong>为何不直接传递share_ptr<this>？</strong><br>这样会出现一个this构建两个shared_ptr对象，导致重复析构的问题。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;
 
class Bad
&#123;
public:
    std::shared_ptr&lt;Bad&gt; getptr() &#123;
        &#x2F;&#x2F; 有一些业务场景需要在类的成员函数里将类对象的指针传递给其他函数，这是如果使用getptr就会引起重复析构的问题
        return std::shared_ptr&lt;Bad&gt;(this);
    &#125;
~Bad() &#123; 
    std::cout &lt;&lt; &quot;Bad::~Bad() called&quot; &lt;&lt; std::endl; 
&#125;
&#125;;
 
int main()
&#123;
    &#x2F;&#x2F; 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者
    std::shared_ptr&lt;Bad&gt; bp1(new Bad());
    std::shared_ptr&lt;Bad&gt; bp2 &#x3D; bp1-&gt;getptr();
    &#x2F;&#x2F; 打印bp1和bp2的引用计数
    std::cout &lt;&lt; &quot;bp1.use_count() &#x3D; &quot; &lt;&lt; bp1.use_count() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;bp2.use_count() &#x3D; &quot; &lt;&lt; bp2.use_count() &lt;&lt; std::endl;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序会因重复析构而崩溃</p>
<p><font color=red><strong>异步调用场景</strong></font></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Foo
&#123;
public:
    coid Bar(std::function&lt;void(Foo *)&gt; p_func_callback)
    &#123;
        &#x2F;&#x2F; async call p_func_callback whit this
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Foo::Bar接受一个函数对象，这个对象需要一个Foo*指针，其实要的就是Foo::Bar的this指针，但是这个回调是异步的，也就是说可能在调用这个回调函数时，this指向的Foo对象已经提前析构了。这时候，std::enable_shared_from_this就派上用场了。修改后如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Foo
&#123;
public:
    coid Bar(std::function&lt;void(std::shared_ptr&lt;Foo&gt;)&gt; p_func_callback)
    &#123;
        std::shared_ptr&lt;Foo&gt; spt_foo &#x3D; shared_from_this();
        &#x2F;&#x2F; async call p_func_callback whit sptr_foo
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以shared_from_this获取对象使引用计数增加，进而保证对象在异步调用期间不会被析构。</p>
<h4 id="3、weak-ptr解决shared-ptr循环引用问题"><a href="#3、weak-ptr解决shared-ptr循环引用问题" class="headerlink" title="3、weak_ptr解决shared_ptr循环引用问题"></a>3、weak_ptr解决shared_ptr循环引用问题</h4><pre class="line-numbers language-none"><code class="language-none">struct A
&#123;
    std::shared_ptr&lt;B&gt; bptr;
    ~A()
    &#123;
        cout&lt;&lt;&quot;A is deleted&quot;&lt;&lt;endl;
    &#125;
&#125;
    
struct B
&#123;
    std::weak_ptr&lt;A&gt; aptr;
    ~B()
    &#123;
        cout&lt;&lt;&quot;B is deleted&quot;&lt;&lt;endl;
    &#125;
&#125;

void Test()
&#123;
    shared_ptr&lt;A&gt; ap(new A);
    shared_ptr&lt;B&gt; bp(new B);
    ap-&gt;bptr &#x3D; bp;
    bp-&gt;aptr &#x3D; ap;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于aptr是weak_ptr，它并不会增加引用计数，所以ap的引用计数仍然是1，在离开作用域之后，ap的引用计数是0，A指针被析构，析构后，其内部的bptr的引用计数减1，然后离开作用域的后的bp引用计数又从1减为0，B指针也被析构。</p>
<h4 id="4、weak-ptr的lock函数"><a href="#4、weak-ptr的lock函数" class="headerlink" title="4、weak_ptr的lock函数"></a>4、weak_ptr的lock函数</h4><p>函数原型</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::shared_ptr&lt;T&gt; lock() const noexcept;

Creates a new std::shared_ptr that shares ownership of the managed object. If there is no managed object, i.e. *this is empty, then the returned shared_ptr also is empty.   
Effectively returns expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this), executed atomically.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>lock返回的是新shared_ptr，与它所监视的shared_ptr对象共享所有权<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;

class TEST
&#123;
public:
    int32_t value_;
&#125;;

int main()
&#123;
    std::shared_ptr&lt;TEST&gt; sptr_a(new TEST());
    sptr_a-&gt;value_ &#x3D; 10;
    std::cout &lt;&lt; &quot;01 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;

    std::shared_ptr&lt;TEST&gt; sptr_b(sptr_a);
    std::cout &lt;&lt; &quot;02 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;

    std::weak_ptr&lt;TEST&gt; wptr_a(sptr_a);
    std::cout &lt;&lt; &quot;03 counter is: &quot; &lt;&lt; wptr_a.use_count() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;04 counter is: &quot; &lt;&lt; wptr_a.lock().use_count() &lt;&lt; std::endl;

    std::shared_ptr&lt;TEST&gt; sptr_c(wptr_a.lock());
    std::cout &lt;&lt; &quot;05 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
运行结果<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">01 counter is: 1
02 counter is: 2
03 counter is: 2
04 counter is: 3
05 counter is: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>lock的原子性<br>通过上面函数原型的注释来看，lock的操作是原子性的<code>executed atomically</code><br>那么为何lock的操作会是原子性的呢？   <ul>
<li>首先weak_ptr并不会引起shared_ptr的引用计数增加，说明weak_ptr对象中存放的就是shared_ptr；</li>
<li>对于某些异步场景，比如，当weak_ptr对象与shared_ptr对象不在同一个线程之中时，若想通过lock函数构建新的shared_ptr对象，这里就涉及到同一个shared_ptr对象在不同线程的读写问题，存在竞太条件，详见<strong>6.5.6节</strong></li>
</ul>
</li>
</ul>
<h3 id="6-5-4、RAII：智能指针的理论基础"><a href="#6-5-4、RAII：智能指针的理论基础" class="headerlink" title="6.5.4、RAII：智能指针的理论基础"></a>6.5.4、RAII：智能指针的理论基础</h3><p>详见<strong>1.8</strong>节</p>
<h3 id="6-5-5、weak-ptr解决回调函数中对象参数已消亡问题"><a href="#6-5-5、weak-ptr解决回调函数中对象参数已消亡问题" class="headerlink" title="6.5.5、weak_ptr解决回调函数中对象参数已消亡问题"></a>6.5.5、weak_ptr解决回调函数中对象参数已消亡问题</h3><p>在回调函数中有时需要调用其他对象指针的成员或函数，多线程模式下，可能不知道对象是否还活着，存在race condition的情况，通过weak_ptr的方式，在回调的时候先尝试提升为shared_ptr判断是否有效可以很好的解决此类问题，这种方式称作”弱回调”：</p>
<pre class="line-numbers language-none"><code class="language-none">class StacksFactory : pubic boost::enable_shared_from_this&lt;StocksFactory&gt;, boost::noncopyable
&#123;
public:
    shared_ptr&lt;Stock&gt; get(const string &amp;key)
    &#123;
        shared_ptr&lt;Stock&gt; pStock;
        MutexLockGuard lock(mutex_);
        weak_ptr&lt;Stock&gt;&amp;wStock &#x3D; stocks_[key];  &#x2F;&#x2F; 注意这里是引用
        pStock &#x3D; wStock.lock();
        if(!pStock)
        &#123;
            pStock.reset(new Stock(key), boost::bind(&amp;StockFactory::weakDeleteCallback, boost::weak_ptr&lt;StockFactory&gt;(shared_from_this()), _1));
            &#x2F;&#x2F; 必须强制把shared_from_this()转型为weak_ptr，才不会延长生命周期
            &#x2F;&#x2F; 因为boost::bind拷贝的是实参，而不是形参
            wStock &#x3D; pStock;
        &#125;
        return pStock;
    &#125;
    
private:
     static void weakDeleteCallback(const boost::weak_ptr&lt;StockFactory&gt;&amp; wStock, Stock* stock)
     &#123;
         shared_ptr&lt;StockFactory&gt; factory(wFactory.lock());  &#x2F;&#x2F; 尝试提升
         if(factory)
         &#123;
             factory-&gt;removeStock(stocj);
         &#125;
         delete stock;
     &#125;
    
    void removeStock(Stock* stock)
    &#123;
        if(stock)
        &#123;
            MutexLockGuard lock(mutex_);
            stocks_.erase(stock-&gt;key());
        &#125;
    &#125;
    
    mutable MutexLock mutex_;
    map&lt;string, weak_ptr&lt;StockFactory&gt;&gt; stocks_;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-5-6、shared-ptr的线程安全问题"><a href="#6-5-6、shared-ptr的线程安全问题" class="headerlink" title="6.5.6、shared_ptr的线程安全问题"></a>6.5.6、shared_ptr的线程安全问题</h3><p>参考：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb3e574eee5f">智能指针的线程安全</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/D_Guco/article/details/80155323?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">shared_ptr的线程安全性</a></p>
<p>shared_ptr对象的成员至少包括：</p>
<ul>
<li>一个指向堆空间对象的指针；</li>
<li>一个指向引用计数对象的指针；</li>
</ul>
<p>对这两个对象的操作不是一个指令可以完成的，因此多线程环境下，势必有问题<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE233bf2066ae985f9ecd2adf78712ffcf/39789" alt="image06"></p>
<p>线程安全的场景：   </p>
<ul>
<li><p>同一个shared_ptr对象被多个线程读，是线程安全的；</p>
</li>
<li><p>同一个shared_ptr对象被多个线程写，不是线程安全的；</p>
</li>
<li><p>引用计数的增、减操作是线程安全的（参见6.5.7节），但对管理引用计数的对象的操作不是线程安全的，详见下方示例；</p>
</li>
<li><p>线程安全</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread A
shared_ptr&lt;int&gt; p2(p); &#x2F;&#x2F; reads p

&#x2F;&#x2F; thread B
shared_ptr&lt;int&gt; p3(p); &#x2F;&#x2F; OK, multiple reads are safe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>p的赋值操作不涉及堆空间的写操作，仅是引用计数的增加，故是线程安全的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread A
p.reset(new int(1912)); &#x2F;&#x2F; writes p

&#x2F;&#x2F; thread B
p2.reset(); &#x2F;&#x2F; OK, writes p2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>p与p2虽然都被reset，并不涉及堆空间的写操作，仅是对引用计数的操作，故是线程安全的。</p>
</li>
<li><p>线程不安全<br>线程不安全的原因详见下方示例</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread A
p &#x3D; p3; &#x2F;&#x2F; reads p3, writes p

&#x2F;&#x2F; thread B
p3.reset(); &#x2F;&#x2F; writes p3; undefined, simultaneous read&#x2F;write<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread A
p3 &#x3D; p2; &#x2F;&#x2F; reads p2, writes p3

&#x2F;&#x2F; thread B
&#x2F;&#x2F; p2 goes out of scope: undefined, the destructor is considered a &quot;write access&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread A
p3.reset(new int(1));

&#x2F;&#x2F; thread B
p3.reset(new int(2)); &#x2F;&#x2F; undefined, multiple writes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><font color=red><strong>多线程场景下的竞态条件示例</strong></font><br>shared_ptr对象的拷贝、赋值操作至少包括如下两步：</p>
<ul>
<li>拷贝指向堆空间对象的指针;</li>
<li>拷贝引用计数对象的指针;</li>
</ul>
<p>考虑一个简单的场景，有 3 个 shared_ptr<Foo> 对象 x、g、n：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr&lt;Foo&gt; g(new Foo); &#x2F;&#x2F; 线程之间共享的 shared_ptr
shared_ptr&lt;Foo&gt; x; &#x2F;&#x2F; 线程 A 的局部变量
shared_ptr&lt;Foo&gt; n(new Foo); &#x2F;&#x2F; 线程 B 的局部变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>一开始，各安其事<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE0603c082a1b134065903a4ec2d59e798/39791" alt="image07"></p>
<p>线程 A 执行x = g;（即 read g），以下完成了步骤 1，还没来及执行步骤 2。这时切换到了 B 线程<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE2ba124e790af8967ad69aa28a4378909/39794" alt="image08"></p>
<p>同时线程 B 执行 g = n; （即 write G），两个步骤一起完成了<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE03443423e9145c6ed28a3deb23a4a626/39796" alt="image09"></p>
<p>这时 Foo1 对象已经销毁，x.ptr 成了空悬指针！<br>最后回到线程 A，完成步骤 2<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCEddbb3631887362b151a4fb1b18d77c43/39799" alt="image10"></p>
<p>多线程无保护地读写 g，造成了”x 是空悬指针”的后果。这正是多线程读写同一个 shared_ptr 对象必须加锁的原因。</p>
<h3 id="6-5-7、shared-ptr的引用计数源码"><a href="#6-5-7、shared-ptr的引用计数源码" class="headerlink" title="6.5.7、shared_ptr的引用计数源码"></a>6.5.7、shared_ptr的引用计数源码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;_Lock_policy _Lp &#x3D; __default_lock_policy&gt;
   class _Sp_counted_base
   : public _Mutex_base&lt;_Lp&gt;
   &#123;
   public:  
     _Sp_counted_base() noexcept
     : _M_use_count(1), _M_weak_count(1) &#123; &#125;
     
     virtual
     ~_Sp_counted_base() noexcept
     &#123; &#125;
 
     &#x2F;&#x2F;当_M_use_count为0时调用，是个纯虚函数(必须实现)，这个函数的作用是释放指针指向的对象所持有的资源，即*this
     virtual void
     _M_dispose() noexcept &#x3D; 0;
     
     &#x2F;&#x2F; 当_M_weak_count为0时调用，释放自己本身的资源，即this
     &#x2F;&#x2F;  _M_weak_count &#x3D; _M_weak_count + (_M_use_count!&#x3D; 0),当_M_weak_count和_M_use_count都为0时释放this
     virtual void
     _M_destroy() noexcept
     &#123; delete this; &#125;
     
     virtual void*
     _M_get_deleter(const std::type_info&amp;) noexcept &#x3D; 0;
 
    &#x2F;&#x2F;增加一个引用
     void
     _M_add_ref_copy()
     &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); &#125;
 
     void
     _M_add_ref_lock();
 
     bool
     _M_add_ref_lock_nothrow();
 
     void
     _M_release() noexcept
     &#123;
       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);
  &#x2F;&#x2F;首先use_count减去1，并对比减操作之前的值，如果减之前是1，说明减后是0，a1没有任何shared_ptr指针指向它了将销毁对象
if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) &#x3D;&#x3D; 1)
  &#123;
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);
    _M_dispose();
    &#x2F;&#x2F;如果destory和dispose存在内存屏障，保证dispose函数的效果在destory函数的调用该线程的可见性
    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
      &#123;
   __atomic_thread_fence (__ATOMIC_ACQ_REL);
      &#125;
 
    &#x2F;&#x2F;同时对a1的weak_count减去1，也对比减操作之前的值，如果减之前是1，说明减后是0，a1没有weak_ptr指向它了，
    &#x2F;&#x2F;应该将管理对象销毁，于是调用_M_destroy()销毁了管理对象
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,
                      -1) &#x3D;&#x3D; 1)
             &#123;
               _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
        _M_destroy();
             &#125;
  &#125;
     &#125;
 
     void
     _M_weak_add_ref() noexcept
     &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); &#125;
 
     void
     _M_weak_release() noexcept
     &#123;
       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);
if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) &#x3D;&#x3D; 1)
  &#123;
           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);
    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)
      &#123;
   __atomic_thread_fence (__ATOMIC_ACQ_REL);
      &#125;
    _M_destroy();
  &#125;
     &#125;
 
    &#x2F;&#x2F;获取引用计数 
     long
     _M_get_use_count() const noexcept
     &#123;
       return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);
     &#125;
 
   private:  
     _Sp_counted_base(_Sp_counted_base const&amp;) &#x3D; delete;
     _Sp_counted_base&amp; operator&#x3D;(_Sp_counted_base const&amp;) &#x3D; delete;
 
     _Atomic_word  _M_use_count;   
     _Atomic_word  _M_weak_count;   
   &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过其中的函数<code>_M_add_ref_copy()</code>实现可以看到，引用计数的增量操作是以atomic的原子类型进行的，故是线程安全的。<br>shared_ptr在多线程下传递使用时引用计数是不会有线程安全问题的，但是对shared_ptr对象的操作在多线程环境下却无法保证安全性，详见6.5.6节</p>
<h2 id="6-6、NULL、nullptr、0、nullptr-t"><a href="#6-6、NULL、nullptr、0、nullptr-t" class="headerlink" title="6.6、NULL、nullptr、0、nullptr_t"></a>6.6、NULL、nullptr、0、nullptr_t</h2><p>nullptr_t是个class，是nullptr的类型<br><font color=red>NULL、nullptr、0</font>均可表示空指针，区别如下：<br>C与C++中对NULL的定义</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Define NULL pointer value
#ifndef NULL
    #ifdef __cplusplus
        #define NULL    0
    #else  &#x2F;&#x2F; __cplusplus
        #define NULL    ((void *)0)
    #endif  &#x2F;&#x2F; __cplusplus
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在C中NULL就是个void*，而C++中是0<br>C++ NULL为0可能引发的问题，可以通过函数重载的例子看出：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;memory&gt;
void fun(int)
&#123;
    std::cout &lt;&lt; &quot;fuck1&quot; &lt;&lt; std::endl;
&#125;
void fun(void *)
&#123;
    std::cout &lt;&lt; &quot;fuck2&quot; &lt;&lt; std::endl;
&#125;
int main(int argc, char *argv[])
&#123;
    fun(NULL);
    system(&quot;pause&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般来说，我们传进去一个NULL，想要调用是参数为指针的重载函数fun，但实际调用的是int的版本。这是因为C++中NULL就是整形值(size_t)0，调用时当发现没有匹配size_t类型的重载函数，会发生隐式转换为int，进而与void fun(int)匹配。为解决此问题，C++引入了nullptr。</p>
<h3 id="6-6-1、nullptr"><a href="#6-6-1、nullptr" class="headerlink" title="6.6.1、nullptr"></a>6.6.1、nullptr</h3><p>nullptr并不是(void*)0的一个别名，nullptr是一个关键字、编译时期的常量，能够为编译器所识别。nullptr可以被隐式转换为任意类型的指针，但C++中(void*)不可以隐式转换，必须要显式指明被转换的指针类型</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int foo()
&#123;
int*px&#x3D;(void*)0;  &#x2F;&#x2F; 编译错误， 不能隐式地将无类型指针转换为int*类型的指针
int*px&#x3D;(int *)((void*)0);  &#x2F;&#x2F;ok
int*py&#x3D;nullptr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>nullptr实际上是一个编译期行为，编译器会识别nullptr的存在，虽然编译时会将nullptr替换为一个指定整形，比如0，但由于其是编译期行为，明确知晓它是一个nullpter_t类型，进而可以有效规避NULL与0的重载问题</p>
<h2 id="6-7、this、空指针、野指针"><a href="#6-7、this、空指针、野指针" class="headerlink" title="6.7、this、空指针、野指针"></a>6.7、this、空指针、野指针</h2><ul>
<li>this指针<ul>
<li>this是指向类对象的指针，编译器会将this作为第一个参数传递给非静态成员函数；</li>
<li>this虽然是个指针，但它是一种特殊的指针，不能通过取地址符&amp;来获取this的指针地址，否则编译器会报错；</li>
<li>this既不占据类的内存空间，也不占据类对象的内存空间，通常存放在寄存器之中。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Empty  &#x2F;&#x2F; 只占1byte，用于占位符
&#123;

&#125;;

int main()
&#123;
    Empty obj;
    std::cout &lt;&lt; sizeof(Empty) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(obj) &lt;&lt; std::endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1    1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>空类以及空的类对象只占1Byte，说明this指针既不占据类的内存空间，也不占据类对象的内存空间</p>
<ul>
<li><p>this是一个指针常量，不能修改this指针的值；</p>
</li>
<li><p>空指针<br>被赋值为NULL、nullptr、0的指针</p>
</li>
<li><p>野指针<br>被delete、free且未被赋值为NULL、nullptr、0的指针</p>
</li>
</ul>
<p>空指针与野指针在内存访问行为上是有区别的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()
&#123;
    Car *ptr_one_car &#x3D; new Car(4);
    std::cout &lt;&lt; &quot;01******&quot; &lt;&lt; std::endl;
    ptr_one_car-&gt;print();
    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;\n02******&quot; &lt;&lt; std::endl;
    delete ptr_one_car;  &#x2F;&#x2F; 野指针
    ptr_one_car-&gt;print();
    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;

    ptr_one_car &#x3D; nullptr;  &#x2F;&#x2F; 空指针
    std::cout &lt;&lt; &quot;\n03******&quot; &lt;&lt; std::endl;
    ptr_one_car-&gt;print();
    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;
    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">01******
I have 4 wheeves
4

02******
I have 4 wheeves
0

03******
I have 4 wheeves
Segmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>1、由于print函数并未访问任何类成员，所以并未使用到this指针，故不会报错；<br>2、访问类成员wheels_时需要使用this指针，而空指针是不允许被访问的，故03报core dumped错，而野指针虽然已被delete，但此内存区域仍存在，可能空闲也可能被他人使用或者被系统回收，所以野指针有些时候访问是OK的，存在不确定行为；</p>
<h2 id="6-8、函数指针"><a href="#6-8、函数指针" class="headerlink" title="6.8、函数指针"></a>6.8、函数指针</h2><p>函数指针的定义形如：</p>
<pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此处便定了一个函数指针seq_ptr，指向的函数类型是const int *返回值，参数列表是char和float.<br>也可以像普通变量那样，为函数指针赋初值：</p>
<pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float) &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数指针数组：</p>
<pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float) &#x3D; 
&#123;
    fibon_ptr, lucas_ptr, pell_ptr
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="6-9、原始指针的不妥"><a href="#6-9、原始指针的不妥" class="headerlink" title="6.9、原始指针的不妥"></a>6.9、原始指针的不妥</h2><p>原始指针存在的问题：     </p>
<ul>
<li>1、缓存区溢出 buffer overrun；</li>
<li>2、空悬指针/野指针；</li>
<li>3、重复释放double delete；</li>
<li>4、内存泄漏memory leak；</li>
<li>5、不配对的new[]/delete；</li>
<li>6、内存碎片memory fragmentation；</li>
</ul>
<p>针对以上的指针问题的解决方案：</p>
<ul>
<li>1、缓存区溢出：设计保存缓存区长度的成员；</li>
<li>2、空悬指针/野指针：智能指针解决；</li>
<li>3、重复释放：只在对象析构时释放；</li>
<li>4、内存泄漏：在对象析构时释放；</li>
<li>5、不配对的new[]/delete：把new[]替换成容器形式，逐一遍历delete；</li>
</ul>
<h2 id="6-10、、C-C-指针问题的根源"><a href="#6-10、、C-C-指针问题的根源" class="headerlink" title="6.10、、C/C++指针问题的根源"></a>6.10、、C/C++指针问题的根源</h2><p>指针就是指向一块内存，由操作系统管理，程序自身无从知晓内存是否越界、是否被释放等状态，既然无从知晓内存的状态，便无法判断一个指针是否有效，这就是C/C++指针问题的根源。  </p>
<ul>
<li>内存越界的判断是由CPU的(控制单元 + 地址寄存器)完成；</li>
<li>唯一能在程序中做的就是指针的判空行为，但此操作仅在单线程中有效，在多线程时便失效了，详见《服务器多线程编程》的1.4节。</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">IPanda</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xman123ing.github.io/2021/07/10/C-plus-%E5%A3%B9/">https://xman123ing.github.io/2021/07/10/C-plus-%E5%A3%B9/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">IPanda</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/07/10/C-plus-%E5%A3%B9/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="C-plus-壹">
                        
                        <span class="card-title">C-plus-壹</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                    summary && 技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/10/C-plus-%E8%B4%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="C-plus-贰">
                        
                        <span class="card-title">C-plus-贰</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                    summary && 技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: IPanda`s Blog<br />'
            + '文章作者: IPanda<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">IPanda</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "3";
                    var startDate = "7";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已努力运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Xman123ing/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lipin075084@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=836070413" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 836070413" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script src="/js/prism/prism.js" async></script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.8'
        zIndex="-1" count="150"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
