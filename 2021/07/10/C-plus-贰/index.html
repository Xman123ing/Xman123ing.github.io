<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="C-plus-贰, 中国地质大学(武汉)2008-2012 Asia亚信 IFly科大讯飞 OPPO">
    <meta name="description" content="技术分享 | C/C++ | 服务器后端 | 计算机系统 | 嵌入式系统 | FreeRTOS | SensorHub">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C-plus-贰 | IPanda`s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/css/prism-dark.css" type="text/css"></head>
<link rel="stylesheet" href="/js/prism/prism.css">




<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">IPanda`s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">IPanda`s Blog</div>
        <div class="logo-desc">
            
            技术分享 | C/C++ | 服务器后端 | 计算机系统 | 嵌入式系统 | FreeRTOS | SensorHub
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Xman123ing/Xman123ing.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Xman123ing/Xman123ing.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C-plus-贰</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                summary && 技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-07-10
                </div>
                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="7、关键字-amp-amp-修饰符"><a href="#7、关键字-amp-amp-修饰符" class="headerlink" title="7、关键字&amp;&amp;修饰符"></a>7、关键字&amp;&amp;修饰符</h1><h2 id="7-1、static"><a href="#7-1、static" class="headerlink" title="7.1、static"></a>7.1、static</h2><ul>
<li><p>隐藏<br>这是最重要的一个作用   </p>
<ul>
<li>作用域：具有static前缀的变量和函数仅当前源文件可见，故不能使用extern关键字；   </li>
<li>普通变量不能在头文件中定义，当被多个文件include时会报重复定义错误，需要使用extern关键字，才能将其具有跨文件作用域的全局性；   </li>
<li>静态变量和函数可以在头文件定义，不会报重复定义错误，因其不具备跨文件作用域的全局性。每个include的文件中都是独立分配的内存空间，彼此之间并无关联性；   </li>
</ul>
</li>
<li><p>生命周期<br>全局变量、静态全局变量、静态局部变量的生命周期都是整个程序运行期间</p>
</li>
<li><p>修饰C++类成员变量和函数<br>static成员属于整个类，不属于任何对象；<br>static成员变量内存只分配一次，对类的所有对象只有一份拷贝；<br>static成员变量和函数只能被本类访问，对类外不可见；<br>static成员函数不接收this指针，因此只能访问static成员；<br>static成员函数不能被virtual修饰，因为static成员不属于任何对象/实例，没有this指针，而virtual函数的实现是通过为每一有个对象分配一个vptr指针，而vptr是通过this指针调用地； </p>
</li>
</ul>
<h3 id="7-1-1、static特例场景"><a href="#7-1-1、static特例场景" class="headerlink" title="7.1.1、static特例场景"></a>7.1.1、static特例场景</h3><ul>
<li><p>static变量和函数的定义可以放在头文件，普通函数和变量的定义不能放在头文件，否则编译报错： ***** redefinition。 static变量和函数被include进源文件之后，都是独立的拷贝，彼此之间无关联；</p>
</li>
<li><p>类的static成员在类中定义之后，必须要在源文件中再显示定义一次，这是由static的两个属性决定的：</p>
<ul>
<li>static作用域仅限当前文件；</li>
<li>类的static成员只属于类，不属于类的对象；    </li>
</ul>
<p>所以必须要再次显示定义类static成员，为其在某一个源文件之中申请内存。</p>
</li>
</ul>
<p>否则编译报错：****undefined</p>
<h3 id="7-1-2、初始化时机及线程安全性"><a href="#7-1-2、初始化时机及线程安全性" class="headerlink" title="7.1.2、初始化时机及线程安全性"></a>7.1.2、初始化时机及线程安全性</h3><ul>
<li>全局变量、全局静态变量<ul>
<li>C语言中，它们的初始化发生在main函数之前，属于编译器常量；</li>
<li>C++中，对于非类对象的全局变量、全局静态变量，初始化时机与C语言一致；</li>
<li>C++中，类对象的全局变量、全局静态变量只有在第一次使用时才会进行初始化，这个’使用’包括显示调用该变量以及其他调用发生在其所在的源文件之中；<br>C++的对象必须由构造函数生成，并最终执行析构函数释放，由于构造动作需要执行相关代码，无法在编译期完成，所以类对象的全局变量、全局静态变量不是编译器常量，只有在第一次使用时才会进行初始化；</li>
</ul>
</li>
<li>局部静态变量<ul>
<li>C和C++中，都是第一次使用时才会进行初始化；</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;

class Wheel
&#123;
public:
    Wheel()&#123;std::cout &lt;&lt; &quot;Wheel constructor&quot; &lt;&lt; std::endl;&#125;
    ~Wheel()&#123;&#125;
&#125;;

class Window
&#123;
public:
    Window()&#123;std::cout &lt;&lt; &quot;Window constructor&quot; &lt;&lt; std::endl;&#125;
    ~Window()&#123;&#125;
&#125;;

class Car
&#123;
public:
    Car()&#123;std::cout &lt;&lt; &quot;Car constructor&quot; &lt;&lt; std::endl;&#125;
    ~Car()&#123;&#125;
    void print()
    &#123;
        static Window four_windows;
        std::cout &lt;&lt; &quot;I have four windows&quot; &lt;&lt; std::endl;
    &#125;

    static Wheel four_wheels;
&#125;;

Wheel Car::four_wheels;

int main()
&#123;
    std::cout &lt;&lt; &quot;step in main&quot; &lt;&lt; std::endl;
    Car my_car;
    my_car.print();
    std::cout &lt;&lt; &quot;step out main&quot; &lt;&lt; std::endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">Wheel constructor
step in main
Car constructor
Window constructor
I have four windows
step out main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>虽然并没有显式调用静态变量four_wheels，但声明语句’Wheel Car::four_wheels;’被放在main.cpp源文件之中，main函数的调用也发生在此文件之中，所以静态变量four_wheels完成了它的第一次使用；   </p>
<p>假如声明语句’Wheel Car::four_wheels;’放在另一个不相干的源文件之中，比如a.cpp，且没有任何的调用牵涉到a.cpp文件，那么静态变量four_wheels就没有被使用，运行结果也便不会打印’Wheel constructor’     </p>
<ul>
<li><strong>线程安全性</strong><ul>
<li>非类对象的全局变量、全局静态变量的初始化发生在main函数之前，故不存在线程安全性问题；</li>
<li>类对象的全局变量、全局静态变量以及局部静态变量，只有当第一次使用时才会进行初始化，故存在线程安全性问题。C++11之前并未对此有强制要求，故其线程安全性是存在问题的，但C++标准对此有了强制要求，要求编译器实现其线程安全性，例如g++使用了类似全局锁的方式解决此问题；</li>
</ul>
</li>
</ul>
<h3 id="7-1-3、优势"><a href="#7-1-3、优势" class="headerlink" title="7.1.3、优势"></a>7.1.3、优势</h3><ul>
<li>static变量和函数会在静态存储区申请空间，具有完整声明周期，与程序声明周期相同。在static变量访问、static函数调用时不用反复出栈入栈；</li>
<li>static变量和函数仅限当前文件作用域，故其他文件可以有相同名称的变量和函数；</li>
</ul>
<h2 id="7-2、const"><a href="#7-2、const" class="headerlink" title="7.2、const"></a>7.2、const</h2><p>const并不能代表”常量”，它仅仅是对变量的一种修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过指针间接的修改）。而这个变量的值，既可以在运行时也可以在编译时指定。    </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">const int a &#x3D; 123;  &#x2F;&#x2F;  编译时常量
void getResult(const int b);  &#x2F;&#x2F;  运行时常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>const可以修饰变量、函数、指针、函数返回值、形参、类成员变量、类成员函数</p>
<ul>
<li>设置变量常量性，定义时既要初始化。对于类的const成员变量则必须在初始化列表里进行初始化，也可在class的声明处初始化，此方法与在构造函数的初始化列表里初始化相同，如果此时初始化列表重新指定值，那么声明时的值就会被修改掉；</li>
<li>对于指针来说，可以修饰指针本身int *const ptrA，也可以修饰指针指向的对象const int *ptrA、int const *ptrA;</li>
<li>修饰函数返回值const int functionName()，使其返回值不能为”左值”，不能被修改，例如返回指向堆的指针；</li>
<li>指定类成员函数为常函数，int functionName() const，不能修改类的成员变量。类的常量对象只能访问类的常函数；</li>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li>
<li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li>
<li>const属性可以通过类型转换符const_cast转换为非const；</li>
</ul>
<p>示例：    </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">①const Stock &amp; Stock::topval (②const Stock &amp; s)③const   

①处const：确保返回的Stock对象在以后的使用中不能被修改	
②处const：确保此方法不修改形参s，或者说不能修改传递给形参s的实参
③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-2-1、const特例场景"><a href="#7-2-1、const特例场景" class="headerlink" title="7.2.1、const特例场景"></a>7.2.1、const特例场景</h3><ul>
<li>const变量的定义可以放在头文件，普通变量的定义不能放在头文件，否则编译报错： ***** redefinition。 const变量被include进源文件之后，都是独立的拷贝，彼此之间无关联；</li>
<li>const之于函数重载<ul>
<li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参，则这个时候无论加不加const对实参不会产生任何影响；</li>
<li>但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。所以，只有引用传递和指针传递可以用是否加const来重载，而值传递的const不具备重载性；</li>
</ul>
</li>
</ul>
<h2 id="7-3、mutable"><a href="#7-3、mutable" class="headerlink" title="7.3、mutable"></a>7.3、mutable</h2><p>如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;</p>
<h2 id="7-4、extern"><a href="#7-4、extern" class="headerlink" title="7.4、extern"></a>7.4、extern</h2><ul>
<li>声明外部属性，修饰变量、函数；</li>
<li>指示C、C++编译规范：<br>比如在C＋＋中调用C库函数，就需要在C＋＋程序中用如下命令声明要引用的函数   </li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif

void print(char *);
    
#ifdef __cplusplus
&#125;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</p>
<h2 id="7-5、inline"><a href="#7-5、inline" class="headerlink" title="7.5、inline"></a>7.5、inline</h2><p>inline用于定义内联函数<br><strong>产生背景：</strong>    </p>
<ul>
<li>函数调用时需要出栈入栈，频繁的出入栈时间成本增加，且会造成栈空间的大量消耗；</li>
<li>取代宏表达式，内联函数与普通函数一样，编译时会进行严格的类型检查，不像宏表达式没有类型检查，只是简单的文本替换，且宏表达式的编译错误很难发现；</li>
</ul>
<p><strong>PS：</strong>   </p>
<ul>
<li><p>inline只是对编译器的一种建议，编译器并不一定会将函数变成内联函数，是否内联依赖于函数具体实现、编译选项等因素：   </p>
<ul>
<li>默认编译优化选项-O0时inline不起作用，-O2、-O3时inline会生效；</li>
<li>存在inline函数的指针调用时，inline在调用位置失去内联属性，与普通函数无异；</li>
<li>存在结构控制语句时不生效，例如while、switch、for；</li>
<li>函数体实现过长时也不生效；</li>
</ul>
</li>
<li><p>inline函数定义可以放在头文件之中，符合语法规则。因为inline函数在调用处就地展开，不同调用处均是互不相干inline的函数副本；</p>
</li>
<li><p>inline函数只能有定义，不能单独进行声明，类成员函数除外，说明如下：</p>
<ul>
<li>声明处的inline是无效的，编译会报错：***** is not defined<br>因为inline函数编译期需要在调用处直接展开，它不能像普通函数一样通过声明去找函数定义体，所以要求inline的声明和定义必须是一体的，类成员函数除外。<br>示例：<br>假如inline的声明和定义是分开的，不管声明处是否显式包含inline，编译都会报错</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">inline void func(void)
ERROR: inline function func is not defined  &#x2F;&#x2F;inline函数声明

void func(void)
ERROR: function func is not defined  &#x2F;&#x2F;报错信息不同于上面的例子，这是因为声明处是普通函数func，它会去源文件中查找函数func的定义，而源文件中只有inline func，二者是没有关联的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用场景：</strong>   </p>
<ul>
<li>函数定义较短，且调用的地方不是很多。这是因为内联函数的汇编代码会在调用处展开，如果函数体过大或调用处过多，会造成代码膨胀；    </li>
</ul>
<p>内联函数在编译时会就地展开，不生成独立汇编码，<strong>不会生成函数名，所以也不会添加进符号表之中</strong>，故在文件作用域外无法调用inline函数，否则编译报错：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">undefined reference to ***<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="7-6、constexpr"><a href="#7-6、constexpr" class="headerlink" title="7.6、constexpr"></a>7.6、constexpr</h2><p>首先了解两个概念：</p>
<ul>
<li>编译时常量；</li>
<li>运行时常量；</li>
</ul>
<p>通常来讲运行时常量是指使用const修饰的对象，const可以修饰函数参数、函数返回值、函数本身、类等，在不同的使用条件下，const有不同的意义，不过大多数情况下，const描述的都是一些”运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的。</p>
<pre class="line-numbers language-none"><code class="language-none">const int GetConst()&#123;return 1;&#125;
void Constless(int cond)
&#123;
    int arr[GetConst()]&#x3D;&#123;0&#125;;&#x2F;&#x2F;无法通过编译
    enum&#123;e1&#x3D;GetConst(),e2&#125;;&#x2F;&#x2F;无法通过编译
    switch(cond)
        &#123;
            case GetConst():&#x2F;&#x2F;无法通过编译
            break;
            default:
            break;
        &#125; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>数组大小、枚举值和switch均是需要编译时常量。   </p>
<p>此时便需要常量表达式，将函数或值转换为常量表达式函数或常量表达式值，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">constexpr int GetConst()&#123;return 1;&#125;constexpr int i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>常量表达式主要是允许一些计算发生在编译时Compile-time calculation。<br>constexpr可以使代码具有编译时运算的能力，同inline关键字类似，但constexpr只是一种建议，是否发挥作用还取决于具体的调用。</p>
<p>constexpr可以修饰变量、函数、构造函数</p>
<h3 id="7-6-1、constexpr修饰函数时的限制"><a href="#7-6-1、constexpr修饰函数时的限制" class="headerlink" title="7.6.1、constexpr修饰函数时的限制"></a>7.6.1、constexpr修饰函数时的限制</h3><ul>
<li>函数体只能有一个return语句（C++14之后此限制放开了，只要return语句返回的是常量即可）；</li>
<li>只能调用其他constexpr函数；</li>
<li>只能使用全局constexpr变量</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">constexpr int32_t getValue() &#123;return 1;&#125;constexpr int32_t getLength(int32_t i) &#123;return i + 2;&#125;constexpr int32_t getLength02(int32_t i)&#123;    i +&#x3D; 2;    return i;&#125;int main()&#123;    int32_t i &#x3D; 3;    int32_t nums01[getValue()] &#x3D; &#123;1&#125;;  &#x2F;&#x2F; ok    int32_t nums02[getLength(1)] &#x3D; &#123;3&#125;;  &#x2F;&#x2F; ok    int32_t nums03[getLength02(2)] &#x3D; &#123;4&#125;;  &#x2F;&#x2F; ok        std::cout &lt;&lt; nums01[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums02[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums03[0] &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-6-2、constexpr修饰构造函数"><a href="#7-6-2、constexpr修饰构造函数" class="headerlink" title="7.6.2、constexpr修饰构造函数"></a>7.6.2、constexpr修饰构造函数</h3><p>可以构造函数声明为constexpr，则在编译期就可以构造类对象，要求构造函数调用处传入的参数都必须是常量</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Circle&#123;    public:    constexpr Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) &#123;&#125;    constexpr double getArea ()    &#123;        return _radius * _radius * 3.1415926;    &#125;    private:        int _x;        int _y;        int _radius;&#125;;constexpr Circle temCircle(0, 0, 10);  &#x2F;&#x2F; 编译期执行构造函数，计算半径为10的Circle面积<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-6-3、constexpr与const"><a href="#7-6-3、constexpr与const" class="headerlink" title="7.6.3、constexpr与const"></a>7.6.3、constexpr与const</h3><pre class="line-numbers language-none"><code class="language-none">const int i&#x3D;1;constexpr int j&#x3D;1;  &#x2F;&#x2F; 常量表达式值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>大多数情况下这两种声明方式没有区别，都是将变量声明为常量，主要不同之处在于i不能用于编译期常量的场景，比如数组大小、枚举值和switch值等。</p>
<h2 id="7-7、mallloc-free和new-delete的区别"><a href="#7-7、mallloc-free和new-delete的区别" class="headerlink" title="7.7、mallloc/free和new/delete的区别"></a>7.7、mallloc/free和new/delete的区别</h2><ul>
<li>malloc/free是C语言的库函数，而new/delete是C++的关键字，故他们不能被重载，但它们的二级调用operator new / operator delete可以被重载；</li>
<li>malloc/free只能用于基本类型，而new/delete不但可以用于基本类型还可用于自定义类型；</li>
<li>malloc返回的是void*类型，需要显示转换为指定类型，new不涉及类型转换的问题；</li>
<li>maloc只负责申请空间，并返回首地址，new运算符除了申请空间，还调用构造函数进行初始化。free函数只负责释放空间，并标识这段空间是可用空间，delete除了释放空间，还调用析构函数；</li>
</ul>
<p>事实上，new/delete的功能已经完全覆盖了malloc/free。</p>
<h2 id="7-8、delete和delete-的区别"><a href="#7-8、delete和delete-的区别" class="headerlink" title="7.8、delete和delete[]的区别"></a>7.8、delete和delete[]的区别</h2><p>对于基本类型delete和delete[]没有区别，都可以正常释放单个空间或数组空间，对于数组空间，系统可以根据数组长度和数据类型计算出数组所占空间，然后一次性释放。    </p>
<p>但是对于自定义类型，delete只会释放数组的第一个元素，其他元素空间并不会释放，而delete[]可以循环释放数组所有元素的空间。</p>
<h1 id="8、异常处理"><a href="#8、异常处理" class="headerlink" title="8、异常处理"></a>8、异常处理</h1><p>异常处理机制主要包含两个部分：</p>
<ul>
<li>异常的鉴定与抛出；</li>
<li>异常的捕获与处理</li>
</ul>
<p>异常抛出之后，当前的执行流程会被暂停，然后在程序的全局范围内搜索可以捕获此异常的地方，异常处理完之后，程序会从异常处理点继续往下执行（<strong>不一定是抛出异常的地方</strong>）    </p>
<p>异常处理提供了一种转移程序控制权的方式    </p>
<p>程序运行时常会碰到一些异常情况，例如：</p>
<ul>
<li>做除法的时候除数为 0；</li>
<li>用户输入年龄时输入了一个负数；<br>*用 new 运算符动态分配空间时，空间不够导致无法分配；</li>
<li>访问数组元素时，下标越界；打开文件读取时，文件不存在；</li>
</ul>
<p>这些异常情况如果不能被发现并加以处理，很可能会导致程序崩溃</p>
<p>所谓”处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。   </p>
<p>一发现异常情况就立即处理未必妥当，因为在一个函数执行过程中发生的异常，在有的情况下由该函数的调用者决定如何处理更加合适。</p>
<p>此外，将异常分散在各处进行处理不利于代码的维护，如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</p>
<p>C++ 引入了异常处理机制。其基本思想是：函数A在执行过程中发现异常时可以不加处理，而只是”拋出一个异常”给 A的调用者，假定为函数B。拋出异常而不加处理会导致函数A立即中止，在这种情况下，函数B可以选择捕获A拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。</p>
<p>如果一层层的函数都不处理异常，异常最终会被拋给最外层的main函数。main函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p>
<h2 id="8-1、抛出异常"><a href="#8-1、抛出异常" class="headerlink" title="8.1、抛出异常"></a>8.1、抛出异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;异常的抛出if(a &gt; b)throw compare_class_obj(a,b);if(a &lt;&#x3D; b)......<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当a大于b的时候，异常便会以类为compare_class_obj的对象抛出。<br>所谓抛出异常(throw exception)抛出的是一个实体，这个实体可以是一个复杂的类对象，也可以是一个简单的整形或字符串</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">throw 42;throw &quot;error: no buffer&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="8-2、捕获异常"><a href="#8-2、捕获异常" class="headerlink" title="8.2、捕获异常"></a>8.2、捕获异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool catchOperator()&#123;    catch(int errno)    &#123;        ......    &#125;    catch(const char*str)    &#123;        ....    &#125;    catch(compare_class_obj &amp;it)    &#123;        ....    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>被抛出异常对象的类型会被拿来逐一地与catch子句对比，如果类型符合，那么该catch子句便会被执行。<br>如果想要捕获所有类型的异常，可以使用一网打尽的方式，只需要在catch中使用(…)即可</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">catch(...)    &#123;        ....    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="8-3、try、catch组合"><a href="#8-3、try、catch组合" class="headerlink" title="8.3、try、catch组合"></a>8.3、try、catch组合</h2><p>try和catch通常搭配使用，try语句块抛出异常，catch语句块捕获异常</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include&lt;exception&gt;using namespace std;   int main()&#123;   cout &lt;&lt; &quot;Enter number of integers you wish to reserve: &quot;;   try   &#123;      int Input &#x3D; 0;      cin &gt;&gt; Input;      &#x2F;&#x2F; Request memory space and then return it      int* pReservedInts &#x3D; new int [Input];  &#x2F;&#x2F; new操作中包含throw语句      delete[] pReservedInts;     &#125;   catch (std::bad_alloc&amp; exp)   &#123;      cout &lt;&lt; &quot;Exception encountered: &quot; &lt;&lt; exp.what() &lt;&lt; endl;      cout &lt;&lt; &quot;Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   catch(...)   &#123;      cout &lt;&lt; &quot;Exception encountered. Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>std::bad_alloc表明捕获内存申请异常</p>
<p><strong>==配合throw自定义异常==</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;iostream&gt;using namespace std;double Divide(double Dividend, double Divisor)&#123;   if(Divisor &#x3D;&#x3D; 0)      throw &quot;Dividing by 0 is a crime&quot;;   return (Dividend &#x2F; Divisor);&#125;int main()&#123;   cout &lt;&lt; &quot;Enter dividend: &quot;;   double Dividend &#x3D; 0;   cin &gt;&gt; Dividend;   cout &lt;&lt; &quot;Enter divisor: &quot;;   double Divisor &#x3D; 0;   cin &gt;&gt; Divisor;   try   &#123;      cout &lt;&lt; &quot;Result of division is: &quot; &lt;&lt; Divide(Dividend, Divisor);   &#125;   catch(char* exp)   &#123;      cout &lt;&lt; &quot;Exception: &quot; &lt;&lt; exp &lt;&lt; endl;      cout &lt;&lt; &quot;Sorry, can&#39;t continue!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="8-4、标准异常基类std-exception"><a href="#8-4、标准异常基类std-exception" class="headerlink" title="8.4、标准异常基类std::exception"></a>8.4、标准异常基类std::exception</h2><p>头文件：   </p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdexcept&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>C++提供了标准异常基类，以及一些标准异常派生类<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE79dc7e0746bf807241a0c16fb37ce99c/38324" alt="image04"></p>
<p>这些都是exception的派生类，当有异常发生时，即使没有显式的throw语句，也会抛出相应的异常，派生类中都会实现虚函数what，用于返回异常的描述信息</p>
<p>示例：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;class Base&#123;    virtual void func() &#123;&#125;&#125;;class Derived : public Base&#123;public:    void Print() &#123;&#125;&#125;;void PrintObj(Base &amp; b)&#123;    try &#123;        Derived &amp; rd &#x3D; dynamic_cast &lt;Derived &amp;&gt;(b);        &#x2F;&#x2F;此转换若不安全，会拋出 bad_cast 异常        rd.Print();    &#125;    catch (bad_cast &amp; e) &#123;        cerr &lt;&lt; e.what() &lt;&lt; endl;    &#125;&#125;int main()&#123;    Base b;    PrintObj(b);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出结果：<br>Bad dynamic_cast!</p>
<p><strong>==自定义异常派生类==</strong></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std; struct MyException : public exception&#123;  const char * what () const throw ()  &#123;    return &quot;C++ Exception&quot;;  &#125;&#125;; int main()&#123;  try  &#123;    throw MyException();  &#125;  catch(exception&amp; e)  &#123;    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出结果：<br>MyException caught<br>C++ Exception</p>
<h1 id="9、类型转换"><a href="#9、类型转换" class="headerlink" title="9、类型转换"></a>9、类型转换</h1><p>C语言中的类型转换包括隐式类型转换、显式类型转换(也称作强制类型转换)，但有些情况下转换操作并不安全，比如可将指针转换成任意类型，编译是正常，而在运行期可能引发无法预估的问题。<br>C++引入了多种可供选择的类型转换方法</p>
<h2 id="9-1、向上转换、向下转换"><a href="#9-1、向上转换、向下转换" class="headerlink" title="9.1、向上转换、向下转换"></a>9.1、向上转换、向下转换</h2><p>具有继承关系的类之间双向转换操作：</p>
<ul>
<li>向上转换，派生类向基类转换；</li>
<li>向下转换，基类向派生类转换；</li>
</ul>
<h2 id="9-2、static-cast"><a href="#9-2、static-cast" class="headerlink" title="9.2、static_cast"></a>9.2、static_cast</h2><ul>
<li><strong>==编译期类型转换检查==</strong>,只做编译阶段检查，不会在运行阶段检查；</li>
<li>操作对象可以是基本类型，也可以是具有继承关系的类；</li>
<li>不支持不具备继承关系的类之间的转换；</li>
<li>普通对象变量(非指针、非引用)只能向上转换；</li>
<li>指针、引用对象变量支持向上、向下转换；参考：<a href="">4.9.6、对象调用成员变量、成员函数的原理</a></li>
<li>虽然指针、引用对象可以向下类型转换，但运行期是不安全的，可能引发不确定行为，比如空指针异常、访问未初始化的地址空间等；</li>
</ul>
<p>**==类似于c语言的显式类型转换==**，但没有显式类型转换那么暴力，不相关的类型之间转换会报错，比如没有继承关系的类之间、指针转整形操作等。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base&#123;    .......&#125;class Dev : public Base&#123;    .......&#125;class NoDev&#123;    .......&#125;int main()&#123;    char ca &#x3D; &#39;a&#39;;    int ia &#x3D; static_cast&lt;int&gt;(ca);  &#x2F;&#x2F; OK    float *pa &#x3D; static_cast&lt;float*&gt;(ca);  &#x2F;&#x2F; error        Base base01;    Dev dev01 &#x3D; static_cast&lt;Dev&gt;(base01);  &#x2F;&#x2F; error，普通对象变量不支持向下转换        Dev dev02;    Base base02 &#x3D; static_cast&lt;Base&gt;(dev02);  &#x2F;&#x2F; OK        Base *pBase &#x3D; new Base();    Dev *pDev &#x3D; new Dev();    pDev &#x3D; static_cast&lt;Dev&gt;(pBase);  &#x2F;&#x2F; OK    pBase &#x3D; static_cast&lt;Base&gt;(pDev);  &#x2F;&#x2F; OK        Base base03;    NoDev no_dev &#x3D; static_cast&lt;NoDev&gt;(base03);  &#x2F;&#x2F; error，Base与NoDev之间不存在继承关系        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="9-3、dynamic-static"><a href="#9-3、dynamic-static" class="headerlink" title="9.3、dynamic_static"></a>9.3、dynamic_static</h2><p>由于static_cast只在编译阶段检查，继承类之间向下类型转换在运行期存在不安全行为，dynamic_static可以执行运行期检查</p>
<ul>
<li>运行期类型转换检查；</li>
<li>只针对类的指针、引用对象，不支持普通对象、基础类型；</li>
<li>可以实现运行期安全的向下类型转换操作；</li>
<li>类指针向下转换失败返回nullptr，类引用向下转换失败返回bad_cast异常;</li>
<li>支持向上转化，但由于向上转换本来就是安全的，考虑到dynamic_static比较耗时，故向上类型转换不建议使用dynamic_static；</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stdafx.h&quot;#include&lt;iostream&gt;using namespace std;class Base&#123;public:    Base()&#123;&#125;;    virtual void Show()&#123;cout&lt;&lt;&quot;This is Base calss&quot;;&#125;&#125;;class Derived:public Base&#123;public:    Derived()&#123;&#125;;    void Show()&#123;cout&lt;&lt;&quot;This is Derived class&quot;;&#125;&#125;;int main()&#123;    &#x2F;&#x2F; ************************类指针    Base* base &#x3D; new Derived();    if(Derived *der&#x3D; dynamic_cast&lt;Derived*&gt;(base))  &#x2F;&#x2F; OK，因为Base指针本来就指向继承类    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der-&gt;Show();        cout&lt;&lt;endl;    &#125;        Base * base1 &#x3D; new Base;    if(Derived *der1 &#x3D; dynamic_cast&lt;Derived*&gt;(base1))  &#x2F;&#x2F; error，向下转换失败    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der1-&gt;Show();    &#125;    else     &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;    delete(base);    delete(base1);        &#x2F;&#x2F; ************************类引用    Derived b ;    Base &amp;base1&#x3D; b;    Derived &amp;der1 &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base1);  &#x2F;&#x2F; OK    Base a ;    Base &amp;base &#x3D; a ;    try&#123;        Derived &amp; der &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base);  &#x2F;&#x2F; error    &#125;    catch(bad_cast)    &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="9-4、reinterpret-cast"><a href="#9-4、reinterpret-cast" class="headerlink" title="9.4、reinterpret_cast"></a>9.4、reinterpret_cast</h2><ul>
<li>只支持指针、引用的类型转换操作；</li>
</ul>
<p>可以将指针、引用转换成不相关的类型，包括基础类型、没有继承关系的类；<br>与C语言最接近的类型转换符，用于强制转换，通常在较低级的程序中使用</p>
<h2 id="9-5、const-cast"><a href="#9-5、const-cast" class="headerlink" title="9.5、const_cast"></a>9.5、const_cast</h2><ul>
<li>增加或修改类型限定符const;</li>
<li>只支持指针、引用的类型转换操作；</li>
<li>只能修改类型限定符，不能更改基础类型，即向上、向下转换，比如Derived *转换成const Base *是不允许的；</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">const Base *base01 &#x3D; new Base();Base *base02 &#x3D; const_cast&lt;Base*&gt;(base01);const Base * const base03 &#x3D; new Base();Base *base04 &#x3D; const_cast&lt;Base*&gt;(base03);Base *base05 &#x3D; new Base();const Base *base06 &#x3D; const_cast&lt;const Base*&gt;(base05);const Detived *dev01 &#x3D; new Derived();Base *base02 &#x3D; const_cast&lt;Base*&gt;(dev01);  &#x2F;&#x2F; error，不允许改变基础类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="10、类型推导"><a href="#10、类型推导" class="headerlink" title="10、类型推导"></a>10、类型推导</h1><p>通常C和C+被称作静态类型语言，因为数据类型必须显示声明，而例如python、javascrip等被称作动态语言，它们的变量可以不指定类型，在编译阶段会自动推导。<br>C++中类型推导主要应用在模板、auto、decltype之中，模板的类型推导是基于auto演变而来，auto用于类型推导，而decltype用于获取类型</p>
<h2 id="10-1、模板类型推导"><a href="#10-1、模板类型推导" class="headerlink" title="10.1、模板类型推导"></a>10.1、模板类型推导</h2><p>模板函数伪代码：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(ParamType para);func(expr);  &#x2F;&#x2F; 以表达式expr创建模板函数实例<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在编译期编译器会通过expr（也可以理解成实参）推导两个型别：</p>
<ul>
<li>模板类型T的型别；</li>
<li>函数形参ParamType（也可以理解错形参）的型别；</li>
</ul>
<p>T与ParamType之间的关系要视具体情况而言，比如：   </p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(const T&amp; para);int x &#x3D; 0;func(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>T被推导为int，ParamType被推导为const int&amp;。<br>我们很自热的认为T的型别与传入的实参expr型别是一样的，其实这一点并不总是成立，T的型别推导不仅仅依赖于expr，还依赖于ParaType，具体可分为以下三种情况讨论：   </p>
<ul>
<li>ParamType具有指针或引用型别，但不是个万能引用；</li>
<li>ParamType是个万能引用；</li>
<li>ParamType既非指针也非引用；</li>
</ul>
<p><font color=red><strong>此三种场景均遵循如下类型推导规则:</strong></font></p>
<ul>
<li>根据实参确定形参的类型；</li>
<li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li>
<li>模式匹配出T及ParamType类型；</li>
</ul>
<h3 id="10-1-1、ParamType是个指针或引用，但不是万能引用"><a href="#10-1-1、ParamType是个指针或引用，但不是万能引用" class="headerlink" title="10.1.1、ParamType是个指针或引用，但不是万能引用"></a>10.1.1、ParamType是个指针或引用，但不是万能引用</h3><p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>func(x)中实参x传递给形参T&amp;，可确定ParamType类型是int &amp;，然后模式匹配结果T为int；</li>
<li>func(cx)中cx是const int，传递给形参T&amp;，func形参的意图是作为实参的引用，此时实参具备const性，即不希望后续操作中其值被修改，而且此时实参是按照引用传递的，那么便可确定ParamType类型是const int &amp;，T类型是const int;</li>
<li>func(rx)推导规则同样；</li>
</ul>
<p><font color=purple>当向引用型别的形参传入const对象时，他们期望该对象保持其不可被修改的属性，这也就是为何向持有T&amp;的型别模板传入const对象是安全的。 </font>   </p>
<p>若将模板中的T&amp;改成cosnt T&amp;，推导结果会略有不同：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(cosnt T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是const int&amp;func(cx);  &#x2F;&#x2F; T是int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于ParamType已经具有const属性，故模式匹配时T不会包含const属性。    </p>
<p>若将T&amp;换成指针T*，推导结果基本相同：  </p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T* para);int x &#x3D; 27;const int *px &#x3D; &amp;x;func(&amp;x);   &#x2F;&#x2F; T是int， para是int*func(px);   &#x2F;&#x2F; T是const int，  para是const int*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-1-2、ParamType是个万能引用"><a href="#10-1-2、ParamType是个万能引用" class="headerlink" title="10.1.2、ParamType是个万能引用"></a>10.1.2、ParamType是个万能引用</h3><p>模板类型推导遵循引用折叠规则，详见<strong>5.6</strong>节</p>
<p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp;&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int&amp;， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(27);  &#x2F;&#x2F; T是int， para是int&amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-1-3、ParamType既非指针也非引用"><a href="#10-1-3、ParamType既非指针也非引用" class="headerlink" title="10.1.3、ParamType既非指针也非引用"></a>10.1.3、ParamType既非指针也非引用</h3><p>当ParamType即非指针也非引用时，它想表达的意图是接收实参的一个副本，也即一个全新对象。ParamType会是一个全新对象这一事实促成了如何从expr推导出T的型别规则：</p>
<ul>
<li>若实参具有引用型别，则形参是想借由实参构造一个全新的对象，故引用型别不被保留，若实参是指针类型，则实参传递的是指针的副本，指针* 会被保留；</li>
<li>由于实参传递给形参是一个副本，故const属性不会被保留；</li>
<li>特例：实参const T *、T const *的const会保留，是因为这里的const修饰的是指针指向的对象，并不是指针自身，所以T *const不会保留const属性；</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参为非指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是int，  para是intfunc(rx);  &#x2F;&#x2F; T是int，  para是int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>即使cx和rx代表const值，para仍然不具有const型别，因为para是个完全独立于cx和rx存在的对象，从而cx和rx的不可修改属性并不会传递给para。       </p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参是指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int *cx &#x3D; &amp;x;int * const cx02 &#x3D; &amp;x;int *rx &#x3D; &amp;x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是const int *，  para是const int *func(cx02);  &#x2F;&#x2F; T是int *，  para是int *func(rx);  &#x2F;&#x2F; T是int *，  para是int *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="10-2、auto类型推导"><a href="#10-2、auto类型推导" class="headerlink" title="10.2、auto类型推导"></a>10.2、auto类型推导</h2><p>auto类型推导表达式在编译时确定变量类型，auto所修饰的变量必须被初始化<br>推导规则与模板类型推导遵循如下规则：</p>
<ul>
<li>根据实参确定形参的类型；</li>
<li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li>
<li>模式匹配出T及ParamType类型；</li>
</ul>
<p>示例：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;auto *a &#x3D; &amp;x;  &#x2F;&#x2F;a-&gt;int *auto b &#x3D; &amp;x;   &#x2F;&#x2F;b-&gt;int *auto &amp;c&#x3D; x;    &#x2F;&#x2F;c-&gt;int &amp;auto d&#x3D;c;      &#x2F;&#x2F;d-&gt;intconst auto e &#x3D; x;  &#x2F;&#x2F;e-&gt;const intauto f &#x3D; e;        &#x2F;&#x2F;f-&gt;intconst auto&amp;g &#x3D; x;  &#x2F;&#x2F;g-&gt;const int &amp;auto&amp; h &#x3D; g;   &#x2F;&#x2F;h-&gt;const int&amp; const int *j &#x3D; &amp;x;auto k &#x3D; j;  &#x2F;&#x2F; k-&gt;const int *int *const m &#x3D; &amp;x;auto n &#x3D; m;  &#x2F;&#x2F; n-&gt;int *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color=red><strong>特殊示例:</strong></font>  </p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto x &#x3D; 5;   &#x2F;&#x2F; intauto pi &#x3D; new auto(1);  &#x2F;&#x2F;int *const auto *v&#x3D;&amp;x, u &#x3D; 6;  &#x2F;&#x2F;v是const int*, u是const intstatic auto y &#x3D; 0.0;  &#x2F;&#x2F;doubleauto yt&#123;1&#125;;  &#x2F;&#x2F;使用初始化列表的auto，auto被推导出初始化列表容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当经过v推导出auto为int之后，u仍然需要显示指定为6，以防在经过u推导时，auto出现二义性，比如u=6.0，编译器就会报错。<br>auto不能代表一个实际的类型声明，而是一个类型的占位符，在编译期间替换为真正的类型，使用auto必须马上初始化。</p>
<p>数组形式的大括号初始化auto推导，详见<strong>10.3.3</strong>节</p>
<h3 id="10-2-1、auto的限制"><a href="#10-2-1、auto的限制" class="headerlink" title="10.2.1、auto的限制"></a>10.2.1、auto的限制</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;void func(auto a &#x3D; 1);  &#x2F;&#x2F;error:auto不能用于函数参数struct Foo&#123;	auto var1_ &#x3D; 0;  &#x2F;&#x2F;error:auto不能用于非静态成员变量	static const auto var2_ &#x3D; 0;&#125;;template &lt;typename T&gt;struct Bar &#123;&#125;;int main(void)&#123;	int arr[10] &#x3D; &#123;0&#125;;	auto aa &#x3D; arr;  &#x2F;&#x2F;OK: aa -&gt; int *，数组名arr退化成指针	auto rr[10] &#x3D; arr;  &#x2F;&#x2F;error:auto无法定义数组	Bar&lt;int&gt; bar;	Bar&lt;auto&gt; bb &#x3D; bar;  &#x2F;&#x2F;error:auto无法推导出模板参数	system(&quot;pause&quot;);	return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>auto不能用于函数参数的类型推导，即使有默认值也不行；</li>
<li>auto不能用于非静态成员变量的类型推导（仅针对于结构体和类中的成员，即使有默认值也不行），同时仅能用于推导static const的整型或枚举成员；</li>
<li>auto不能用于数组类型推导；</li>
<li>auto不能用于模板参数类型推导；</li>
</ul>
<h2 id="10-3、decltype"><a href="#10-3、decltype" class="headerlink" title="10.3、decltype"></a>10.3、decltype</h2><p>auto声明的变量必须要初始化，而有时我们仅仅只是想知道表达式的类型，可以使用decltype来实现，它的推导过程也是在编译期完成。   </p>
<p>decltype获取数据类型的规则通常是所见即所得，但也有例外，特殊情况包括const限定符、函数返回值类型、重载函数、标记符表达式等，详见<strong>10.3.2</strong>节</p>
<h3 id="10-3-1、示例"><a href="#10-3-1、示例" class="headerlink" title="10.3.1、示例"></a>10.3.1、示例</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;decltype(x) y&#x3D;1;   &#x2F;&#x2F;y-&gt;intdecltype(x + y) z&#x3D;1;   &#x2F;&#x2F;z-&gt;intconst int &amp;i &#x3D; x;decltype(i) j&#x3D;y;   &#x2F;&#x2F;j-&gt;const int&amp;const int* k &#x3D; &amp;x;decltype(k) p &#x3D; 20;   &#x2F;&#x2F;p-&gt;const int *int * const m &#x3D; &amp;x;decltype(m) n &#x3D; 30;   &#x2F;&#x2F;p-&gt;int *constint func_int(void);decltype(func_int) f_01;  &#x2F;&#x2F; f_01-&gt;int (*)(void)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-3-2、特例"><a href="#10-3-2、特例" class="headerlink" title="10.3.2、特例"></a>10.3.2、特例</h3><h4 id="1、decltype与函数返回值"><a href="#1、decltype与函数返回值" class="headerlink" title="1、decltype与函数返回值"></a>1、decltype与函数返回值</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int value &#x3D; 20;const int func_int(void);const int * func_int_ptr_01(void);int * const func_int_ptr_02(void);decltype(func_int()) f&#x3D;0;   &#x2F;&#x2F;f-&gt;intdecltype(func_int_ptr_01()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;const int*decltype(func_int_ptr_02()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;int*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>函数返回值的const传递性规则与auto、模板参数类型推导规则一样，需要考虑是按值传递还是按地址传递。函数返回值换成引用类型，规则同样适用</p>
<h4 id="2、decltype与重载函数"><a href="#2、decltype与重载函数" class="headerlink" title="2、decltype与重载函数"></a>2、decltype与重载函数</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int func_int(void);int func_int(int value)decltype(func_int) f_01;  &#x2F;&#x2F; error，由于func_int是重载函数，decltype无法知晓需要获取哪一个函数的类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="3、decltype与多重指针符号、引用符号、const"><a href="#3、decltype与多重指针符号、引用符号、const" class="headerlink" title="3、decltype与多重指针符号、引用符号、const"></a>3、decltype与多重指针符号、引用符号、const</h4><pre class="line-numbers language-none"><code class="language-none">#include ＜type_traits＞#include ＜iostream＞using namespace std;int i&#x3D;1;int＆j&#x3D;i;int*p&#x3D;＆i;const int k&#x3D;1;int main()&#123;decltype(i)＆var1&#x3D;i;  &#x2F;&#x2F; var1-&gt;int &amp;decltype(j)＆var2&#x3D;i;  &#x2F;&#x2F;多余的＆被忽略, var2-&gt;int &amp;cout＜＜is_lvalue_reference＜decltype(var1)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用cout＜＜is_rvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;0,不是右值引用cout＜＜is_lvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用decltype(p)*var3&#x3D;＆i;  &#x2F;&#x2F;无法通过编译,var3的类型是int**decltype(p)*var3&#x3D;＆p;  &#x2F;&#x2F;var3的类型是int**auto*v3&#x3D;p;&#x2F;&#x2F;v3的类型是int*v3&#x3D;＆i;const decltype(k)var4&#x3D;1;&#x2F;&#x2F;冗余的const被忽略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>表达式中多余的引用符号、const会被忽略，而指针符号会被保留</p>
<h4 id="4、decltype与标记符表达式"><a href="#4、decltype与标记符表达式" class="headerlink" title="4、decltype与标记符表达式"></a>4、decltype与标记符表达式</h4><p>绝大多数时刻decltype都是平易近人的，但有时候也会让人疑惑，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">int i;decltype(i)a;&#x2F;&#x2F;a:intdecltype((i))b;&#x2F;&#x2F;b:int＆,无法编译通过<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这是因为decltype具有以下四规则，不过需要先了解什么是<strong>标记符表达式</strong>：<br>基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier） 。 而单个标记符对应的表达式就是标记符表达式。比如程序员定义了：</p>
<pre class="line-numbers language-none"><code class="language-none">int arr[4];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那么arr是一个标记符表达式， 而arr[3]+0,arr[3]等， 则都不是标记符表达式。   </p>
<ul>
<li><strong>规则一</strong>：如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。 此外， <strong>如果e是一个被重载的函数</strong>， 则会导致编译时错误；</li>
<li><strong>规则二</strong>：否则， 假设e的类型是T， 如果e是一个将亡值(xvalue)， 那么decltype(e)为T＆＆；</li>
<li><strong>规则三</strong>：否则， 假设e的类型是T， 如果e是一个左值， 则decltype(e)为T＆；</li>
<li><strong>规则四</strong>：否则， 假设e的类型是T， 则decltype(e)为T；</li>
</ul>
<p>这样便可解释上面的int i例子，由于(i)不是一个标记符表达式，而却是一个左值表达式（可以有具名的地址） ， 因此， 按照decltype推导规则3， 其类型应该是一个int的引用，所以b必须同时初始化。</p>
<pre class="line-numbers language-none"><code class="language-none">int i&#x3D;4;int arr[5]&#x3D;&#123;0&#125;;int*ptr&#x3D;arr;struct S&#123;double d;&#125;s;void Overloaded(int);void Overloaded(char);&#x2F;&#x2F;重载的函数int＆＆RvalRef();const bool Func(int);&#x2F;&#x2F;规则1:单个标记符表达式以及访问类成员， 推导为本类型decltype(arr)var1;&#x2F;&#x2F;int[5],标记符表达式decltype(ptr)var2;&#x2F;&#x2F;int*,标记符表达式decltype(s.d)var4;&#x2F;&#x2F;double,成员访问表达式decltype(Overloaded)var5;&#x2F;&#x2F;无法通过编译， 是个重载的函数&#x2F;&#x2F;规则2:将亡值， 推导为类型的右值引用decltype(RvalRef())var6&#x3D;1;&#x2F;&#x2F;int＆＆&#x2F;&#x2F;规则3:左值， 推导为类型的引用decltype(true?i:i)var7&#x3D;i;&#x2F;&#x2F;int＆,三元运算符， 这里返回一个i的左值decltype((i))var8&#x3D;i;&#x2F;&#x2F;int＆,带圆括号的左值decltype(++i)var9&#x3D;i;&#x2F;&#x2F;int＆,++i返回i的左值decltype(arr[3])var10&#x3D;i;&#x2F;&#x2F;int＆[]操作返回左值decltype(*ptr)var11&#x3D;i;&#x2F;&#x2F;int＆*操作返回左值decltype(&quot;lval&quot;)var12&#x3D;&quot;lval&quot;;&#x2F;&#x2F;const char(＆)[9],字符串字面常量为左值&#x2F;&#x2F;规则4： 以上都不是， 推导为本类型decltype(1)var13;&#x2F;&#x2F;int,除字符串外字面常量为右值decltype(i++)var14;&#x2F;&#x2F;int,i++返回右值decltype((Func(1)))var15;&#x2F;&#x2F;const bool,圆括号可以忽略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>此处顺便可以理解，前置++ 与后置++的区别，前置++是一个左值，后置++是一个表达式，需要返回一个临时值</p>
<h2 id="10-4、数组与类型推导"><a href="#10-4、数组与类型推导" class="headerlink" title="10.4、数组与类型推导"></a>10.4、数组与类型推导</h2><h3 id="10-4-1、数组常规推导"><a href="#10-4-1、数组常规推导" class="headerlink" title="10.4.1、数组常规推导"></a>10.4.1、数组常规推导</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T param);const char name[13] &#x3D; &quot;abcddftg&quot;;func(name);  &#x2F;&#x2F; T是const char *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>T被推导成const char *而不是const char [13]，因为：</p>
<ul>
<li>数组到指针的退化规则，name的const char [13]退化成了const char *；</li>
<li>也可以理解成函数无法声明真正意义上的数组形参；    </li>
</ul>
<h3 id="10-4-2、数组引用类型推导"><a href="#10-4-2、数组引用类型推导" class="headerlink" title="10.4.2、数组引用类型推导"></a>10.4.2、数组引用类型推导</h3><p><strong>难点来了</strong>：<br>虽然函数无法声明真正意义上的数组形参，但却可以将形参声明成数组的引用</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(T&amp; param);const char name[13] &#x3D; &quot;abcddftg&quot;;f(name);  &#x2F;&#x2F; T是const char [13], param是const char (&amp;)[13]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里需要注意参考2.7.1的情形，此时ParamType是个引用类型，传入的是个数组const char [13]，这里的const性便得以保留。    </p>
<p><strong>实际应用</strong>：<br>可以利用这个功能创造出一个模板，用来推导出数组含有的元素数：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以编译期常量的形式返回数组尺寸template&lt;typename T, std::size_t N&gt;constpxer std::size_t arraySize(T (&amp;)[N]) nonexcept&#123;    return N;&#125;int keyVals[] &#x3D; &#123;1,3,7,9&#125;;int mappedVals[arraySize(keyVals)];  &#x2F;&#x2F; mappedVals被指定为与keyVals一样大小的数组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-4-3、数组初始化形式作为实参的类型推导"><a href="#10-4-3、数组初始化形式作为实参的类型推导" class="headerlink" title="10.4.3、数组初始化形式作为实参的类型推导"></a>10.4.3、数组初始化形式作为实参的类型推导</h3><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;int x(27);int x &#x3D; &#123;27&#125;;int x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以上是四种初始表达式，都可以将x初始化为27，但在以初始化形式发生auto类型推导时情况略有不同：</p>
<pre class="line-numbers language-none"><code class="language-none">auto x &#x3D; 27;auto x(27);auto x &#x3D; &#123;27&#125;;auto x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>前两个没有问题，可以正常初始化x为int，值为27，但后两个会将x初始化为std::initializer_list<int>类型，且包含单个值27<br>，这是因为在auto推导时会将大括号推导为std::initializer_list<int>类型，而模板推导中就会失败，因为模板不支持这种推导形式：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T name);func(&#123;1,2,3&#125;);  &#x2F;&#x2F; 错误，无法推导T的型别<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>不过，若指定该模板中param为std::initializer_list<T>类型，则可以推导出T的型别：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; name);f(&#123;1,2,3&#125;);  &#x2F;&#x2F; T被推导为int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="11、std-string类"><a href="#11、std-string类" class="headerlink" title="11、std::string类"></a>11、std::string类</h1><p>传统字符数组的缺点：</p>
<ul>
<li>普通字符数组的长度在编译期已固定，不可更改；</li>
<li>动态申请的字符数组虽然可以按需分配空间，但当扩容时内存空间需要销毁重建；</li>
<li>char *在浅复制时易出现内存泄漏、double free等问题；</li>
</ul>
<h2 id="11-1、初始化"><a href="#11-1、初始化" class="headerlink" title="11.1、初始化"></a>11.1、初始化</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    &#x2F;&#x2F; char * To std::string    const char * c_string &#x3D; &quot;Hello world!&quot;;    std::string str01 &#x3D; &quot;Hello world!&quot;;  &#x2F;&#x2F; copy constructor    std::string str02 &#x3D; c_string;  &#x2F;&#x2F; copy constructor    std::string str03(c_string);  &#x2F;&#x2F; default constructor    std::string str04;    str04 &#x3D; c_string;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n01: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str01 &lt;&lt; &quot;\n&quot; &lt;&lt; str02 &lt;&lt; &quot;\n&quot; &lt;&lt; str03  &lt;&lt; &quot;\n&quot; &lt;&lt; str04 &lt;&lt; std::endl;    &#x2F;&#x2F; std::string To std::string    std::string str_str &#x3D; &quot;Everything is OK!&quot;;    std::string str05 &#x3D; str_str;  &#x2F;&#x2F; copy constructor    std::string str06(str05);  &#x2F;&#x2F; defalut constructor    std::string str07;    str07 &#x3D; str_str;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n02: &quot; &lt;&lt; str_str &lt;&lt; &quot;\n&quot; &lt;&lt; str05 &lt;&lt; &quot;\n&quot; &lt;&lt; str06 &lt;&lt; &quot;\n&quot; &lt;&lt; str07 &lt;&lt; std::endl;    &#x2F;&#x2F; member function    &#x2F;&#x2F; function: *_copy_*(source, begin_pos, len)， 指定位置开始复制    std::string str08(c_string,2,10);  &#x2F;&#x2F; str08 &#x3D; &quot;llo world!&quot;&quot;    std::string str09(c_string,2);  &#x2F;&#x2F; str09 &#x3D; &quot;He&quot; copy len &#x3D; 2 from begin pos    std::string str10(str_str,2,15);  &#x2F;&#x2F; str10 &#x3D; &quot;erything is OK!&quot;&quot;    std::string str11(str_str,2);  &#x2F;&#x2F; str11 &#x3D; &quot;erything is OK!&quot; copy from 2th pos to end pos    std::cout &lt;&lt; &quot;\n03: &quot; &lt;&lt; str08 &lt;&lt; &quot;\n&quot; &lt;&lt; str09 &lt;&lt; &quot;\n&quot; &lt;&lt; str10 &lt;&lt; &quot;\n&quot; &lt;&lt; str11 &lt;&lt; std::endl;    &#x2F;&#x2F; function: *_copy_*(begin_pos, end_pos), 区间复制    std::string str12(c_string + 2, c_string + 8);  &#x2F;&#x2F; str12 &#x3D; &quot;llo wo&quot;    std::string str13(c_string + 2);  &#x2F;&#x2F; str13 &#x3D; &quot;llo world!&quot;    std::cout &lt;&lt; &quot;\n04: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str12 &lt;&lt; &quot;\n&quot; &lt;&lt; str13 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Hello world!Hello world!Hello world!Hello world!Hello world!02: Everything is OK!Everything is OK!Everything is OK!Everything is OK!03: llo world!Heerything is OK!erything is OK!04: Hello world!llo wollo world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-2、访问"><a href="#11-2、访问" class="headerlink" title="11.2、访问"></a>11.2、访问</h2><ul>
<li>类数组下标形式访问；</li>
<li>C风格指针形式访问；</li>
<li>迭代器形式访问</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    &#x2F;&#x2F; 数组下标形式    for (int32_t i &#x3D; 0; i &lt; str_str.length(); ++i) &#123;        std::cout &lt;&lt; str_str[i];    &#125;        &#x2F;&#x2F; C风格指针    const char *c_string &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\n\n&quot; &lt;&lt; c_string &lt;&lt; std::endl;    &#x2F;&#x2F; 迭代器    std::cout &lt;&lt; &quot;\n&quot;;    for (auto iter &#x3D; str_str.begin(); iter !&#x3D; str_str.end(); ++iter) &#123;        std::cout &lt;&lt; *iter;    &#125;    std::cout &lt;&lt; &quot;\n&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-3、拼接"><a href="#11-3、拼接" class="headerlink" title="11.3、拼接"></a>11.3、拼接</h2><ul>
<li>拼接符：+=、+</li>
<li>appen函数</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str01 &#x3D; &quot;Hello&quot;;    std::string str_str02 &#x3D; &quot; world!&quot;;    std::string str_str03 &#x3D; str_str01 + str_str02;    std::string str_str04 &#x3D; str_str01.append(str_str02);    std::string str_str05 &#x3D; &quot;Everybody, &quot; + str_str03;    std::cout &lt;&lt; str_str03 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str04 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str05 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-4、查找"><a href="#11-4、查找" class="headerlink" title="11.4、查找"></a>11.4、查找</h2><p>查找相关的函数：</p>
<ul>
<li>find</li>
<li>find_first_of</li>
<li>find_first_not_of</li>
<li>find_last_of</li>
<li>find_last_not_of</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;every body is everybody&quot;;    std::string str_obj &#x3D; &quot;everybody&quot;;    size_t pos01 &#x3D; str_str.find(str_obj, 2);    size_t pos02 &#x3D; str_str.find(str_obj);    size_t pos03 &#x3D; str_str.find_first_of(str_obj, 2);    size_t pos04 &#x3D; str_str.find_first_of(str_obj);    size_t pos05 &#x3D; str_str.find_first_not_of(str_obj);    size_t pos06 &#x3D; str_str.find_last_of(str_obj);    size_t pos07 &#x3D; str_str.find_last_of(str_obj, 2);    size_t pos08 &#x3D; str_str.find_last_not_of(str_obj);    std::cout &lt;&lt; pos01 &lt;&lt; &quot;  &quot; &lt;&lt; pos02 &lt;&lt; &quot;  &quot;  &lt;&lt; pos03 &lt;&lt; &quot;  &quot;  &lt;&lt; pos04 &lt;&lt; &quot;  &quot;     &lt;&lt; pos05 &lt;&lt; &quot;  &quot;  &lt;&lt; pos06 &lt;&lt; &quot;  &quot;  &lt;&lt; pos07 &lt;&lt; &quot;  &quot;  &lt;&lt; pos08 &lt;&lt; std::endl;        &#x2F;&#x2F; 迭代器    auto iter &#x3D; find(str_str.begin(), str_str.end(), &#39;e&#39;);  &#x2F;&#x2F; 第三个参数如果是std::string类型会报错，因为str_str的iteration是字符，字符与字符串是无法match    if (iter !&#x3D; str_str.end()) &#123;        std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;Has been found&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">14  14  2  0  5  22  2  13Has been found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>find_first_of/find_last_of查找规则是如果str_str中含有str_obj中的任何字符，则就会查找成功，而find则是要完全匹配；</p>
<h2 id="11-5、截短"><a href="#11-5、截短" class="headerlink" title="11.5、截短"></a>11.5、截短</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    str_str.erase(3, 7);  &#x2F;&#x2F; 从第3位开始删除7个字符，遇到字符串结尾结束    std::cout &lt;&lt; &quot;01: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    str_str.erase(2);  &#x2F;&#x2F; 遇到字符串结尾结束    std::cout &lt;&lt; &quot;02: &quot; &lt;&lt; str_str &lt;&lt; std::endl;        str_str.erase(str_str.begin(), str_str.end());    std::cout &lt;&lt; &quot;03: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#x2F;&#x2F; 删除指定字符    str_str &#x3D; &quot;Hello world!&quot;;    size_t pos &#x3D; str_str.find(&#39;H&#39;);    if (pos !&#x3D; str_str.npos) &#123;        str_str.erase(pos, 1);        std::cout &lt;&lt; &quot;04: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    auto iter &#x3D; std::find(str_str.begin(), str_str.end(), &#39;w&#39;);    if (iter !&#x3D; str_str.end()) &#123;        str_str.erase(iter);        std::cout &lt;&lt; &quot;05: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Held!02: He03:04: ello world!05: ello orld!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-6、获取子字符串std-substr"><a href="#11-6、获取子字符串std-substr" class="headerlink" title="11.6、获取子字符串std::substr"></a>11.6、获取子字符串std::substr</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string targt &#x3D; &quot;Hello,world!&quot;;        int nComma &#x3D; targt.find(&#39;,&#39;);    if (nComma !&#x3D; std::string::npos)    &#123;    	std::string keywordSegmt_1 &#x3D; targt.substr(0, nComma);    	std::cout &lt;&lt; &quot;test 1  &quot; &lt;&lt; keywordSegmt_1 &lt;&lt; std::endl;        	std::string keywordSegmt_2 &#x3D; targt.substr(nComma + 1, targt.length() - 1 - nComma);    	std::cout &lt;&lt; &quot;test 2  &quot; &lt;&lt; keywordSegmt_2 &lt;&lt; std::endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">test 1  Hellotest 2  world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-7、翻转std-reverse"><a href="#11-7、翻转std-reverse" class="headerlink" title="11.7、翻转std::reverse"></a>11.7、翻转std::reverse</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;int main()&#123;    using namespace std;    string strSample (&quot;Hello String!&quot;);    cout &lt;&lt; &quot;The original sample string is: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl &lt;&lt; endl;     reverse (strSample.begin (), strSample.end ());     cout &lt;&lt; &quot;After applying the std::reverse algorithm: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl;     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">The original sample string is: Hello String!After applying the std::reverse algorithm: !gnirtS olleH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-8、大小写转换transform、toupper、tolower"><a href="#11-8、大小写转换transform、toupper、tolower" class="headerlink" title="11.8、大小写转换transform、toupper、tolower"></a>11.8、大小写转换transform、toupper、tolower</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;cctype&gt;#include &lt;algorithm&gt;int main ()&#123;    std::string strInput &#x3D; &quot;Hello world!&quot;;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::toupper);  &#x2F;&#x2F; ::toupper为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to upper case is: &quot; &lt;&lt;std:: endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::tolower);  &#x2F;&#x2F; ::tolower为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to lower case is: &quot; &lt;&lt; std::endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">The string converted to upper case is: HELLO WORLD!The string converted to lower case is: hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-9、字符串与其他类型转换"><a href="#11-9、字符串与其他类型转换" class="headerlink" title="11.9、字符串与其他类型转换"></a>11.9、字符串与其他类型转换</h2><h3 id="11-9-1、实数转字符串"><a href="#11-9-1、实数转字符串" class="headerlink" title="11.9.1、实数转字符串"></a>11.9.1、实数转字符串</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 普通字符串std::string to_string(int);std::string to_string(long);std::string to_string(long long);std::string to_string(unsigned);std::string to_string(unsigned long);std::string to_string(unsigned long long);std::string to_string(float);std::string to_string(double);std::string to_string(long double);&#x2F;&#x2F; 宽字符串std::wstring to_wstring(int);std::wstring to_wstring(long);std::wstring to_wstring(long long);std::wstring to_wstring(unsigned);std::wstring to_wstring(unsigned long);std::wstring to_wstring(unsigned long long);std::wstring to_wstring(float);std::wstring to_wstring(double);std::wstring to_wstring(long double);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也可以使用C函数snprintf</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int snprintf(char *str, size_t size, const char *format, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main ()&#123;    int32_t int_str &#x3D; 123456;    char c_string[20];    snprintf(c_string, 20 - 1, &quot;%09d&quot;, int_str);    std::cout &lt;&lt; &quot;string is: &quot; &lt;&lt; c_string &lt;&lt; &quot;\nint string is: &quot; &lt;&lt; int_str &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">string is: 000123456int string is: 123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将int_str按照format格式转化成字符串，可以指定字符串的长度为9，不足的部分使用字符’0’填充，末尾自动添加\0，然后将转换结果放入c-string之中，成功则返回写入的字符串长度，失败返回负值</p>
<h3 id="11-9-2、字符串转实数"><a href="#11-9-2、字符串转实数" class="headerlink" title="11.9.2、字符串转实数"></a>11.9.2、字符串转实数</h3><pre class="line-numbers language-none"><code class="language-none">int std::atoi(const char*);long std::atol(const char*);long long std::atoll(const char*);float std::atof(const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果需要转换的字符串起始部分不是数字，返回0，如果是空格，会被忽略掉。</p>
<pre class="line-numbers language-none"><code class="language-none">long int strtol(const char* nptr, char **endptr, int base);long long int strtoll(const char* nptr, char **endptr, int base);unsigned long int strtoul(const char* nptr, char **endptr, int base);unsigned long long int strtoull(const char* nptr, char **endptr, int base);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>将参数nptr按照base的格式转化成整形<br>base是0-36，代表进制，函数会扫描参数nptr，跳过前面的空格字符串，直到遇上数字或正负符号才开始转换(如果是不合法字符，直接退出)，再遇到非数字或字符串结束符停止转换，若endptr不为NULL，则会将遇到的不符合条件而终止的nptr中的字符指针返回。<br>如果base=0，则根据字符串起始部分是0还是0x来判断转换成8进制还是16进制，如果都不是默认转换成10进制</p>
<pre class="line-numbers language-none"><code class="language-none">using namespace std;int main()&#123;    char *endptr;    char nptr[]&#x3D;&quot;123abc&quot;;    int ret &#x3D; strtol(nptr, &amp;endptr, 10 );    cout &lt;&lt; &quot;*****01*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr &#x3D; &quot;&lt;&lt;endptr&lt;&lt;endl;    char *endptr2;    char nptr2[]&#x3D;&quot; \t    abc&quot;;    ret &#x3D; strtol(nptr2, &amp;endptr2, 10 );     cout &lt;&lt; &quot;\n*****02*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr2 &#x3D; &quot;&lt;&lt;endptr2&lt;&lt;endl;    char *endptr8;    char nptr8[]&#x3D;&quot;0123&quot;;    ret &#x3D; strtol(nptr8, &amp;endptr8,0);     cout &lt;&lt; &quot;\n*****03*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr8 &#x3D; &quot;&lt;&lt;endptr8&lt;&lt;endl;       char *endptr16;    char nptr16[]&#x3D;&quot;0x123&quot;;    ret &#x3D; strtol(nptr16, &amp;endptr16,0);     cout &lt;&lt; &quot;\n*****04*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr16 &#x3D; &quot;&lt;&lt;endptr16&lt;&lt;endl;       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出结果</p>
<pre class="line-numbers language-none"><code class="language-none">*****01*****ret &#x3D; 123endptr &#x3D; abc*****02*****ret &#x3D; 0endptr2 &#x3D;  	    abc*****03*****ret &#x3D; 83endptr8 &#x3D; *****04*****ret &#x3D; 291endptr16 &#x3D; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="11-9-3、stringstream类"><a href="#11-9-3、stringstream类" class="headerlink" title="11.9.3、stringstream类"></a>11.9.3、stringstream类</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sstream&gt;using namespace std;int main()&#123;   int32_t int_input &#x3D; 6789;   stringstream converterStream01;   converterStream01 &lt;&lt; int_input;    string str_output;   converterStream01 &gt;&gt; str_output;   cout &lt;&lt; &quot;Integer Input &#x3D; &quot; &lt;&lt; int_input &lt;&lt; endl;   cout &lt;&lt; &quot;String gained from integer, strInput &#x3D; &quot; &lt;&lt; str_output &lt;&lt; endl;   std::string str_input &#x3D; str_output;   stringstream converterStream02;   converterStream02 &lt;&lt; str_input;   int32_t Copy &#x3D; 0;   converterStream02 &gt;&gt; Copy;   cout &lt;&lt; &quot;Integer gained from string, Copy &#x3D; &quot; &lt;&lt; Copy + 1 &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">Integer Input &#x3D; 6789String gained from integer, strInput &#x3D; 6789Integer gained from string, Copy &#x3D; 6790<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-10、string转C风格字符串"><a href="#11-10、string转C风格字符串" class="headerlink" title="11.10、string转C风格字符串"></a>11.10、string转C风格字符串</h2><ul>
<li>data()返回char *指针，指向std::string对象内存放数组的内存空间；</li>
<li>c_str()返回const char *指针，指向std::string对象内存放数组的内存空间；</li>
<li>copy()将std::string内容复制至指定字符数组内；</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; copy函数原型copy(_CharT* __s, size_type __n, size_type __pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;memory.h&gt;int main()&#123;    std::string str_str &#x3D; &quot;hello&quot;;    char *ptr01;    ptr01 &#x3D; str_str.data();    std::cout &lt;&lt; &quot;execute function data: &quot; &lt;&lt; ptr01 &lt;&lt; std::endl;    const char *ptr02 &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\nexecute function c_str: &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    char array[6];    memset(array, 0, sizeof(array));    str_str.copy(array, 3, 2);    std::cout &lt;&lt; &quot;\nexecute function copy: &quot; &lt;&lt; array &lt;&lt; std::endl;    &#x2F;&#x2F; modify std::string    str_str &#x3D; &quot;Hello world!&quot;;    std::cout &lt;&lt; &quot;\nafter modify:\nptr01 &#x3D; &quot; &lt;&lt; ptr01 &lt;&lt; &quot;\nptr02 &#x3D; &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">execute function data: helloexecute function c_str: helloexecute function copy: lloafter modify:ptr01 &#x3D; Hello world!ptr02 &#x3D; Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-11、其他常用函数"><a href="#11-11、其他常用函数" class="headerlink" title="11.11、其他常用函数"></a>11.11、其他常用函数</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int compare(string);  &#x2F;&#x2F; string比较，相同返回0int capacity() const;  &#x2F;&#x2F;返回string容量，已分配的内存空间int max_size()const;  &#x2F;&#x2F;返回string对象可存放的最大字符串长度，通常是个很大的数int size()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间int length()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间bool empty()const;  &#x2F;&#x2F;当前字符串是否为空void resize(int len, char c)const;&#x2F;&#x2F;把当前字符串大小设置为len，并用字符c填充不足的部分<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;hello world!&quot;;    std::cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; str_str.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nmax_size &#x3D; &quot; &lt;&lt; str_str.max_size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nsize &#x3D; &quot; &lt;&lt; str_str.size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nlength &#x3D; &quot; &lt;&lt; str_str.length() &lt;&lt; std::endl;    str_str.resize(15, &#39;B&#39;);    std::cout &lt;&lt; &quot;\nresize &#x3D; &quot; &lt;&lt; str_str &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-12、C风格字符串"><a href="#11-12、C风格字符串" class="headerlink" title="11.12、C风格字符串"></a>11.12、C风格字符串</h2><h3 id="11-12-1、strcmp的实现"><a href="#11-12-1、strcmp的实现" class="headerlink" title="11.12.1、strcmp的实现"></a>11.12.1、strcmp的实现</h3><pre class="line-numbers language-none"><code class="language-none">int mystrcmp(const char *str1, const char *str2)&#123;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39; &amp;&amp; *str1 &#x3D;&#x3D; *str2)    &#123;        str1++;        str2++;    &#125;        if(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 &#x3D;&#x3D; &#39;\0&#39;)    return 1;    else if(*str1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;)    return -1;    else if(*str1 &gt; *str2)    return 1;    else if (*str1 &lt; *str2)    return -1;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="11-12-2、strcpy的实现"><a href="#11-12-2、strcpy的实现" class="headerlink" title="11.12.2、strcpy的实现"></a>11.12.2、strcpy的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrcpy(char *str1, const char *str2)&#123;    char *p &#x3D; str1;    if(p &#x3D;&#x3D; NULL || str2 &#x3D;&#x3D; NULL)    &#123;         printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str2 !&#x3D; &#39;\0&#39;)    &#123;        *p &#x3D; *str2;        p++;        str2++;    &#125;    *p &#x3D; &#39;\0&#39;;    return str1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="11-12-3、strstr的实现"><a href="#11-12-3、strstr的实现" class="headerlink" title="11.12.3、strstr的实现"></a>11.12.3、strstr的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrstr(const char *str1, const char *str2)&#123;    char *src, char *sub;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;    while(*str1 !&#x3D; &#39;\0&#39;)    &#123;        src &#x3D; str1;        sub &#x3D; str2;                do        &#123;            if(*sub &#x3D;&#x3D; &#39;\0&#39;)            &#123;                return str1;            &#125;        &#125;while(*src ++ &#x3D;&#x3D; *sub++);                str1++    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="11-、字符、字符串相关函数"><a href="#11-、字符、字符串相关函数" class="headerlink" title="11.*、字符、字符串相关函数"></a>11.*、字符、字符串相关函数</h2><ul>
<li>字母（不区分大小写）：isalpha();</li>
<li>大写字母：isupper();</li>
<li>小写字母：islower();</li>
<li>数字：isdigit();</li>
<li>字母和数字：isalnum();</li>
<li>转化为大写：toupper();</li>
<li>转化为小写：tolower();</li>
</ul>
<h1 id="12、lambda表达式"><a href="#12、lambda表达式" class="headerlink" title="12、lambda表达式"></a>12、lambda表达式</h1><p>语法结构：   </p>
<pre class="line-numbers language-none"><code class="language-none">[capturer]   (params) mutable-&gt;ret   &#123;body;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>capturer是捕获列表</strong>:[]是lambda引出符,编译器根据该引出符判断接下来的代码是lambda表达式；    </li>
<li><strong>params是参数列表</strong>:如果不需要参数传递，则可以连同括号()一起省略；   </li>
<li><strong>mutable是修饰符</strong>：默认情况下，lambda总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略；   </li>
<li><strong>ret是返回类型</strong>：不需要返回值的时候也可以连同符号-＞一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导；    </li>
<li><strong>body是函数体</strong>；    </li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto f &#x3D; []  (int a) -&gt;int &#123;return a+1;&#125;std::cout&lt;&lt;f(1)&lt;&lt;endl;   &#x2F;&#x2F;输出2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>lambda的捕获列表</strong>：    </p>
<ul>
<li>[]不捕获任何变量；</li>
<li>[&amp;]捕获外部作用域所有变量，并作为引用在函数体中使用；</li>
<li>[=]捕获外部作用域所有变量，并作为副本在函数体中使用；</li>
<li>[=,&amp;foo]按值捕获外部作用域所有变量，但按引用捕获foo变量；</li>
<li>[bar]按值捕获bar变量；</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限；</li>
</ul>
<p><strong>通用语法</strong>：    </p>
<ul>
<li>必须以方括号[]打头，这个方括号告诉编译器接下来是一个lambda表达式。方括号后面是一个参数列表及函数表达式。[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li>
<li>stateVar1,stateVar2为状态变量，param1，param2为参数列表；   </li>
<li>如果要在表达式中修改状态变量，需要添加关键字mutable或捕获左值形式:<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) mutable {lambda表达式}；   </li>
<li>使用mutable修改状态变量，在离开lambda之后将无效，若要使之有效需使用引用:<br>[&amp;stateVar1,&amp;stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li>
<li>向编译器指明返回类型：<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) -&gt;returnType {lambda表达式}；</li>
</ul>
<p><font color=red><strong>[]只能捕获父作用域的变量；lambda可以直接使用全局变量，不需要额外捕获</strong></font></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;class A&#123;	int i_ &#x3D; 0;	void func(int x, int y)	&#123;		auto x1 &#x3D; []&#123;return i_; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量		auto x2 &#x3D; [&#x3D;]&#123;return i_ + x + y; &#125;;		auto x3 &#x3D; [&amp;]&#123;return i_ + x + y; &#125;;		auto x4 &#x3D; [this]&#123;return i_; &#125;;		auto x5 &#x3D; [this]&#123;return i_ + x + y; &#125;;  &#x2F;&#x2F;error,没有捕获x和y		auto x6 &#x3D; [this, x, y]&#123;return i_ + x + y; &#125;;		auto x7 &#x3D; [this]&#123;return i_++; &#125;;	&#125;&#125;;int main(void)&#123;	&#123;		int a &#x3D; 0;		int b &#x3D; 1;		auto func1 &#x3D; []&#123;return a; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量 		auto func2 &#x3D; [&amp;]&#123;return a++; &#125;;		auto func3 &#x3D; [&#x3D;]&#123;return a; &#125;;		auto func4 &#x3D; [&#x3D;]&#123;return a++; &#125;;  &#x2F;&#x2F;error,a是以复制方式捕获的，无法修改		auto func5 &#x3D; [a]&#123;return a + b; &#125;;  &#x2F;&#x2F;error,没有捕获变量b		auto func6 &#x3D; [a, &amp;b]&#123;return a + (b++); &#125;;		auto func7 &#x3D; [&#x3D;, &amp;b]&#123;return a + (b++); &#125;;	&#125;	system(&quot;pause&quot;);	return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color=red>lambda按值捕获时实际捕获的是外部变量的副本，捕获之后的任何修改与原始变量无关，此种行为称作lambda捕获延时性</font></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a&#x3D;0;auto f &#x3D; [&#x3D;] &#123;return a;&#125;;a +&#x3D; 1;cout&lt;&lt;f()&lt;&lt;endl;  &#x2F;&#x2F;结果仍然是0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color=red>没有捕获外部变量的lambda表达式可以直接转换为函数指针</font>，可以这么理解：假如lambda捕获了作用域内的rivate、protect成员，lambda转换为函数指针后，若在它处发生调用，函数是不会对private、protect进行检查，这样就破坏了封装性。</p>
<h2 id="12-1、lambda表达式的类型"><a href="#12-1、lambda表达式的类型" class="headerlink" title="12.1、lambda表达式的类型"></a>12.1、lambda表达式的类型</h2><p>从C++11标准的定义上可以发现，lambda的类型被定义为”<strong>闭包</strong>“（closure）的类，而每个lambda表达式则会产生一个闭包类型的临时对象（右值）。因此，严格地讲，lambda表达式并非函数指针。不过C++11标准却允许lambda表达式向函数指针转换(不允许函数指针向lambda转换)，但前提是lambda函数<strong>没有捕捉任何变量</strong>，且函数指针所示的函数原型， 必须跟lambda表达式类型相同。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int girls&#x3D;3,boys&#x3D;4;auto totalChild&#x3D;[](int x,int y)-＞int&#123;return x+y;&#125;;typedef int(*allChild)(int x,int y);typedef int(*oneChild)(int x);allChild p;p&#x3D;totalChild;oneChild q;q&#x3D;totalChild;&#x2F;&#x2F;编译失败， 参数必须一致decltype(totalChild)allPeople&#x3D;totalChild;&#x2F;&#x2F;需通过decltype获得lambda的类型decltype(totalChild)totalPeople&#x3D;p;&#x2F;&#x2F;编译失败， 指针无法转换为lambdareturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="12-2、lambda的常量性"><a href="#12-2、lambda的常量性" class="headerlink" title="12.2、lambda的常量性"></a>12.2、lambda的常量性</h2><p>lambda默认是const(常量性)，mutable可以修改其常量性，不过极少使用</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int val;auto const_val_lambda&#x3D;[&#x3D;]()&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;编译失败,不允许在const的lambda中修改按值捕获的变量auto mutable_val_lambda&#x3D;[&#x3D;]()mutable&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;非const的lambda,可以修改捕获的变量。对于按值捕获的变量，修改的是其捕获的副本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="12-3、lambda的底层实现"><a href="#12-3、lambda的底层实现" class="headerlink" title="12.3、lambda的底层实现"></a>12.3、lambda的底层实现</h2><p>lambda表达式被设计的目的就是要就地书写，就地使用。使用lambda的用户，更倾向于在一个文件作用域里看到所有的代码，而不是依靠代码浏览工具在文件间找到函数的实现。在封装的思维层面上，lambda只是一种局部的封装以及局部的共享。<br>由<strong>12.1节</strong>可知lambda是一个闭包类型，那么它的底层是怎么实现的呢？这就要从函数对象说起，函数对象是对函数调用符operator()的重载，详见<strong>4.9.7节</strong><br>lambda的原理与此相关：<font color=red>编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符</font></p>
<h3 id="12-3-1、无捕获列表-无参数列表"><a href="#12-3-1、无捕获列表-无参数列表" class="headerlink" title="12.3.1、无捕获列表 + 无参数列表"></a>12.3.1、无捕获列表 + 无参数列表</h3><p><code>auto print = []&#123;cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl; &#125;;</code><br>编译器会翻译成，伪代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;用给定的lambda表达式生成相应的类class print_class&#123;public:	void operator()(void) const	&#123;		cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl;	&#125;&#125;;&#x2F;&#x2F;用构造的类创建对象，print此时就是一个函数对象auto print &#x3D; print_class();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="12-3-2、无捕获列表-参数列表"><a href="#12-3-2、无捕获列表-参数列表" class="headerlink" title="12.3.2、无捕获列表 + 参数列表"></a>12.3.2、无捕获列表 + 参数列表</h3><p><code>auto add = [](int a, int b)&#123;return a + b; &#125;;</code><br>编译器会翻译成，伪代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class add_class&#123;public:	auto operator()(int a, int b) const	&#123;		return a + b;	&#125;&#125;;auto add &#x3D; add_class();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="12-3-3、按值捕获"><a href="#12-3-3、按值捕获" class="headerlink" title="12.3.3、按值捕获"></a>12.3.3、按值捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;&#x2F;&#x2F;采用值捕获，捕获所有的已定义的局部变量，如year，nameauto print &#x3D; [&#x3D;]()&#123;	cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>编译器会翻译成，伪代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:	&#x2F;&#x2F;根据捕获列表来决定构造函数的参数列表形式	print_class(int year, char *name) :year(year), name(name)	&#123; 	&#125;	void operator()(void) const	&#123;		cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;	&#125;private:	int year;	char *name;&#125;;auto print &#x3D; print_class(a, str);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里需要注意的是：</p>
<ul>
<li>值的传递方式是以含参数的构造函数实现；</li>
<li>按值捕获时lambda默认为const，在编译时以operator() const形式实现，同理mutable将const属性去除，是通过取消operator()的const性实现；</li>
</ul>
<h3 id="12-3-4、按引用捕获"><a href="#12-3-4、按引用捕获" class="headerlink" title="12.3.4、按引用捕获"></a>12.3.4、按引用捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;auto print &#x3D; [&amp;]()&#123;	year++;	cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>编译器会翻译成，伪代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:	&#x2F;&#x2F;由于是引用捕获，参数列表采用引用的方式	print_class(int &amp;year, char *&amp;name) :year(year), name(name)	&#123; 	&#125;	void operator()(void) const	&#123;			year++;   &#x2F;&#x2F;编译通过，const对引用类型无效		cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;	&#125;private:	int &amp;year;	char *&amp;name;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="12-4、lambda的优势"><a href="#12-4、lambda的优势" class="headerlink" title="12.4、lambda的优势"></a>12.4、lambda的优势</h2><p><font color=purple>lambda表达式的优势：</font></p>
<ul>
<li>提升代码的可读性，它是就地书写，就地使用；</li>
<li>底层使用函数对象的方法实现，故同函数对象一样的优势，就地展开，避免了频繁的函数调用，性能更加；</li>
</ul>
<h1 id="13、I-O操作"><a href="#13、I-O操作" class="headerlink" title="13、I/O操作"></a>13、I/O操作</h1><p>stream流操作是读写功能的通用实现，不管数据来自网络、磁盘、程序或键盘，都以相同的方式处理读写操作。</p>
<h2 id="13-1、C-stream流操作类与控制符"><a href="#13-1、C-stream流操作类与控制符" class="headerlink" title="13.1、C++ stream流操作类与控制符"></a>13.1、C++ stream流操作类与控制符</h2><p><strong>常用stream类</strong></p>
<ul>
<li><strong>cout</strong>—标准输出；   </li>
<li><strong>cin</strong>—标准输入；   </li>
<li><strong>cerr</strong>—用于显示错误信息的标准输出流；    </li>
<li><strong>fstream</strong>—文件的输入输出流，集合了ofstream和ifstream；   </li>
<li><strong>ifstream</strong>—文件的输入流，用于读取文件；   </li>
<li><strong>ofstream</strong>—文件的输出流，用于写入文件操作；   </li>
<li><strong>stringstream</strong>—字符串的输入输出流，继承了istringstream和ostringstream，通常用于字符串和其他类型之间的转换；</li>
</ul>
<p><strong>常用stream流控制符</strong></p>
<ul>
<li>endl—输出换行符；</li>
<li>ends—输出空字符；</li>
<li>oct—以八进制形式进行输入输出；</li>
<li>dec—以十进制形式进行输入输出；</li>
<li>hex—以十六进制形式进行输入输出；</li>
<li>fixed—以定点表示法显示数据；</li>
<li>scientific—以科学表示法显示数据；</li>
<li>setprecision—设置小数精度；   </li>
<li>setw—设置字段宽度；   </li>
<li>setfill—设置填充字符；   </li>
<li>setbase—设置基数，与dec、hex、oct等效；   </li>
<li>setiosflag—通过类型为std::io_base::fmtflags的掩码输入参数设置标志；   </li>
<li>resetiosflag–重置标志；   </li>
</ul>
<h3 id="13-1-1、指定整形输出格式"><a href="#13-1-1、指定整形输出格式" class="headerlink" title="13.1.1、指定整形输出格式"></a>13.1.1、指定整形输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int Input &#x3D; 0;   cin &gt;&gt; Input;   cout &lt;&lt; &quot;Integer in octal: &quot; &lt;&lt; oct &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hexadecimal: &quot; &lt;&lt; hex &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hex using base notation: &quot;;   cout &lt;&lt; setiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer after resetting I&#x2F;O flags: &quot;;   cout &lt;&lt; resetiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 253    Integer in octal: 375   Integer in hexadecimal: fd   Integer in hex using base notation: 0XFD   Integer after resetting I&#x2F;O flags: 253<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-1-2、指定浮点型输出格式"><a href="#13-1-2、指定浮点型输出格式" class="headerlink" title="13.1.2、指定浮点型输出格式"></a>13.1.2、指定浮点型输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   const double Pi &#x3D; (double)22.0 &#x2F; 7;   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 7: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(7);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 10: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(10);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Enter a radius: &quot;;   double Radius &#x3D; 0.0;   cin &gt;&gt; Radius;   cout &lt;&lt; &quot;Area of circle: &quot; &lt;&lt; 2*Pi*Radius*Radius &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Pi&#x3D;3.14286    Setting precision to 7:    Pi&#x3D;3.142857   Fixed Pi &#x3D; 3.1428571    Scientific Pi &#x3D; 3.1428571e+000Setting precision to 10:    Pi&#x3D;3.1428571429e+000   Fixed Pi &#x3D; 3.1428571429  Scientific Pi &#x3D; 3.142857129e+000    Enter a radius:    Area of circle: 6.2731491429e+002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-1-3、设置文本对齐与宽度"><a href="#13-1-3、设置文本对齐与宽度" class="headerlink" title="13.1.3、设置文本对齐与宽度"></a>13.1.3、设置文本对齐与宽度</h3><p>setw设置字段宽度<br>setfill指定字符填充空白区域</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hey - default!&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and left, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setiosflags(ios::left);    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - left aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nback to default:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Hey - back to default!&quot; &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hey - default!weight length &#x3D; 35, and right default               Hey - right aligned!weight length &#x3D; 35, and right default, fill with ****************Hey - right aligned!weight length &#x3D; 35, and left, fill with *Hey - left aligned!****************back to default:Hey - back to default!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-1-4、cin读取"><a href="#13-1-4、cin读取" class="headerlink" title="13.1.4、cin读取"></a>13.1.4、cin读取</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int InputInt &#x3D; 0;   cin &gt;&gt; InputInt;   cout &lt;&lt; &quot;Enter an float: &quot;;   double Pi &#x3D; 0.0;   cin &gt;&gt; Pi;   cout &lt;&lt; &quot;Enter three characters separated by space: &quot; &lt;&lt; endl;   char Char1 &#x3D; &#39;\0&#39;, Char2 &#x3D; &#39;\0&#39;, Char3 &#x3D; &#39;\0&#39;;   cin &gt;&gt; Char1 &gt;&gt; Char2 &gt;&gt; Char3;   cout &lt;&lt; &quot;\nThe recorded variable values are: &quot; &lt;&lt; endl;   cout &lt;&lt; &quot;InputInt: &quot; &lt;&lt; InputInt &lt;&lt; endl;   cout &lt;&lt; &quot;Pi: &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; &quot;The three characters: &quot; &lt;&lt; Char1 &lt;&lt; Char2 &lt;&lt; Char3 &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 123Enter an float: 3.1415926Enter three characters separated by space: a b c    The recorded variable values are: InputInt: 123Pi: 3.14159The three characters: abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><font color=red><strong>读取数组</strong></font><br>可以直接使用cin，但这样存在地址越界的风险，最好使用get函数指定输入长度，避免地址越界</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter a line: &quot; &lt;&lt; endl;   char CStyleStr[10] &#x3D; &#123;0&#125;;   cin.get(CStyleStr, 9);   cout &lt;&lt; &quot;CStyleStr: &quot; &lt;&lt; CStyleStr &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><font color=red><strong>读取字符串</strong></font><br>使用cin读取数据到string时，如果输入流中有空格，cin的读取会停止，所以更好的方法是getline函数</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter your name: &quot;;   string Name;   getline(cin, Name);   &#x2F;&#x2F; 或者   cin.getline(Name);   cout &lt;&lt; &quot;Hi &quot; &lt;&lt; Name &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-1-5、fstream文件流操作"><a href="#13-1-5、fstream文件流操作" class="headerlink" title="13.1.5、fstream文件流操作"></a>13.1.5、fstream文件流操作</h3><p>fstream继承了ifstream和ofstream，需包含头文件<fstream></p>
<pre class="line-numbers language-none"><code class="language-none">fstream myFile;myFile.open(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);  &#x2F;&#x2F; 或者构造函数形式fstream myFile(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);if(myFile.is_open())&#123;    &#x2F;&#x2F; do something    myFile.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>第一个参数为打开文件的路径和名称，未指定路径时，默认为程序当前的执行路径；   </li>
<li>第二个参数为打开模式，主要有如下几种：   <ul>
<li>ios_base::app—附加到现有文件末尾，而不是覆盖它；   </li>
<li>ios_base::ate—切换到文件末尾，但可在文件任何地方写入数据；   </li>
<li>ios_base::trunc—直接覆盖现有文件，此为默认模式；   </li>
<li>ios_base::binary—创建二进制文件，默认为文本文件；   </li>
<li>ios_base::in—以只读方式打开，<strong>注意</strong>：此种打开方式要求文件必须已经存在，否则打开失败；   </li>
<li>ios_base::out—以只写方式打开；</li>
</ul>
</li>
</ul>
<p><font color=purple>**&lt;&lt;文本文件写入**</font></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;   ofstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::out);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful&quot; &lt;&lt; endl;    	  myFile &lt;&lt; &quot;My first text file!&quot; &lt;&lt; endl;      myFile &lt;&lt; &quot;Hello file!&quot;;     	  cout &lt;&lt; &quot;Finished writing to file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><font color=purple><strong>&gt;&gt;文本文件读取</strong></font></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   ifstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::in);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful. It contains: &quot; &lt;&lt; endl;      string fileContents;      while (myFile.good())      &#123;         getline (myFile, fileContents);       cout &lt;&lt; fileContents &lt;&lt; endl;      &#125;           cout &lt;&lt; &quot;Finished reading file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   else      cout &lt;&lt; &quot;open() failed: check if file is in right folder&quot; &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>good函数用于判断是否到达文件末尾；<br>getline函数逐行读取；   </p>
<p><font color=purple><strong>二进制文件读写read、write</strong></font></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;struct Human&#123;	Human() &#123;&#125;;   Human(const char* inName, int inAge, const char* inDOB) : Age(inAge)   &#123;      strcpy(Name, inName);      strcpy(DOB, inDOB);   &#125;   char Name[30];   int Age;   char DOB[20];&#125;;int main()&#123;   Human Input(&quot;Siddhartha Rao&quot;, 101, &quot;May 1910&quot;);   ofstream fsOut (&quot;MyBinary.bin&quot;, ios_base::out | ios_base::binary);   if (fsOut.is_open())   &#123;	  cout &lt;&lt; &quot;Writing one object of Human to a binary file&quot; &lt;&lt; endl;      fsOut.write(reinterpret_cast&lt;const char*&gt;(&amp;Input), sizeof(Input));      fsOut.close();   &#125;   ifstream fsIn (&quot;MyBinary.bin&quot;, ios_base::in | ios_base::binary);   if(fsIn.is_open())   &#123;      Human somePerson;      fsIn.read((char*)&amp;somePerson, sizeof(somePerson));      cout &lt;&lt; &quot;Reading information from binary file: &quot; &lt;&lt; endl;      cout &lt;&lt; &quot;Name &#x3D; &quot; &lt;&lt; somePerson.Name &lt;&lt; endl;      cout &lt;&lt; &quot;Age &#x3D; &quot; &lt;&lt; somePerson.Age &lt;&lt; endl;      cout &lt;&lt; &quot;Date of Birth &#x3D; &quot; &lt;&lt; somePerson.DOB &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="13-2、C-stream流操作"><a href="#13-2、C-stream流操作" class="headerlink" title="13.2、C stream流操作"></a>13.2、C stream流操作</h2><h3 id="13-2-1、输出64位整型"><a href="#13-2-1、输出64位整型" class="headerlink" title="13.2.1、输出64位整型"></a>13.2.1、输出64位整型</h3><pre class="line-numbers language-none"><code class="language-none">uint64_t num &#x3D; 0;printf(&quot;%llu&quot;, num);或者printf(&quot;%lld&quot;, num);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-2-2、输出到数组"><a href="#13-2-2、输出到数组" class="headerlink" title="13.2.2、输出到数组"></a>13.2.2、输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">char src[32];char dst[32];sprintf(dst, &quot;%s&quot;, src);snprintf(dst, sizeof(dst),&quot;%s&quot;, src);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-2-3、以日期格式输出到数组"><a href="#13-2-3、以日期格式输出到数组" class="headerlink" title="13.2.3、以日期格式输出到数组"></a>13.2.3、以日期格式输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">time_t timeTick &#x3D; time(NULL);char timeStamp[24];strftime(timeStamp, _countof(timeStamp), &quot;%Y-%m-%d %H:%M:%S&quot;, localtime(&amp;timeTick));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-2-4、打开文件"><a href="#13-2-4、打开文件" class="headerlink" title="13.2.4、打开文件"></a>13.2.4、打开文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE *fopen( const char *path, const char *mode );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>函数说明：</strong>   </p>
<ul>
<li>path就是指定打开文件的路径，可以是相对路径，也可以绝对路径。mode代表打开文件的方式；</li>
<li>fopen打开成功，返回FILE的有效地址，失败返回NULL；</li>
</ul>
<p><strong>mode模式说明：</strong></p>
<ul>
<li><p>r 以只读方式打开文件，该文件必须存在，文件必须是可读的。</p>
</li>
<li><p>r+ 以可读写方式打开文件，该文件必须存在。</p>
</li>
<li><p>rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。</p>
</li>
<li><p>rw+ 读写打开一个文本文件，允许读和写。</p>
</li>
<li><p>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</p>
</li>
<li><p>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</p>
</li>
<li><p>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。<strong>EOF符保留</strong></p>
</li>
<li><p>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<strong>原来的EOF符不保留</strong></p>
</li>
</ul>
<h3 id="13-2-5、输出到文本文件"><a href="#13-2-5、输出到文本文件" class="headerlink" title="13.2.5、输出到文本文件"></a>13.2.5、输出到文本文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;fprintf(pfile, &quot;%d%s%c&quot;, num, strName, nChr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-2-6、输出到二进制文件"><a href="#13-2-6、输出到二进制文件" class="headerlink" title="13.2.6、输出到二进制文件"></a>13.2.6、输出到二进制文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;uint32_t num;fwrite(&amp;num, sizeof(uint32_t), 1, pfile);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="13-2-7、rename"><a href="#13-2-7、rename" class="headerlink" title="13.2.7、rename"></a>13.2.7、rename</h3><p>rename重命名或移动文件，但当目的目录下已存在同名文件时，不能被覆盖，被操作文件无法移动，所以操作之前需要检查目的目录下是否存在同名文件。</p>
<h2 id="13-3、I-O模型"><a href="#13-3、I-O模型" class="headerlink" title="13.3、I/O模型"></a>13.3、I/O模型</h2><p>I/O模型主要涉及两个对象：用户态、内核态。操作系统中I/O相关操作是内核行为，用户态是不能直接进行I/O操作的，比如读取文件、网络、键盘、鼠标、显示器等，用户态程序需要通过系统调用驱使内核态进行I/O操作。<br>同理同步、异步、阻塞、非阻塞也是针对用户态、内核态而言，相关概念参见：<strong>计算机系统.md第2节</strong>；</p>
<ul>
<li>同步阻塞I/O：用户态向内核态发起IO请求之后不做任何事情，死等内核返回IO操作结果；</li>
<li>同步非阻塞I/O：用户态向内核态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，不用死等。</li>
<li>异步非阻塞：用户态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，且用户态可以同时发起多次IO请求，内核态也可以同时返回多次IO操作结果；</li>
<li>异步只有非阻塞；</li>
</ul>
<h3 id="13-3-1、常见I-O模型"><a href="#13-3-1、常见I-O模型" class="headerlink" title="13.3.1、常见I/O模型"></a>13.3.1、常见I/O模型</h3><ul>
<li>阻塞状态下，用户态会一直等待内核返回结果，在此期间用户态会持续占有CPU；</li>
<li>非阻塞状态下，用户态不会一直等待内核返回结果，那么用户是如何接收内核返回的呢？常见的方式有：一通过轮询的方式检查内核是否结束，二是用户态发起请求之后就进入睡眠状态，待内核完成操作后以通知方式唤醒用户态接收；</li>
</ul>
<table>
<thead>
<tr>
<th>1、阻塞IO模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>老李去火车站买票，排队三天买到一张票</td>
<td></td>
</tr>
<tr>
<td>耗费：在车站吃喝拉撒睡3天，其他事一件没干</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>2、非阻塞IO模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>老李去火车站买票，隔12小时去火车站问有没有票，三天后买到一张票</td>
<td></td>
</tr>
<tr>
<td>耗费：往返车站6次，路上6小时，其他时间做了好多事</td>
<td></td>
</tr>
</tbody></table>
<p><font color=red>这既是传统的轮询方式，轮询的不足之处在于不管IO队列之中是否有读写动作的发生，loop都会进行IO队列的遍历操作，这样便会白白浪费CPU资源。</font></p>
<p><strong>3、I/O复用模型，一共包括两种</strong></p>
<table>
<thead>
<tr>
<th>3.1、select/poll模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>老李去火车站买票，委托黄牛，黄牛会监视所有车次的余票，然后每隔6小时老李都会电话询问黄牛，看下是否是自己想要的车次，黄牛三天内买到票，然后老李去火车站交钱领票</td>
<td></td>
</tr>
<tr>
<td>耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次</td>
<td></td>
</tr>
<tr>
<td>select模型下黄牛可以监视的车次有限，poll模型下，黄牛可以监视全国范围内的所有车次</td>
<td></td>
</tr>
</tbody></table>
<p>这个代理可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个去轮询了，伪代码如下： </p>
<pre class="line-numbers language-none"><code class="language-none">while true  &#123;      select(streams[]) &#x2F;&#x2F;这一步阻塞在这里，直到有一个流有I&#x2F;O事件时，才往下执行      for i in streams[]      &#123;          if i has data          read until unavailable      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>但是依然有个问题，我们从select那里仅仅知道有I/O事件发生了，却并不知道是哪个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<br>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<table>
<thead>
<tr>
<th>3.2、epoll模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>老李去火车站买票，委托黄牛，黄牛通过车次编码识别老李需要的车次，黄牛买到后即通知老李去领，然后老李去火车站交钱领票</td>
<td></td>
</tr>
<tr>
<td>耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</td>
<td></td>
</tr>
</tbody></table>
<p>epoll可以理解为event poll，不同于死循环和无差别轮询，epoll会以事件通知的方式反馈指定I/O流是否有事件发生，这样轮询的复杂度降低到了O(1)，伪代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">while true  &#123;      active_stream[] &#x3D; epoll_wait(epollfd)      for i in active_stream[]      &#123;          read or write till      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以看到，select/poll和epoll最大的区别就是：select/poll只是告诉你一定数目的流有事件了，至于哪个流有事件，还得一个个地去轮询，而epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到指定的流。</p>
<p><font color=red><strong>这里的黄牛相当于代理功能的select/poll，epoll</strong>，这个代理位于内核态，可以同时监控多个IO动作。</font></p>
<table>
<thead>
<tr>
<th>4、信号驱动IO模型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票</td>
<td></td>
</tr>
<tr>
<td>耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</td>
<td></td>
</tr>
</tbody></table>
<h3 id="13-3-2、I-O复用的理解"><a href="#13-3-2、I-O复用的理解" class="headerlink" title="13.3.2、I/O复用的理解"></a>13.3.2、I/O复用的理解</h3><p>IO复用产生的原因：<br>如果一个I/O操作到来我们就开启一个task进行处理，那么假设现在有一百万个I/O操作进来，那我们就需要开启一百万个task一一这就是传统意义下的多task并发阻塞处理。思考一下，一百万个task，你的CPU占有会多高，这钟实现方式极其的不合理。所以人们提出了I/O多路复用模型，一个专有task通过记录I/O状态的方式来同时管理多个I/O。</p>
<p>IO复用的英文单词I/O multiplexing翻译成多路复用其实并不合理，应该理解成将多个task注册的I/O凑在一起交由一个专有task统一管理。注册I/O的task在I/O操作返回之前可以处理其他的事情已到达提升吞吐量的目的，这种涉及模式称作Reactor模式。</p>
<p>IO复用的实现方式包括：select、poll、epoll</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">IPanda</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xman123ing.github.io/2021/07/10/C-plus-%E8%B4%B0/">https://xman123ing.github.io/2021/07/10/C-plus-%E8%B4%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">IPanda</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/07/10/C-plus-%E8%B4%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="C-plus-贰">
                        
                        <span class="card-title">C-plus-贰</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                    summary && 技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/10/C-plus-%E5%8F%81/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="C-plus-叁">
                        
                        <span class="card-title">C-plus-叁</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/summary-%E6%8A%80%E6%9C%AF/" class="post-category">
                                    summary && 技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/C/">
                        <span class="chip bg-color">C++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: IPanda`s Blog<br />'
            + '文章作者: IPanda<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">IPanda</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "3";
                    var startDate = "7";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已努力运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Xman123ing/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lipin075084@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=836070413" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 836070413" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script src="/js/prism/prism.js" async></script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.8'
        zIndex="-1" count="150"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
