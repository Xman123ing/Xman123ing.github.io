<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git与Github</title>
      <link href="2021/03/17/Git%E4%B8%8EGithub/"/>
      <url>2021/03/17/Git%E4%B8%8EGithub/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Git简介"><a href="#1、Git简介" class="headerlink" title="1、Git简介"></a>1、Git简介</h1><h2 id="1-1、发展历史"><a href="#1-1、发展历史" class="headerlink" title="1.1、发展历史"></a>1.1、发展历史</h2><ul><li>git开发者是Linux系统创始人Linus；</li><li>在git之前，市场上有免费的版本管理系统CVS、SVN，但它们都是集中式的版本控制系统，不仅速度慢，而且需要联网；</li><li>一开始Linux的源代码是由Linus亲自管理，但到了2002年，由于代码量的急剧上升，Linus就将源代码托管在商用软件BitKeeper上，其母公司BitMover对Linux社区免费。但后来因为Linux社区有人试图破解BitKeeper被发现，而被终止向社区提供服务；</li><li>Linus花费两周时间用C语言开发了分布式的Git；</li><li>2008年GitHub上线，它为开源项目提供免费的源码git存储；</li></ul><h2 id="1-2、git对象"><a href="#1-2、git对象" class="headerlink" title="1.2、git对象"></a>1.2、git对象</h2><p>   首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词”Linux”，在第8行删了一个单词”Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>​    git与其他版本管理系统不同之处在于，git跟踪和管理的对象是修改，而非文件本身。</p><h1 id="2、Git使用-本地版本库-仓"><a href="#2、Git使用-本地版本库-仓" class="headerlink" title="2、Git使用-本地版本库/仓"></a>2、Git使用-本地版本库/仓</h1><h2 id="2-1、创建版本库-仓"><a href="#2-1、创建版本库-仓" class="headerlink" title="2.1、创建版本库/仓"></a>2.1、创建版本库/仓</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   这样就在本地创建了一个空的git，该目录下的所有文件就会被git管理起来。同时本地也会生成一个隐藏目录.git，它是git用来跟踪管理版本库</p><h2 id="2-2、commit修改"><a href="#2-2、commit修改" class="headerlink" title="2.2、commit修改"></a>2.2、commit修改</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git add + pathgit commit -m &quot;comment&quot;&#x2F;&#x2F; 或者进入vi模式进行修改git commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>   不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。如果觉得文件修改到一定程度的时候，就可以”保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作。</p><h2 id="2-3、git-status"><a href="#2-3、git-status" class="headerlink" title="2.3、git status"></a>2.3、git status</h2><p>可以查看当前仓的状态，比如是否有change, 是否有commit等</p><h2 id="2-4、git-diff"><a href="#2-4、git-diff" class="headerlink" title="2.4、git diff"></a>2.4、git diff</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git diff + file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前改动的内容，只能查看本地未commit的修改部分</p><h2 id="2-5、查看修改日志"><a href="#2-5、查看修改日志" class="headerlink" title="2.5、查看修改日志"></a>2.5、查看修改日志</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示的结果中commit ID是16进制SHA1码，是修改记录的唯一标识</p><h2 id="2-6、版本回退"><a href="#2-6、版本回退" class="headerlink" title="2.6、版本回退"></a>2.6、版本回退</h2><p>git中HEAD表示当前版本，依次类推HEAD^是上一个版本，HEAD^^前两个版本……，也可以这样表示HEAD~100前100个版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 回退到前一个版本git reset --hard HEAD^# 回退到之前指定的版本,n表示前n个版本git reset --hard HEAD~n# 也可以使用commit id，使用commit id也可以往后回退，防止误回退操作# 如果忘记了回退之前的commit id，可以使用git reflog查看git reset --hard + commit id# --hard表示同时也会回退文件本地的修改，较为危险；不带hard，仅回退暂存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过–hard方式回退的操作，可以回退commit记录，也会将文件本身进行回退</p><h2 id="2-7、git-reflog"><a href="#2-7、git-reflog" class="headerlink" title="2.7、git reflog"></a>2.7、git reflog</h2><p>查看在当前版本库下所有执行过的git命令</p><h2 id="2-8、工作区和暂存区"><a href="#2-8、工作区和暂存区" class="headerlink" title="2.8、工作区和暂存区"></a>2.8、工作区和暂存区</h2><table><thead><tr><th>工作区</th><th>就是执行git init的本地目录</th></tr></thead><tbody><tr><td>版本库/仓</td><td>就是.git目录</td></tr><tr><td>暂存区</td><td>存在于版本库之中，称作stage</td></tr></tbody></table><p>版本库的组成：</p><ul><li>master—git创建的第一个分支</li><li>HEAD—指向master的指针，也就是git仓的当前版本</li></ul><p>git add就是将修改添加到暂存区，git add的操作对象是工作区的文件</p><p>git commit就是将暂存区的所有修改提交到当前分支，即当前版本HEAD，就是向master上提交。git commit的操作对象是暂存区的修改</p><h2 id="2-9、撤销修改"><a href="#2-9、撤销修改" class="headerlink" title="2.9、撤销修改"></a>2.9、撤销修改</h2><h3 id="2-9-1、工作区"><a href="#2-9-1、工作区" class="headerlink" title="2.9.1、工作区"></a>2.9.1、工作区</h3><ul><li>1、如果乱改了工作区文件，但并没有提交到暂存区，即没有执行git add；</li><li>2、已经提交到暂存区，但没有commit到版本/分支，又在工作区做了修改；</li></ul><p>撤销工作区的修改操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -- file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完命令后：</p><ul><li>1、就回到了和当前版本库/分支一样的状态；</li><li>2、就回到了添加到暂存区后的状态；</li></ul><h3 id="2-9-2、暂存区"><a href="#2-9-2、暂存区" class="headerlink" title="2.9.2、暂存区"></a>2.9.2、暂存区</h3><p>1、如果错误的修改被git add到暂存区，但并未commit</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git reset HEAD file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令就会撤回暂存区的修改，此时通过git status可以看到修改撤回到了工作区，如果还想撤回工作区的修改，参考2.9.1即可</p><p>2、或者重新修改文件</p><p>然后重新add，git commit –amend即可</p><h3 id="2-9-3、版本库-仓"><a href="#2-9-3、版本库-仓" class="headerlink" title="2.9.3、版本库/仓"></a>2.9.3、版本库/仓</h3><p>如果错误修改即git add， 也git commit，那就参考2.6，进行版本回退</p><h3 id="2-9-4、远程分支"><a href="#2-9-4、远程分支" class="headerlink" title="2.9.4、远程分支"></a>2.9.4、远程分支</h3><p>如果错误修改即git add， 也git commit，同时又git push到了远程仓库，那就不能参考2.6，进行版本回退了</p><h2 id="2-10、删除文件"><a href="#2-10、删除文件" class="headerlink" title="2.10、删除文件"></a>2.10、删除文件</h2><ul><li>如果提交到版本库之后，在工作区删除了文件，此时工作区与版本库就不一致了，那么git status会告知哪些文件被删除了，如果此时确定需要从版本库删除；</li><li>如果提交到版本库之后，发现有些文件是没必要提交的，那么可以先在工作区删除该文件，然后执行以下命令；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git rm file namegit commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果提交到版本库之后，误删了工作区文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -- file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3、Git使用-远程基线版本"><a href="#3、Git使用-远程基线版本" class="headerlink" title="3、Git使用-远程基线版本"></a>3、Git使用-远程基线版本</h1><h2 id="3-1、基线、master、分支"><a href="#3-1、基线、master、分支" class="headerlink" title="3.1、基线、master、分支"></a>3.1、基线、master、分支</h2><ul><li>从大版本的一个时间节点拉下来的代码作为基线版本，基线版本的管理是放在远程服务器，可以理解成”中央服务器”，基线版本可以理解成所有开发者的主分支master，它只有一条时间线；</li><li>每个开发者从远程服务器拉下来的代码，作为本地的主分支master，所有的本地修改，都是在延长本地分支的时间线；</li><li>分支，本地代码相对于远程服务器基线版本，就是一个分支；基线版本相对于大版本就是一个分支；</li></ul><p>第一次拉完代码后，本地master与远程master是对应起来的，HEAD是指向本地master的，后续的本地修改，都是在延长本地分支的时间线，HEAD指向当前最新本地版本。</p><h2 id="3-2、抓取远程分支"><a href="#3-2、抓取远程分支" class="headerlink" title="3.2、抓取远程分支"></a>3.2、抓取远程分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone ssh:&#x2F;&#x2F;lipin@172.17.122.236:29418&#x2F;&lt;分支名&gt;&#x2F;&#x2F; 或git pull ssh:&#x2F;&#x2F;lipin@gerrit.scm.adc.com:29418&#x2F;amss&#x2F;slpi_proc &lt;最新提交点&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-3、创建本地分支"><a href="#3-3、创建本地分支" class="headerlink" title="3.3、创建本地分支"></a>3.3、创建本地分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不创建本地分支名，只要在push时知道目标远程分支名即可</p><h2 id="3-4、创建本地分支并与远程分支相关联"><a href="#3-4、创建本地分支并与远程分支相关联" class="headerlink" title="3.4、创建本地分支并与远程分支相关联"></a>3.4、创建本地分支并与远程分支相关联</h2><pre class="line-numbers language-none"><code class="language-none">git checkout -b &lt;local branch name&gt; origin&#x2F;&lt;remote branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-5、设置本地分支与远程分支链接"><a href="#3-5、设置本地分支与远程分支链接" class="headerlink" title="3.5、设置本地分支与远程分支链接"></a>3.5、设置本地分支与远程分支链接</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 第一次clone或pull时并未创建本地分支，后期需要与远程分支相关联时，可执行git branch --set-upstream-to&#x3D;origin&#x2F;&lt;remote branch name&gt; &lt;local branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-6、切换分支"><a href="#3-6、切换分支" class="headerlink" title="3.6、切换分支"></a>3.6、切换分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-7、创建本地分支并切换分支"><a href="#3-7、创建本地分支并切换分支" class="headerlink" title="3.7、创建本地分支并切换分支"></a>3.7、创建本地分支并切换分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -b name&#x2F;&#x2F; 这条命令相当于下面两条命令的合集git branch namegit checkout name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-8、查看分支"><a href="#3-8、查看分支" class="headerlink" title="3.8、查看分支"></a>3.8、查看分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch&#x2F;&#x2F; 或git branch -agit remotegit remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面标’*’的行，就是本地主分支当前master；</p><p>‘origin’行就是远程基线主分支/远程仓库；</p><h2 id="3-9、合并分支"><a href="#3-9、合并分支" class="headerlink" title="3.9、合并分支"></a>3.9、合并分支</h2><h3 id="3-9-1、合并本地分支"><a href="#3-9-1、合并本地分支" class="headerlink" title="3.9.1、合并本地分支"></a>3.9.1、合并本地分支</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git merge 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其他分支合并到当前分支，使用的是fast forward模式，所以在git log中看不到本次合并历史，如果需要：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git merge --no-ff -m &quot;内容&quot; 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为本次合并需要创建一个新的commit，所以需要加 ‘-m’</p><h2 id="3-10、推送分支"><a href="#3-10、推送分支" class="headerlink" title="3.10、推送分支"></a>3.10、推送分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git push origin master&#x2F;&#x2F; 如果本地未创建master分支，可以通过目标远程分支pushgit push origin HEAD:refs&#x2F;for&#x2F;&lt;远程分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p><h2 id="3-11，git-pull"><a href="#3-11，git-pull" class="headerlink" title="3.11，git pull"></a>3.11，git pull</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 首次拉远程分支的最新提交点git pull ssh:&#x2F;&#x2F;lipin@gerrit.scm.adc.com:29418&#x2F;amss&#x2F;slpi_proc &lt;最新提交点&gt;&#x2F;&#x2F; 非首次，拉取最新提交点到本地git pull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>git pull的使用场景通常是多人同时对一个分支仓进行修改时，后push的人在push之前需要先pull最新的远程提交点，与自己本地修改合并之后才能顺利push自己的修改提交</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="4、git使用-分支相关"><a href="#4、git使用-分支相关" class="headerlink" title="4、git使用-分支相关"></a>4、git使用-分支相关</h1><h2 id="4-1、解决冲突conflict"><a href="#4-1、解决冲突conflict" class="headerlink" title="4.1、解决冲突conflict"></a>4.1、解决冲突conflict</h2><p>冲突发生的场景：</p><ul><li>合并其他分支到当前分支时，当前分支滞后于其他分支，或者说当前分支不是最新提交点。这个其他分支既可以是本地分支也可以是远程分支</li><li>从其他分支cherry-pick时</li></ul><p>通过git status可以查看冲突的文件，冲突的内容会通过&lt;&lt;&lt;&lt;&lt;&lt;&lt;<code>，</code>=======<code>，</code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;形式标注出来</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new one&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new two&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vim修改冲突部分即可解决</p><h3 id="4-1-1、push到远程分支’Merge-Conflict’"><a href="#4-1-1、push到远程分支’Merge-Conflict’" class="headerlink" title="4.1.1、push到远程分支’Merge Conflict’"></a>4.1.1、push到远程分支’Merge Conflict’</h3><ul><li>首先点击rebase，如果仍然提示冲突</li><li>方案一：不影响本地编译环境</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、先确保本地修改已经push# 2、将有冲突的仓拉取到本地临时目录repo init -u ssh:&#x2F;&#x2F;gerrit.scm.adc.com:29418&#x2F;oplus&#x2F;prjxml&#x2F;mtk&#x2F;r -b r&#x2F;mtk -m mtk_11&#x2F;20131&#x2F;Milestone_XML&#x2F;mtk_11_V7.1_userdebug.xml --reference&#x3D;&#x2F;work&#x2F;oppo_mirror --no-repo-verifyrepo sync -fcq -j4 --no-tags --prune --no-repo-verify 仓库名# 或者直接在已有的gerrit提交网页复制pull命令# 3、将提交的本地修改cherriy pick到临时目录，解决冲突后重新push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2、git-stash"><a href="#4-2、git-stash" class="headerlink" title="4.2、git stash"></a>4.2、git stash</h2><p>场景：</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交（通过git status查看当前分支未提交的修改）。<br>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？<br>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场”储藏”起来，等以后恢复现场后继续工作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git stashSaved working directory and index state WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在用git status查看工作区，就是干净的。</p><p>bug修复完以后，将之前’储藏’起来的现场恢复：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 方法一： git stash apply + git stash dropgit stash apply stash@&#123;编号&#125;  # 恢复后stash内容不会被删除，需要使用下面的命令删除git stash drop stash@&#123;编号&#125; # 一步到位方式git stash pop stash@&#123;编号&#125; # 查看本地stashgit stash list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3、合并指定修改"><a href="#4-3、合并指定修改" class="headerlink" title="4.3、合并指定修改"></a>4.3、合并指定修改</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 有时候并不想合并完整分支，只是合并某一次的修改commit或远程服务器的其他开发人员的某一次pushgit cherry-pick commit id &#x2F; push地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-4、删除分支"><a href="#4-4、删除分支" class="headerlink" title="4.4、删除分支"></a>4.4、删除分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、本地分支# 删除已合并的分支git branch -d 分支名# 删除未合并的分支git branch -D 分支名#删除本地的远程分支git branch -r -D origin&#x2F;分支名# 2、远程分支# 远程删除git服务器上的remote分支git push origin --delete 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、查看本地分支配置信息-对应的仓名称"><a href="#4-5、查看本地分支配置信息-对应的仓名称" class="headerlink" title="4.5、查看本地分支配置信息/对应的仓名称"></a>4.5、查看本地分支配置信息/对应的仓名称</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config -l# remote.origin.projectname就是对应的远程仓名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-6、查看远程分支信息"><a href="#4-6、查看远程分支信息" class="headerlink" title="4.6、查看远程分支信息"></a>4.6、查看远程分支信息</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-7、no-tracking-information-本地分支与远程分支建立链接"><a href="#4-7、no-tracking-information-本地分支与远程分支建立链接" class="headerlink" title="4.7、no tracking information  / 本地分支与远程分支建立链接"></a>4.7、no tracking information  / 本地分支与远程分支建立链接</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch --set-upsream-to&#x3D;origin&#x2F;&lt;branch&gt; &lt;branch&gt;# 例如 本地开发分支dev与远程开发分支dev相关联git branch --set-upstream-to&#x3D;origin&#x2F;dev dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="5、速记"><a href="#5、速记" class="headerlink" title="5、速记"></a>5、速记</h1><h2 id="5-1、git配置"><a href="#5-1、git配置" class="headerlink" title="5.1、git配置"></a>5.1、git配置</h2><p>配置的对象有三个层级</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 面向系统的所有用户&#x2F;etc&#x2F;config使用git config --system + paras# 当前用户~&#x2F;.gitconfig使用git config --global + paras# 当前项目.git&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前配置会覆盖前一级别的配置</p><h3 id="5-1-1、用户信息配置"><a href="#5-1-1、用户信息配置" class="headerlink" title="5.1.1、用户信息配置"></a>5.1.1、用户信息配置</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.name &quot;lipin&quot;git config --global user.email &quot;lipin@oppo.con&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-1-2、配置文本编辑器"><a href="#5-1-2、配置文本编辑器" class="headerlink" title="5.1.2、配置文本编辑器"></a>5.1.2、配置文本编辑器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global core.editor vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-2、查看本地私钥"><a href="#5-2、查看本地私钥" class="headerlink" title="5.2、查看本地私钥"></a>5.2、查看本地私钥</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat ~&#x2F;.ssh&#x2F;id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-3、查看某个文件的提交记录"><a href="#5-3、查看某个文件的提交记录" class="headerlink" title="5.3、查看某个文件的提交记录"></a>5.3、查看某个文件的提交记录</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git log 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-4、合并diff"><a href="#5-4、合并diff" class="headerlink" title="5.4、合并diff"></a>5.4、合并diff</h2><pre class="line-numbers language-none"><code class="language-none"># 先查看是否可以正常何如git apply --check *.diff#  合入git applu *.diff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5、git不跟踪空目录"><a href="#5-5、git不跟踪空目录" class="headerlink" title="5.5、git不跟踪空目录"></a>5.5、git不跟踪空目录</h2><p>git只跟踪文件的变化，对于空目录git status是无变化地</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
