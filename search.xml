<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C-plus-贰</title>
      <link href="2021/07/10/C-plus-%E8%B4%B0/"/>
      <url>2021/07/10/C-plus-%E8%B4%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="7、关键字-amp-amp-修饰符"><a href="#7、关键字-amp-amp-修饰符" class="headerlink" title="7、关键字&amp;&amp;修饰符"></a>7、关键字&amp;&amp;修饰符</h1><h2 id="7-1、static"><a href="#7-1、static" class="headerlink" title="7.1、static"></a>7.1、static</h2><ul><li><p>隐藏<br>这是最重要的一个作用   </p><ul><li>作用域：具有static前缀的变量和函数仅当前源文件可见，故不能使用extern关键字；   </li><li>普通变量不能在头文件中定义，当被多个文件include时会报重复定义错误，需要使用extern关键字，才能将其具有跨文件作用域的全局性；   </li><li>静态变量和函数可以在头文件定义，不会报重复定义错误，因其不具备跨文件作用域的全局性。每个include的文件中都是独立分配的内存空间，彼此之间并无关联性；   </li></ul></li><li><p>生命周期<br>全局变量、静态全局变量、静态局部变量的生命周期都是整个程序运行期间</p></li><li><p>修饰C++类成员变量和函数<br>static成员属于整个类，不属于任何对象；<br>static成员变量内存只分配一次，对类的所有对象只有一份拷贝；<br>static成员变量和函数只能被本类访问，对类外不可见；<br>static成员函数不接收this指针，因此只能访问static成员；<br>static成员函数不能被virtual修饰，因为static成员不属于任何对象/实例，没有this指针，而virtual函数的实现是通过为每一有个对象分配一个vptr指针，而vptr是通过this指针调用地； </p></li></ul><h3 id="7-1-1、static特例场景"><a href="#7-1-1、static特例场景" class="headerlink" title="7.1.1、static特例场景"></a>7.1.1、static特例场景</h3><ul><li><p>static变量和函数的定义可以放在头文件，普通函数和变量的定义不能放在头文件，否则编译报错： ***** redefinition。 static变量和函数被include进源文件之后，都是独立的拷贝，彼此之间无关联；</p></li><li><p>类的static成员在类中定义之后，必须要在源文件中再显示定义一次，这是由static的两个属性决定的：</p><ul><li>static作用域仅限当前文件；</li><li>类的static成员只属于类，不属于类的对象；    </li></ul><p>所以必须要再次显示定义类static成员，为其在某一个源文件之中申请内存。</p></li></ul><p>否则编译报错：****undefined</p><h3 id="7-1-2、初始化时机及线程安全性"><a href="#7-1-2、初始化时机及线程安全性" class="headerlink" title="7.1.2、初始化时机及线程安全性"></a>7.1.2、初始化时机及线程安全性</h3><ul><li>全局变量、全局静态变量<ul><li>C语言中，它们的初始化发生在main函数之前，属于编译器常量；</li><li>C++中，对于非类对象的全局变量、全局静态变量，初始化时机与C语言一致；</li><li>C++中，类对象的全局变量、全局静态变量只有在第一次使用时才会进行初始化，这个’使用’包括显示调用该变量以及其他调用发生在其所在的源文件之中；<br>C++的对象必须由构造函数生成，并最终执行析构函数释放，由于构造动作需要执行相关代码，无法在编译期完成，所以类对象的全局变量、全局静态变量不是编译器常量，只有在第一次使用时才会进行初始化；</li></ul></li><li>局部静态变量<ul><li>C和C++中，都是第一次使用时才会进行初始化；</li></ul></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;class Wheel&#123;public:    Wheel()&#123;std::cout &lt;&lt; &quot;Wheel constructor&quot; &lt;&lt; std::endl;&#125;    ~Wheel()&#123;&#125;&#125;;class Window&#123;public:    Window()&#123;std::cout &lt;&lt; &quot;Window constructor&quot; &lt;&lt; std::endl;&#125;    ~Window()&#123;&#125;&#125;;class Car&#123;public:    Car()&#123;std::cout &lt;&lt; &quot;Car constructor&quot; &lt;&lt; std::endl;&#125;    ~Car()&#123;&#125;    void print()    &#123;        static Window four_windows;        std::cout &lt;&lt; &quot;I have four windows&quot; &lt;&lt; std::endl;    &#125;    static Wheel four_wheels;&#125;;Wheel Car::four_wheels;int main()&#123;    std::cout &lt;&lt; &quot;step in main&quot; &lt;&lt; std::endl;    Car my_car;    my_car.print();    std::cout &lt;&lt; &quot;step out main&quot; &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Wheel constructorstep in mainCar constructorWindow constructorI have four windowsstep out main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然并没有显式调用静态变量four_wheels，但声明语句’Wheel Car::four_wheels;’被放在main.cpp源文件之中，main函数的调用也发生在此文件之中，所以静态变量four_wheels完成了它的第一次使用；   </p><p>假如声明语句’Wheel Car::four_wheels;’放在另一个不相干的源文件之中，比如a.cpp，且没有任何的调用牵涉到a.cpp文件，那么静态变量four_wheels就没有被使用，运行结果也便不会打印’Wheel constructor’     </p><ul><li><strong>线程安全性</strong><ul><li>非类对象的全局变量、全局静态变量的初始化发生在main函数之前，故不存在线程安全性问题；</li><li>类对象的全局变量、全局静态变量以及局部静态变量，只有当第一次使用时才会进行初始化，故存在线程安全性问题。C++11之前并未对此有强制要求，故其线程安全性是存在问题的，但C++标准对此有了强制要求，要求编译器实现其线程安全性，例如g++使用了类似全局锁的方式解决此问题；</li></ul></li></ul><h3 id="7-1-3、优势"><a href="#7-1-3、优势" class="headerlink" title="7.1.3、优势"></a>7.1.3、优势</h3><ul><li>static变量和函数会在静态存储区申请空间，具有完整声明周期，与程序声明周期相同。在static变量访问、static函数调用时不用反复出栈入栈；</li><li>static变量和函数仅限当前文件作用域，故其他文件可以有相同名称的变量和函数；</li></ul><h2 id="7-2、const"><a href="#7-2、const" class="headerlink" title="7.2、const"></a>7.2、const</h2><p>const并不能代表”常量”，它仅仅是对变量的一种修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过指针间接的修改）。而这个变量的值，既可以在运行时也可以在编译时指定。    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">const int a &#x3D; 123;  &#x2F;&#x2F;  编译时常量void getResult(const int b);  &#x2F;&#x2F;  运行时常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>const可以修饰变量、函数、指针、函数返回值、形参、类成员变量、类成员函数</p><ul><li>设置变量常量性，定义时既要初始化。对于类的const成员变量则必须在初始化列表里进行初始化，也可在class的声明处初始化，此方法与在构造函数的初始化列表里初始化相同，如果此时初始化列表重新指定值，那么声明时的值就会被修改掉；</li><li>对于指针来说，可以修饰指针本身int *const ptrA，也可以修饰指针指向的对象const int *ptrA、int const *ptrA;</li><li>修饰函数返回值const int functionName()，使其返回值不能为”左值”，不能被修改，例如返回指向堆的指针；</li><li>指定类成员函数为常函数，int functionName() const，不能修改类的成员变量。类的常量对象只能访问类的常函数；</li><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>const属性可以通过类型转换符const_cast转换为非const；</li></ul><p>示例：    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">①const Stock &amp; Stock::topval (②const Stock &amp; s)③const   ①处const：确保返回的Stock对象在以后的使用中不能被修改②处const：确保此方法不修改形参s，或者说不能修改传递给形参s的实参③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-1、const特例场景"><a href="#7-2-1、const特例场景" class="headerlink" title="7.2.1、const特例场景"></a>7.2.1、const特例场景</h3><ul><li>const变量的定义可以放在头文件，普通变量的定义不能放在头文件，否则编译报错： ***** redefinition。 const变量被include进源文件之后，都是独立的拷贝，彼此之间无关联；</li><li>const之于函数重载<ul><li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参，则这个时候无论加不加const对实参不会产生任何影响；</li><li>但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。所以，只有引用传递和指针传递可以用是否加const来重载，而值传递的const不具备重载性；</li></ul></li></ul><h2 id="7-3、mutable"><a href="#7-3、mutable" class="headerlink" title="7.3、mutable"></a>7.3、mutable</h2><p>如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;</p><h2 id="7-4、extern"><a href="#7-4、extern" class="headerlink" title="7.4、extern"></a>7.4、extern</h2><ul><li>声明外部属性，修饰变量、函数；</li><li>指示C、C++编译规范：<br>比如在C＋＋中调用C库函数，就需要在C＋＋程序中用如下命令声明要引用的函数   </li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef __cplusplusextern &quot;C&quot; &#123;#endifvoid print(char *);    #ifdef __cplusplus&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</p><h2 id="7-5、inline"><a href="#7-5、inline" class="headerlink" title="7.5、inline"></a>7.5、inline</h2><p>inline用于定义内联函数<br><strong>产生背景：</strong>    </p><ul><li>函数调用时需要出栈入栈，频繁的出入栈时间成本增加，且会造成栈空间的大量消耗；</li><li>取代宏表达式，内联函数与普通函数一样，编译时会进行严格的类型检查，不像宏表达式没有类型检查，只是简单的文本替换，且宏表达式的编译错误很难发现；</li></ul><p><strong>PS：</strong>   </p><ul><li><p>inline只是对编译器的一种建议，编译器并不一定会将函数变成内联函数，是否内联依赖于函数具体实现、编译选项等因素：   </p><ul><li>默认编译优化选项-O0时inline不起作用，-O2、-O3时inline会生效；</li><li>存在inline函数的指针调用时，inline在调用位置失去内联属性，与普通函数无异；</li><li>存在结构控制语句时不生效，例如while、switch、for；</li><li>函数体实现过长时也不生效；</li></ul></li><li><p>inline函数定义可以放在头文件之中，符合语法规则。因为inline函数在调用处就地展开，不同调用处均是互不相干inline的函数副本；</p></li><li><p>inline函数只能有定义，不能单独进行声明，类成员函数除外，说明如下：</p><ul><li>声明处的inline是无效的，编译会报错：***** is not defined<br>因为inline函数编译期需要在调用处直接展开，它不能像普通函数一样通过声明去找函数定义体，所以要求inline的声明和定义必须是一体的，类成员函数除外。<br>示例：<br>假如inline的声明和定义是分开的，不管声明处是否显式包含inline，编译都会报错</li></ul></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">inline void func(void)ERROR: inline function func is not defined  &#x2F;&#x2F;inline函数声明void func(void)ERROR: function func is not defined  &#x2F;&#x2F;报错信息不同于上面的例子，这是因为声明处是普通函数func，它会去源文件中查找函数func的定义，而源文件中只有inline func，二者是没有关联的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景：</strong>   </p><ul><li>函数定义较短，且调用的地方不是很多。这是因为内联函数的汇编代码会在调用处展开，如果函数体过大或调用处过多，会造成代码膨胀；    </li></ul><p>内联函数在编译时会就地展开，不生成独立汇编码，<strong>不会生成函数名，所以也不会添加进符号表之中</strong>，故在文件作用域外无法调用inline函数，否则编译报错：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">undefined reference to ***<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-6、constexpr"><a href="#7-6、constexpr" class="headerlink" title="7.6、constexpr"></a>7.6、constexpr</h2><p>首先了解两个概念：</p><ul><li>编译时常量；</li><li>运行时常量；</li></ul><p>通常来讲运行时常量是指使用const修饰的对象，const可以修饰函数参数、函数返回值、函数本身、类等，在不同的使用条件下，const有不同的意义，不过大多数情况下，const描述的都是一些”运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的。</p><pre class="line-numbers language-none"><code class="language-none">const int GetConst()&#123;return 1;&#125;void Constless(int cond)&#123;    int arr[GetConst()]&#x3D;&#123;0&#125;;&#x2F;&#x2F;无法通过编译    enum&#123;e1&#x3D;GetConst(),e2&#125;;&#x2F;&#x2F;无法通过编译    switch(cond)        &#123;            case GetConst():&#x2F;&#x2F;无法通过编译            break;            default:            break;        &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组大小、枚举值和switch均是需要编译时常量。   </p><p>此时便需要常量表达式，将函数或值转换为常量表达式函数或常量表达式值，例如：</p><pre class="line-numbers language-none"><code class="language-none">constexpr int GetConst()&#123;return 1;&#125;constexpr int i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常量表达式主要是允许一些计算发生在编译时Compile-time calculation。<br>constexpr可以使代码具有编译时运算的能力，同inline关键字类似，但constexpr只是一种建议，是否发挥作用还取决于具体的调用。</p><p>constexpr可以修饰变量、函数、构造函数</p><h3 id="7-6-1、constexpr修饰函数时的限制"><a href="#7-6-1、constexpr修饰函数时的限制" class="headerlink" title="7.6.1、constexpr修饰函数时的限制"></a>7.6.1、constexpr修饰函数时的限制</h3><ul><li>函数体只能有一个return语句（C++14之后此限制放开了，只要return语句返回的是常量即可）；</li><li>只能调用其他constexpr函数；</li><li>只能使用全局constexpr变量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">constexpr int32_t getValue() &#123;return 1;&#125;constexpr int32_t getLength(int32_t i) &#123;return i + 2;&#125;constexpr int32_t getLength02(int32_t i)&#123;    i +&#x3D; 2;    return i;&#125;int main()&#123;    int32_t i &#x3D; 3;    int32_t nums01[getValue()] &#x3D; &#123;1&#125;;  &#x2F;&#x2F; ok    int32_t nums02[getLength(1)] &#x3D; &#123;3&#125;;  &#x2F;&#x2F; ok    int32_t nums03[getLength02(2)] &#x3D; &#123;4&#125;;  &#x2F;&#x2F; ok        std::cout &lt;&lt; nums01[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums02[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums03[0] &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-6-2、constexpr修饰构造函数"><a href="#7-6-2、constexpr修饰构造函数" class="headerlink" title="7.6.2、constexpr修饰构造函数"></a>7.6.2、constexpr修饰构造函数</h3><p>可以构造函数声明为constexpr，则在编译期就可以构造类对象，要求构造函数调用处传入的参数都必须是常量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Circle&#123;    public:    constexpr Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) &#123;&#125;    constexpr double getArea ()    &#123;        return _radius * _radius * 3.1415926;    &#125;    private:        int _x;        int _y;        int _radius;&#125;;constexpr Circle temCircle(0, 0, 10);  &#x2F;&#x2F; 编译期执行构造函数，计算半径为10的Circle面积<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-6-3、constexpr与const"><a href="#7-6-3、constexpr与const" class="headerlink" title="7.6.3、constexpr与const"></a>7.6.3、constexpr与const</h3><pre class="line-numbers language-none"><code class="language-none">const int i&#x3D;1;constexpr int j&#x3D;1;  &#x2F;&#x2F; 常量表达式值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大多数情况下这两种声明方式没有区别，都是将变量声明为常量，主要不同之处在于i不能用于编译期常量的场景，比如数组大小、枚举值和switch值等。</p><h2 id="7-7、mallloc-free和new-delete的区别"><a href="#7-7、mallloc-free和new-delete的区别" class="headerlink" title="7.7、mallloc/free和new/delete的区别"></a>7.7、mallloc/free和new/delete的区别</h2><ul><li>malloc/free是C语言的库函数，而new/delete是C++的关键字，故他们不能被重载，但它们的二级调用operator new / operator delete可以被重载；</li><li>malloc/free只能用于基本类型，而new/delete不但可以用于基本类型还可用于自定义类型；</li><li>malloc返回的是void*类型，需要显示转换为指定类型，new不涉及类型转换的问题；</li><li>maloc只负责申请空间，并返回首地址，new运算符除了申请空间，还调用构造函数进行初始化。free函数只负责释放空间，并标识这段空间是可用空间，delete除了释放空间，还调用析构函数；</li></ul><p>事实上，new/delete的功能已经完全覆盖了malloc/free。</p><h2 id="7-8、delete和delete-的区别"><a href="#7-8、delete和delete-的区别" class="headerlink" title="7.8、delete和delete[]的区别"></a>7.8、delete和delete[]的区别</h2><p>对于基本类型delete和delete[]没有区别，都可以正常释放单个空间或数组空间，对于数组空间，系统可以根据数组长度和数据类型计算出数组所占空间，然后一次性释放。    </p><p>但是对于自定义类型，delete只会释放数组的第一个元素，其他元素空间并不会释放，而delete[]可以循环释放数组所有元素的空间。</p><h1 id="8、异常处理"><a href="#8、异常处理" class="headerlink" title="8、异常处理"></a>8、异常处理</h1><p>异常处理机制主要包含两个部分：</p><ul><li>异常的鉴定与抛出；</li><li>异常的捕获与处理</li></ul><p>异常抛出之后，当前的执行流程会被暂停，然后在程序的全局范围内搜索可以捕获此异常的地方，异常处理完之后，程序会从异常处理点继续往下执行（<strong>不一定是抛出异常的地方</strong>）    </p><p>异常处理提供了一种转移程序控制权的方式    </p><p>程序运行时常会碰到一些异常情况，例如：</p><ul><li>做除法的时候除数为 0；</li><li>用户输入年龄时输入了一个负数；<br>*用 new 运算符动态分配空间时，空间不够导致无法分配；</li><li>访问数组元素时，下标越界；打开文件读取时，文件不存在；</li></ul><p>这些异常情况如果不能被发现并加以处理，很可能会导致程序崩溃</p><p>所谓”处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。   </p><p>一发现异常情况就立即处理未必妥当，因为在一个函数执行过程中发生的异常，在有的情况下由该函数的调用者决定如何处理更加合适。</p><p>此外，将异常分散在各处进行处理不利于代码的维护，如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</p><p>C++ 引入了异常处理机制。其基本思想是：函数A在执行过程中发现异常时可以不加处理，而只是”拋出一个异常”给 A的调用者，假定为函数B。拋出异常而不加处理会导致函数A立即中止，在这种情况下，函数B可以选择捕获A拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。</p><p>如果一层层的函数都不处理异常，异常最终会被拋给最外层的main函数。main函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p><h2 id="8-1、抛出异常"><a href="#8-1、抛出异常" class="headerlink" title="8.1、抛出异常"></a>8.1、抛出异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;异常的抛出if(a &gt; b)throw compare_class_obj(a,b);if(a &lt;&#x3D; b)......<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当a大于b的时候，异常便会以类为compare_class_obj的对象抛出。<br>所谓抛出异常(throw exception)抛出的是一个实体，这个实体可以是一个复杂的类对象，也可以是一个简单的整形或字符串</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">throw 42;throw &quot;error: no buffer&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-2、捕获异常"><a href="#8-2、捕获异常" class="headerlink" title="8.2、捕获异常"></a>8.2、捕获异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool catchOperator()&#123;    catch(int errno)    &#123;        ......    &#125;    catch(const char*str)    &#123;        ....    &#125;    catch(compare_class_obj &amp;it)    &#123;        ....    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>被抛出异常对象的类型会被拿来逐一地与catch子句对比，如果类型符合，那么该catch子句便会被执行。<br>如果想要捕获所有类型的异常，可以使用一网打尽的方式，只需要在catch中使用(…)即可</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">catch(...)    &#123;        ....    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-3、try、catch组合"><a href="#8-3、try、catch组合" class="headerlink" title="8.3、try、catch组合"></a>8.3、try、catch组合</h2><p>try和catch通常搭配使用，try语句块抛出异常，catch语句块捕获异常</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include&lt;exception&gt;using namespace std;   int main()&#123;   cout &lt;&lt; &quot;Enter number of integers you wish to reserve: &quot;;   try   &#123;      int Input &#x3D; 0;      cin &gt;&gt; Input;      &#x2F;&#x2F; Request memory space and then return it      int* pReservedInts &#x3D; new int [Input];  &#x2F;&#x2F; new操作中包含throw语句      delete[] pReservedInts;     &#125;   catch (std::bad_alloc&amp; exp)   &#123;      cout &lt;&lt; &quot;Exception encountered: &quot; &lt;&lt; exp.what() &lt;&lt; endl;      cout &lt;&lt; &quot;Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   catch(...)   &#123;      cout &lt;&lt; &quot;Exception encountered. Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>std::bad_alloc表明捕获内存申请异常</p><p><strong>==配合throw自定义异常==</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;iostream&gt;using namespace std;double Divide(double Dividend, double Divisor)&#123;   if(Divisor &#x3D;&#x3D; 0)      throw &quot;Dividing by 0 is a crime&quot;;   return (Dividend &#x2F; Divisor);&#125;int main()&#123;   cout &lt;&lt; &quot;Enter dividend: &quot;;   double Dividend &#x3D; 0;   cin &gt;&gt; Dividend;   cout &lt;&lt; &quot;Enter divisor: &quot;;   double Divisor &#x3D; 0;   cin &gt;&gt; Divisor;   try   &#123;      cout &lt;&lt; &quot;Result of division is: &quot; &lt;&lt; Divide(Dividend, Divisor);   &#125;   catch(char* exp)   &#123;      cout &lt;&lt; &quot;Exception: &quot; &lt;&lt; exp &lt;&lt; endl;      cout &lt;&lt; &quot;Sorry, can&#39;t continue!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-4、标准异常基类std-exception"><a href="#8-4、标准异常基类std-exception" class="headerlink" title="8.4、标准异常基类std::exception"></a>8.4、标准异常基类std::exception</h2><p>头文件：   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdexcept&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++提供了标准异常基类，以及一些标准异常派生类<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE79dc7e0746bf807241a0c16fb37ce99c/38324" alt="image04"></p><p>这些都是exception的派生类，当有异常发生时，即使没有显式的throw语句，也会抛出相应的异常，派生类中都会实现虚函数what，用于返回异常的描述信息</p><p>示例：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;class Base&#123;    virtual void func() &#123;&#125;&#125;;class Derived : public Base&#123;public:    void Print() &#123;&#125;&#125;;void PrintObj(Base &amp; b)&#123;    try &#123;        Derived &amp; rd &#x3D; dynamic_cast &lt;Derived &amp;&gt;(b);        &#x2F;&#x2F;此转换若不安全，会拋出 bad_cast 异常        rd.Print();    &#125;    catch (bad_cast &amp; e) &#123;        cerr &lt;&lt; e.what() &lt;&lt; endl;    &#125;&#125;int main()&#123;    Base b;    PrintObj(b);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：<br>Bad dynamic_cast!</p><p><strong>==自定义异常派生类==</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std; struct MyException : public exception&#123;  const char * what () const throw ()  &#123;    return &quot;C++ Exception&quot;;  &#125;&#125;; int main()&#123;  try  &#123;    throw MyException();  &#125;  catch(exception&amp; e)  &#123;    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：<br>MyException caught<br>C++ Exception</p><h1 id="9、类型转换"><a href="#9、类型转换" class="headerlink" title="9、类型转换"></a>9、类型转换</h1><p>C语言中的类型转换包括隐式类型转换、显式类型转换(也称作强制类型转换)，但有些情况下转换操作并不安全，比如可将指针转换成任意类型，编译是正常，而在运行期可能引发无法预估的问题。<br>C++引入了多种可供选择的类型转换方法</p><h2 id="9-1、向上转换、向下转换"><a href="#9-1、向上转换、向下转换" class="headerlink" title="9.1、向上转换、向下转换"></a>9.1、向上转换、向下转换</h2><p>具有继承关系的类之间双向转换操作：</p><ul><li>向上转换，派生类向基类转换；</li><li>向下转换，基类向派生类转换；</li></ul><h2 id="9-2、static-cast"><a href="#9-2、static-cast" class="headerlink" title="9.2、static_cast"></a>9.2、static_cast</h2><ul><li><strong>==编译期类型转换检查==</strong>,只做编译阶段检查，不会在运行阶段检查；</li><li>操作对象可以是基本类型，也可以是具有继承关系的类；</li><li>不支持不具备继承关系的类之间的转换；</li><li>普通对象变量(非指针、非引用)只能向上转换；</li><li>指针、引用对象变量支持向上、向下转换；参考：<a href="">4.9.6、对象调用成员变量、成员函数的原理</a></li><li>虽然指针、引用对象可以向下类型转换，但运行期是不安全的，可能引发不确定行为，比如空指针异常、访问未初始化的地址空间等；</li></ul><p>**==类似于c语言的显式类型转换==**，但没有显式类型转换那么暴力，不相关的类型之间转换会报错，比如没有继承关系的类之间、指针转整形操作等。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base&#123;    .......&#125;class Dev : public Base&#123;    .......&#125;class NoDev&#123;    .......&#125;int main()&#123;    char ca &#x3D; &#39;a&#39;;    int ia &#x3D; static_cast&lt;int&gt;(ca);  &#x2F;&#x2F; OK    float *pa &#x3D; static_cast&lt;float*&gt;(ca);  &#x2F;&#x2F; error        Base base01;    Dev dev01 &#x3D; static_cast&lt;Dev&gt;(base01);  &#x2F;&#x2F; error，普通对象变量不支持向下转换        Dev dev02;    Base base02 &#x3D; static_cast&lt;Base&gt;(dev02);  &#x2F;&#x2F; OK        Base *pBase &#x3D; new Base();    Dev *pDev &#x3D; new Dev();    pDev &#x3D; static_cast&lt;Dev&gt;(pBase);  &#x2F;&#x2F; OK    pBase &#x3D; static_cast&lt;Base&gt;(pDev);  &#x2F;&#x2F; OK        Base base03;    NoDev no_dev &#x3D; static_cast&lt;NoDev&gt;(base03);  &#x2F;&#x2F; error，Base与NoDev之间不存在继承关系        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-3、dynamic-static"><a href="#9-3、dynamic-static" class="headerlink" title="9.3、dynamic_static"></a>9.3、dynamic_static</h2><p>由于static_cast只在编译阶段检查，继承类之间向下类型转换在运行期存在不安全行为，dynamic_static可以执行运行期检查</p><ul><li>运行期类型转换检查；</li><li>只针对类的指针、引用对象，不支持普通对象、基础类型；</li><li>可以实现运行期安全的向下类型转换操作；</li><li>类指针向下转换失败返回nullptr，类引用向下转换失败返回bad_cast异常;</li><li>支持向上转化，但由于向上转换本来就是安全的，考虑到dynamic_static比较耗时，故向上类型转换不建议使用dynamic_static；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stdafx.h&quot;#include&lt;iostream&gt;using namespace std;class Base&#123;public:    Base()&#123;&#125;;    virtual void Show()&#123;cout&lt;&lt;&quot;This is Base calss&quot;;&#125;&#125;;class Derived:public Base&#123;public:    Derived()&#123;&#125;;    void Show()&#123;cout&lt;&lt;&quot;This is Derived class&quot;;&#125;&#125;;int main()&#123;    &#x2F;&#x2F; ************************类指针    Base* base &#x3D; new Derived();    if(Derived *der&#x3D; dynamic_cast&lt;Derived*&gt;(base))  &#x2F;&#x2F; OK，因为Base指针本来就指向继承类    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der-&gt;Show();        cout&lt;&lt;endl;    &#125;        Base * base1 &#x3D; new Base;    if(Derived *der1 &#x3D; dynamic_cast&lt;Derived*&gt;(base1))  &#x2F;&#x2F; error，向下转换失败    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der1-&gt;Show();    &#125;    else     &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;    delete(base);    delete(base1);        &#x2F;&#x2F; ************************类引用    Derived b ;    Base &amp;base1&#x3D; b;    Derived &amp;der1 &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base1);  &#x2F;&#x2F; OK    Base a ;    Base &amp;base &#x3D; a ;    try&#123;        Derived &amp; der &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base);  &#x2F;&#x2F; error    &#125;    catch(bad_cast)    &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-4、reinterpret-cast"><a href="#9-4、reinterpret-cast" class="headerlink" title="9.4、reinterpret_cast"></a>9.4、reinterpret_cast</h2><ul><li>只支持指针、引用的类型转换操作；</li></ul><p>可以将指针、引用转换成不相关的类型，包括基础类型、没有继承关系的类；<br>与C语言最接近的类型转换符，用于强制转换，通常在较低级的程序中使用</p><h2 id="9-5、const-cast"><a href="#9-5、const-cast" class="headerlink" title="9.5、const_cast"></a>9.5、const_cast</h2><ul><li>增加或修改类型限定符const;</li><li>只支持指针、引用的类型转换操作；</li><li>只能修改类型限定符，不能更改基础类型，即向上、向下转换，比如Derived *转换成const Base *是不允许的；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">const Base *base01 &#x3D; new Base();Base *base02 &#x3D; const_cast&lt;Base*&gt;(base01);const Base * const base03 &#x3D; new Base();Base *base04 &#x3D; const_cast&lt;Base*&gt;(base03);Base *base05 &#x3D; new Base();const Base *base06 &#x3D; const_cast&lt;const Base*&gt;(base05);const Detived *dev01 &#x3D; new Derived();Base *base02 &#x3D; const_cast&lt;Base*&gt;(dev01);  &#x2F;&#x2F; error，不允许改变基础类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="10、类型推导"><a href="#10、类型推导" class="headerlink" title="10、类型推导"></a>10、类型推导</h1><p>通常C和C+被称作静态类型语言，因为数据类型必须显示声明，而例如python、javascrip等被称作动态语言，它们的变量可以不指定类型，在编译阶段会自动推导。<br>C++中类型推导主要应用在模板、auto、decltype之中，模板的类型推导是基于auto演变而来，auto用于类型推导，而decltype用于获取类型</p><h2 id="10-1、模板类型推导"><a href="#10-1、模板类型推导" class="headerlink" title="10.1、模板类型推导"></a>10.1、模板类型推导</h2><p>模板函数伪代码：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(ParamType para);func(expr);  &#x2F;&#x2F; 以表达式expr创建模板函数实例<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在编译期编译器会通过expr（也可以理解成实参）推导两个型别：</p><ul><li>模板类型T的型别；</li><li>函数形参ParamType（也可以理解错形参）的型别；</li></ul><p>T与ParamType之间的关系要视具体情况而言，比如：   </p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(const T&amp; para);int x &#x3D; 0;func(x);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>T被推导为int，ParamType被推导为const int&amp;。<br>我们很自热的认为T的型别与传入的实参expr型别是一样的，其实这一点并不总是成立，T的型别推导不仅仅依赖于expr，还依赖于ParaType，具体可分为以下三种情况讨论：   </p><ul><li>ParamType具有指针或引用型别，但不是个万能引用；</li><li>ParamType是个万能引用；</li><li>ParamType既非指针也非引用；</li></ul><p><font color=red><strong>此三种场景均遵循如下类型推导规则:</strong></font></p><ul><li>根据实参确定形参的类型；</li><li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li><li>模式匹配出T及ParamType类型；</li></ul><h3 id="10-1-1、ParamType是个指针或引用，但不是万能引用"><a href="#10-1-1、ParamType是个指针或引用，但不是万能引用" class="headerlink" title="10.1.1、ParamType是个指针或引用，但不是万能引用"></a>10.1.1、ParamType是个指针或引用，但不是万能引用</h3><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>func(x)中实参x传递给形参T&amp;，可确定ParamType类型是int &amp;，然后模式匹配结果T为int；</li><li>func(cx)中cx是const int，传递给形参T&amp;，func形参的意图是作为实参的引用，此时实参具备const性，即不希望后续操作中其值被修改，而且此时实参是按照引用传递的，那么便可确定ParamType类型是const int &amp;，T类型是const int;</li><li>func(rx)推导规则同样；</li></ul><p><font color=purple>当向引用型别的形参传入const对象时，他们期望该对象保持其不可被修改的属性，这也就是为何向持有T&amp;的型别模板传入const对象是安全的。 </font>   </p><p>若将模板中的T&amp;改成cosnt T&amp;，推导结果会略有不同：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(cosnt T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是const int&amp;func(cx);  &#x2F;&#x2F; T是int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于ParamType已经具有const属性，故模式匹配时T不会包含const属性。    </p><p>若将T&amp;换成指针T*，推导结果基本相同：  </p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T* para);int x &#x3D; 27;const int *px &#x3D; &amp;x;func(&amp;x);   &#x2F;&#x2F; T是int， para是int*func(px);   &#x2F;&#x2F; T是const int，  para是const int*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-1-2、ParamType是个万能引用"><a href="#10-1-2、ParamType是个万能引用" class="headerlink" title="10.1.2、ParamType是个万能引用"></a>10.1.2、ParamType是个万能引用</h3><p>模板类型推导遵循引用折叠规则，详见<strong>5.6</strong>节</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp;&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int&amp;， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(27);  &#x2F;&#x2F; T是int， para是int&amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-1-3、ParamType既非指针也非引用"><a href="#10-1-3、ParamType既非指针也非引用" class="headerlink" title="10.1.3、ParamType既非指针也非引用"></a>10.1.3、ParamType既非指针也非引用</h3><p>当ParamType即非指针也非引用时，它想表达的意图是接收实参的一个副本，也即一个全新对象。ParamType会是一个全新对象这一事实促成了如何从expr推导出T的型别规则：</p><ul><li>若实参具有引用型别，则形参是想借由实参构造一个全新的对象，故引用型别不被保留，若实参是指针类型，则实参传递的是指针的副本，指针* 会被保留；</li><li>由于实参传递给形参是一个副本，故const属性不会被保留；</li><li>特例：实参const T *、T const *的const会保留，是因为这里的const修饰的是指针指向的对象，并不是指针自身，所以T *const不会保留const属性；</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参为非指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是int，  para是intfunc(rx);  &#x2F;&#x2F; T是int，  para是int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即使cx和rx代表const值，para仍然不具有const型别，因为para是个完全独立于cx和rx存在的对象，从而cx和rx的不可修改属性并不会传递给para。       </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参是指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int *cx &#x3D; &amp;x;int * const cx02 &#x3D; &amp;x;int *rx &#x3D; &amp;x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是const int *，  para是const int *func(cx02);  &#x2F;&#x2F; T是int *，  para是int *func(rx);  &#x2F;&#x2F; T是int *，  para是int *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-2、auto类型推导"><a href="#10-2、auto类型推导" class="headerlink" title="10.2、auto类型推导"></a>10.2、auto类型推导</h2><p>auto类型推导表达式在编译时确定变量类型，auto所修饰的变量必须被初始化<br>推导规则与模板类型推导遵循如下规则：</p><ul><li>根据实参确定形参的类型；</li><li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li><li>模式匹配出T及ParamType类型；</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;auto *a &#x3D; &amp;x;  &#x2F;&#x2F;a-&gt;int *auto b &#x3D; &amp;x;   &#x2F;&#x2F;b-&gt;int *auto &amp;c&#x3D; x;    &#x2F;&#x2F;c-&gt;int &amp;auto d&#x3D;c;      &#x2F;&#x2F;d-&gt;intconst auto e &#x3D; x;  &#x2F;&#x2F;e-&gt;const intauto f &#x3D; e;        &#x2F;&#x2F;f-&gt;intconst auto&amp;g &#x3D; x;  &#x2F;&#x2F;g-&gt;const int &amp;auto&amp; h &#x3D; g;   &#x2F;&#x2F;h-&gt;const int&amp; const int *j &#x3D; &amp;x;auto k &#x3D; j;  &#x2F;&#x2F; k-&gt;const int *int *const m &#x3D; &amp;x;auto n &#x3D; m;  &#x2F;&#x2F; n-&gt;int *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=red><strong>特殊示例:</strong></font>  </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto x &#x3D; 5;   &#x2F;&#x2F; intauto pi &#x3D; new auto(1);  &#x2F;&#x2F;int *const auto *v&#x3D;&amp;x, u &#x3D; 6;  &#x2F;&#x2F;v是const int*, u是const intstatic auto y &#x3D; 0.0;  &#x2F;&#x2F;doubleauto yt&#123;1&#125;;  &#x2F;&#x2F;使用初始化列表的auto，auto被推导出初始化列表容器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当经过v推导出auto为int之后，u仍然需要显示指定为6，以防在经过u推导时，auto出现二义性，比如u=6.0，编译器就会报错。<br>auto不能代表一个实际的类型声明，而是一个类型的占位符，在编译期间替换为真正的类型，使用auto必须马上初始化。</p><p>数组形式的大括号初始化auto推导，详见<strong>10.3.3</strong>节</p><h3 id="10-2-1、auto的限制"><a href="#10-2-1、auto的限制" class="headerlink" title="10.2.1、auto的限制"></a>10.2.1、auto的限制</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;void func(auto a &#x3D; 1);  &#x2F;&#x2F;error:auto不能用于函数参数struct Foo&#123;auto var1_ &#x3D; 0;  &#x2F;&#x2F;error:auto不能用于非静态成员变量static const auto var2_ &#x3D; 0;&#125;;template &lt;typename T&gt;struct Bar &#123;&#125;;int main(void)&#123;int arr[10] &#x3D; &#123;0&#125;;auto aa &#x3D; arr;  &#x2F;&#x2F;OK: aa -&gt; int *，数组名arr退化成指针auto rr[10] &#x3D; arr;  &#x2F;&#x2F;error:auto无法定义数组Bar&lt;int&gt; bar;Bar&lt;auto&gt; bb &#x3D; bar;  &#x2F;&#x2F;error:auto无法推导出模板参数system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>auto不能用于函数参数的类型推导，即使有默认值也不行；</li><li>auto不能用于非静态成员变量的类型推导（仅针对于结构体和类中的成员，即使有默认值也不行），同时仅能用于推导static const的整型或枚举成员；</li><li>auto不能用于数组类型推导；</li><li>auto不能用于模板参数类型推导；</li></ul><h2 id="10-3、decltype"><a href="#10-3、decltype" class="headerlink" title="10.3、decltype"></a>10.3、decltype</h2><p>auto声明的变量必须要初始化，而有时我们仅仅只是想知道表达式的类型，可以使用decltype来实现，它的推导过程也是在编译期完成。   </p><p>decltype获取数据类型的规则通常是所见即所得，但也有例外，特殊情况包括const限定符、函数返回值类型、重载函数、标记符表达式等，详见<strong>10.3.2</strong>节</p><h3 id="10-3-1、示例"><a href="#10-3-1、示例" class="headerlink" title="10.3.1、示例"></a>10.3.1、示例</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;decltype(x) y&#x3D;1;   &#x2F;&#x2F;y-&gt;intdecltype(x + y) z&#x3D;1;   &#x2F;&#x2F;z-&gt;intconst int &amp;i &#x3D; x;decltype(i) j&#x3D;y;   &#x2F;&#x2F;j-&gt;const int&amp;const int* k &#x3D; &amp;x;decltype(k) p &#x3D; 20;   &#x2F;&#x2F;p-&gt;const int *int * const m &#x3D; &amp;x;decltype(m) n &#x3D; 30;   &#x2F;&#x2F;p-&gt;int *constint func_int(void);decltype(func_int) f_01;  &#x2F;&#x2F; f_01-&gt;int (*)(void)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-3-2、特例"><a href="#10-3-2、特例" class="headerlink" title="10.3.2、特例"></a>10.3.2、特例</h3><h4 id="1、decltype与函数返回值"><a href="#1、decltype与函数返回值" class="headerlink" title="1、decltype与函数返回值"></a>1、decltype与函数返回值</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int value &#x3D; 20;const int func_int(void);const int * func_int_ptr_01(void);int * const func_int_ptr_02(void);decltype(func_int()) f&#x3D;0;   &#x2F;&#x2F;f-&gt;intdecltype(func_int_ptr_01()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;const int*decltype(func_int_ptr_02()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;int*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数返回值的const传递性规则与auto、模板参数类型推导规则一样，需要考虑是按值传递还是按地址传递。函数返回值换成引用类型，规则同样适用</p><h4 id="2、decltype与重载函数"><a href="#2、decltype与重载函数" class="headerlink" title="2、decltype与重载函数"></a>2、decltype与重载函数</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int func_int(void);int func_int(int value)decltype(func_int) f_01;  &#x2F;&#x2F; error，由于func_int是重载函数，decltype无法知晓需要获取哪一个函数的类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3、decltype与多重指针符号、引用符号、const"><a href="#3、decltype与多重指针符号、引用符号、const" class="headerlink" title="3、decltype与多重指针符号、引用符号、const"></a>3、decltype与多重指针符号、引用符号、const</h4><pre class="line-numbers language-none"><code class="language-none">#include ＜type_traits＞#include ＜iostream＞using namespace std;int i&#x3D;1;int＆j&#x3D;i;int*p&#x3D;＆i;const int k&#x3D;1;int main()&#123;decltype(i)＆var1&#x3D;i;  &#x2F;&#x2F; var1-&gt;int &amp;decltype(j)＆var2&#x3D;i;  &#x2F;&#x2F;多余的＆被忽略, var2-&gt;int &amp;cout＜＜is_lvalue_reference＜decltype(var1)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用cout＜＜is_rvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;0,不是右值引用cout＜＜is_lvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用decltype(p)*var3&#x3D;＆i;  &#x2F;&#x2F;无法通过编译,var3的类型是int**decltype(p)*var3&#x3D;＆p;  &#x2F;&#x2F;var3的类型是int**auto*v3&#x3D;p;&#x2F;&#x2F;v3的类型是int*v3&#x3D;＆i;const decltype(k)var4&#x3D;1;&#x2F;&#x2F;冗余的const被忽略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表达式中多余的引用符号、const会被忽略，而指针符号会被保留</p><h4 id="4、decltype与标记符表达式"><a href="#4、decltype与标记符表达式" class="headerlink" title="4、decltype与标记符表达式"></a>4、decltype与标记符表达式</h4><p>绝大多数时刻decltype都是平易近人的，但有时候也会让人疑惑，比如：</p><pre class="line-numbers language-none"><code class="language-none">int i;decltype(i)a;&#x2F;&#x2F;a:intdecltype((i))b;&#x2F;&#x2F;b:int＆,无法编译通过<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为decltype具有以下四规则，不过需要先了解什么是<strong>标记符表达式</strong>：<br>基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier） 。 而单个标记符对应的表达式就是标记符表达式。比如程序员定义了：</p><pre class="line-numbers language-none"><code class="language-none">int arr[4];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么arr是一个标记符表达式， 而arr[3]+0,arr[3]等， 则都不是标记符表达式。   </p><ul><li><strong>规则一</strong>：如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。 此外， <strong>如果e是一个被重载的函数</strong>， 则会导致编译时错误；</li><li><strong>规则二</strong>：否则， 假设e的类型是T， 如果e是一个将亡值(xvalue)， 那么decltype(e)为T＆＆；</li><li><strong>规则三</strong>：否则， 假设e的类型是T， 如果e是一个左值， 则decltype(e)为T＆；</li><li><strong>规则四</strong>：否则， 假设e的类型是T， 则decltype(e)为T；</li></ul><p>这样便可解释上面的int i例子，由于(i)不是一个标记符表达式，而却是一个左值表达式（可以有具名的地址） ， 因此， 按照decltype推导规则3， 其类型应该是一个int的引用，所以b必须同时初始化。</p><pre class="line-numbers language-none"><code class="language-none">int i&#x3D;4;int arr[5]&#x3D;&#123;0&#125;;int*ptr&#x3D;arr;struct S&#123;double d;&#125;s;void Overloaded(int);void Overloaded(char);&#x2F;&#x2F;重载的函数int＆＆RvalRef();const bool Func(int);&#x2F;&#x2F;规则1:单个标记符表达式以及访问类成员， 推导为本类型decltype(arr)var1;&#x2F;&#x2F;int[5],标记符表达式decltype(ptr)var2;&#x2F;&#x2F;int*,标记符表达式decltype(s.d)var4;&#x2F;&#x2F;double,成员访问表达式decltype(Overloaded)var5;&#x2F;&#x2F;无法通过编译， 是个重载的函数&#x2F;&#x2F;规则2:将亡值， 推导为类型的右值引用decltype(RvalRef())var6&#x3D;1;&#x2F;&#x2F;int＆＆&#x2F;&#x2F;规则3:左值， 推导为类型的引用decltype(true?i:i)var7&#x3D;i;&#x2F;&#x2F;int＆,三元运算符， 这里返回一个i的左值decltype((i))var8&#x3D;i;&#x2F;&#x2F;int＆,带圆括号的左值decltype(++i)var9&#x3D;i;&#x2F;&#x2F;int＆,++i返回i的左值decltype(arr[3])var10&#x3D;i;&#x2F;&#x2F;int＆[]操作返回左值decltype(*ptr)var11&#x3D;i;&#x2F;&#x2F;int＆*操作返回左值decltype(&quot;lval&quot;)var12&#x3D;&quot;lval&quot;;&#x2F;&#x2F;const char(＆)[9],字符串字面常量为左值&#x2F;&#x2F;规则4： 以上都不是， 推导为本类型decltype(1)var13;&#x2F;&#x2F;int,除字符串外字面常量为右值decltype(i++)var14;&#x2F;&#x2F;int,i++返回右值decltype((Func(1)))var15;&#x2F;&#x2F;const bool,圆括号可以忽略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处顺便可以理解，前置++ 与后置++的区别，前置++是一个左值，后置++是一个表达式，需要返回一个临时值</p><h2 id="10-4、数组与类型推导"><a href="#10-4、数组与类型推导" class="headerlink" title="10.4、数组与类型推导"></a>10.4、数组与类型推导</h2><h3 id="10-4-1、数组常规推导"><a href="#10-4-1、数组常规推导" class="headerlink" title="10.4.1、数组常规推导"></a>10.4.1、数组常规推导</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T param);const char name[13] &#x3D; &quot;abcddftg&quot;;func(name);  &#x2F;&#x2F; T是const char *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>T被推导成const char *而不是const char [13]，因为：</p><ul><li>数组到指针的退化规则，name的const char [13]退化成了const char *；</li><li>也可以理解成函数无法声明真正意义上的数组形参；    </li></ul><h3 id="10-4-2、数组引用类型推导"><a href="#10-4-2、数组引用类型推导" class="headerlink" title="10.4.2、数组引用类型推导"></a>10.4.2、数组引用类型推导</h3><p><strong>难点来了</strong>：<br>虽然函数无法声明真正意义上的数组形参，但却可以将形参声明成数组的引用</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(T&amp; param);const char name[13] &#x3D; &quot;abcddftg&quot;;f(name);  &#x2F;&#x2F; T是const char [13], param是const char (&amp;)[13]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里需要注意参考2.7.1的情形，此时ParamType是个引用类型，传入的是个数组const char [13]，这里的const性便得以保留。    </p><p><strong>实际应用</strong>：<br>可以利用这个功能创造出一个模板，用来推导出数组含有的元素数：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以编译期常量的形式返回数组尺寸template&lt;typename T, std::size_t N&gt;constpxer std::size_t arraySize(T (&amp;)[N]) nonexcept&#123;    return N;&#125;int keyVals[] &#x3D; &#123;1,3,7,9&#125;;int mappedVals[arraySize(keyVals)];  &#x2F;&#x2F; mappedVals被指定为与keyVals一样大小的数组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-4-3、数组初始化形式作为实参的类型推导"><a href="#10-4-3、数组初始化形式作为实参的类型推导" class="headerlink" title="10.4.3、数组初始化形式作为实参的类型推导"></a>10.4.3、数组初始化形式作为实参的类型推导</h3><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;int x(27);int x &#x3D; &#123;27&#125;;int x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上是四种初始表达式，都可以将x初始化为27，但在以初始化形式发生auto类型推导时情况略有不同：</p><pre class="line-numbers language-none"><code class="language-none">auto x &#x3D; 27;auto x(27);auto x &#x3D; &#123;27&#125;;auto x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前两个没有问题，可以正常初始化x为int，值为27，但后两个会将x初始化为std::initializer_list<int>类型，且包含单个值27<br>，这是因为在auto推导时会将大括号推导为std::initializer_list<int>类型，而模板推导中就会失败，因为模板不支持这种推导形式：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T name);func(&#123;1,2,3&#125;);  &#x2F;&#x2F; 错误，无法推导T的型别<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过，若指定该模板中param为std::initializer_list<T>类型，则可以推导出T的型别：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; name);f(&#123;1,2,3&#125;);  &#x2F;&#x2F; T被推导为int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="11、std-string类"><a href="#11、std-string类" class="headerlink" title="11、std::string类"></a>11、std::string类</h1><p>传统字符数组的缺点：</p><ul><li>普通字符数组的长度在编译期已固定，不可更改；</li><li>动态申请的字符数组虽然可以按需分配空间，但当扩容时内存空间需要销毁重建；</li><li>char *在浅复制时易出现内存泄漏、double free等问题；</li></ul><h2 id="11-1、初始化"><a href="#11-1、初始化" class="headerlink" title="11.1、初始化"></a>11.1、初始化</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    &#x2F;&#x2F; char * To std::string    const char * c_string &#x3D; &quot;Hello world!&quot;;    std::string str01 &#x3D; &quot;Hello world!&quot;;  &#x2F;&#x2F; copy constructor    std::string str02 &#x3D; c_string;  &#x2F;&#x2F; copy constructor    std::string str03(c_string);  &#x2F;&#x2F; default constructor    std::string str04;    str04 &#x3D; c_string;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n01: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str01 &lt;&lt; &quot;\n&quot; &lt;&lt; str02 &lt;&lt; &quot;\n&quot; &lt;&lt; str03  &lt;&lt; &quot;\n&quot; &lt;&lt; str04 &lt;&lt; std::endl;    &#x2F;&#x2F; std::string To std::string    std::string str_str &#x3D; &quot;Everything is OK!&quot;;    std::string str05 &#x3D; str_str;  &#x2F;&#x2F; copy constructor    std::string str06(str05);  &#x2F;&#x2F; defalut constructor    std::string str07;    str07 &#x3D; str_str;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n02: &quot; &lt;&lt; str_str &lt;&lt; &quot;\n&quot; &lt;&lt; str05 &lt;&lt; &quot;\n&quot; &lt;&lt; str06 &lt;&lt; &quot;\n&quot; &lt;&lt; str07 &lt;&lt; std::endl;    &#x2F;&#x2F; member function    &#x2F;&#x2F; function: *_copy_*(source, begin_pos, len)， 指定位置开始复制    std::string str08(c_string,2,10);  &#x2F;&#x2F; str08 &#x3D; &quot;llo world!&quot;&quot;    std::string str09(c_string,2);  &#x2F;&#x2F; str09 &#x3D; &quot;He&quot; copy len &#x3D; 2 from begin pos    std::string str10(str_str,2,15);  &#x2F;&#x2F; str10 &#x3D; &quot;erything is OK!&quot;&quot;    std::string str11(str_str,2);  &#x2F;&#x2F; str11 &#x3D; &quot;erything is OK!&quot; copy from 2th pos to end pos    std::cout &lt;&lt; &quot;\n03: &quot; &lt;&lt; str08 &lt;&lt; &quot;\n&quot; &lt;&lt; str09 &lt;&lt; &quot;\n&quot; &lt;&lt; str10 &lt;&lt; &quot;\n&quot; &lt;&lt; str11 &lt;&lt; std::endl;    &#x2F;&#x2F; function: *_copy_*(begin_pos, end_pos), 区间复制    std::string str12(c_string + 2, c_string + 8);  &#x2F;&#x2F; str12 &#x3D; &quot;llo wo&quot;    std::string str13(c_string + 2);  &#x2F;&#x2F; str13 &#x3D; &quot;llo world!&quot;    std::cout &lt;&lt; &quot;\n04: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str12 &lt;&lt; &quot;\n&quot; &lt;&lt; str13 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Hello world!Hello world!Hello world!Hello world!Hello world!02: Everything is OK!Everything is OK!Everything is OK!Everything is OK!03: llo world!Heerything is OK!erything is OK!04: Hello world!llo wollo world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-2、访问"><a href="#11-2、访问" class="headerlink" title="11.2、访问"></a>11.2、访问</h2><ul><li>类数组下标形式访问；</li><li>C风格指针形式访问；</li><li>迭代器形式访问</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    &#x2F;&#x2F; 数组下标形式    for (int32_t i &#x3D; 0; i &lt; str_str.length(); ++i) &#123;        std::cout &lt;&lt; str_str[i];    &#125;        &#x2F;&#x2F; C风格指针    const char *c_string &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\n\n&quot; &lt;&lt; c_string &lt;&lt; std::endl;    &#x2F;&#x2F; 迭代器    std::cout &lt;&lt; &quot;\n&quot;;    for (auto iter &#x3D; str_str.begin(); iter !&#x3D; str_str.end(); ++iter) &#123;        std::cout &lt;&lt; *iter;    &#125;    std::cout &lt;&lt; &quot;\n&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-3、拼接"><a href="#11-3、拼接" class="headerlink" title="11.3、拼接"></a>11.3、拼接</h2><ul><li>拼接符：+=、+</li><li>appen函数</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str01 &#x3D; &quot;Hello&quot;;    std::string str_str02 &#x3D; &quot; world!&quot;;    std::string str_str03 &#x3D; str_str01 + str_str02;    std::string str_str04 &#x3D; str_str01.append(str_str02);    std::string str_str05 &#x3D; &quot;Everybody, &quot; + str_str03;    std::cout &lt;&lt; str_str03 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str04 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str05 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-4、查找"><a href="#11-4、查找" class="headerlink" title="11.4、查找"></a>11.4、查找</h2><p>查找相关的函数：</p><ul><li>find</li><li>find_first_of</li><li>find_first_not_of</li><li>find_last_of</li><li>find_last_not_of</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;every body is everybody&quot;;    std::string str_obj &#x3D; &quot;everybody&quot;;    size_t pos01 &#x3D; str_str.find(str_obj, 2);    size_t pos02 &#x3D; str_str.find(str_obj);    size_t pos03 &#x3D; str_str.find_first_of(str_obj, 2);    size_t pos04 &#x3D; str_str.find_first_of(str_obj);    size_t pos05 &#x3D; str_str.find_first_not_of(str_obj);    size_t pos06 &#x3D; str_str.find_last_of(str_obj);    size_t pos07 &#x3D; str_str.find_last_of(str_obj, 2);    size_t pos08 &#x3D; str_str.find_last_not_of(str_obj);    std::cout &lt;&lt; pos01 &lt;&lt; &quot;  &quot; &lt;&lt; pos02 &lt;&lt; &quot;  &quot;  &lt;&lt; pos03 &lt;&lt; &quot;  &quot;  &lt;&lt; pos04 &lt;&lt; &quot;  &quot;     &lt;&lt; pos05 &lt;&lt; &quot;  &quot;  &lt;&lt; pos06 &lt;&lt; &quot;  &quot;  &lt;&lt; pos07 &lt;&lt; &quot;  &quot;  &lt;&lt; pos08 &lt;&lt; std::endl;        &#x2F;&#x2F; 迭代器    auto iter &#x3D; find(str_str.begin(), str_str.end(), &#39;e&#39;);  &#x2F;&#x2F; 第三个参数如果是std::string类型会报错，因为str_str的iteration是字符，字符与字符串是无法match    if (iter !&#x3D; str_str.end()) &#123;        std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;Has been found&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">14  14  2  0  5  22  2  13Has been found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>find_first_of/find_last_of查找规则是如果str_str中含有str_obj中的任何字符，则就会查找成功，而find则是要完全匹配；</p><h2 id="11-5、截短"><a href="#11-5、截短" class="headerlink" title="11.5、截短"></a>11.5、截短</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    str_str.erase(3, 7);  &#x2F;&#x2F; 从第3位开始删除7个字符，遇到字符串结尾结束    std::cout &lt;&lt; &quot;01: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    str_str.erase(2);  &#x2F;&#x2F; 遇到字符串结尾结束    std::cout &lt;&lt; &quot;02: &quot; &lt;&lt; str_str &lt;&lt; std::endl;        str_str.erase(str_str.begin(), str_str.end());    std::cout &lt;&lt; &quot;03: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#x2F;&#x2F; 删除指定字符    str_str &#x3D; &quot;Hello world!&quot;;    size_t pos &#x3D; str_str.find(&#39;H&#39;);    if (pos !&#x3D; str_str.npos) &#123;        str_str.erase(pos, 1);        std::cout &lt;&lt; &quot;04: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    auto iter &#x3D; std::find(str_str.begin(), str_str.end(), &#39;w&#39;);    if (iter !&#x3D; str_str.end()) &#123;        str_str.erase(iter);        std::cout &lt;&lt; &quot;05: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Held!02: He03:04: ello world!05: ello orld!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-6、获取子字符串std-substr"><a href="#11-6、获取子字符串std-substr" class="headerlink" title="11.6、获取子字符串std::substr"></a>11.6、获取子字符串std::substr</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string targt &#x3D; &quot;Hello,world!&quot;;        int nComma &#x3D; targt.find(&#39;,&#39;);    if (nComma !&#x3D; std::string::npos)    &#123;    std::string keywordSegmt_1 &#x3D; targt.substr(0, nComma);    std::cout &lt;&lt; &quot;test 1  &quot; &lt;&lt; keywordSegmt_1 &lt;&lt; std::endl;        std::string keywordSegmt_2 &#x3D; targt.substr(nComma + 1, targt.length() - 1 - nComma);    std::cout &lt;&lt; &quot;test 2  &quot; &lt;&lt; keywordSegmt_2 &lt;&lt; std::endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">test 1  Hellotest 2  world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-7、翻转std-reverse"><a href="#11-7、翻转std-reverse" class="headerlink" title="11.7、翻转std::reverse"></a>11.7、翻转std::reverse</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;int main()&#123;    using namespace std;    string strSample (&quot;Hello String!&quot;);    cout &lt;&lt; &quot;The original sample string is: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl &lt;&lt; endl;     reverse (strSample.begin (), strSample.end ());     cout &lt;&lt; &quot;After applying the std::reverse algorithm: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl;     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">The original sample string is: Hello String!After applying the std::reverse algorithm: !gnirtS olleH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-8、大小写转换transform、toupper、tolower"><a href="#11-8、大小写转换transform、toupper、tolower" class="headerlink" title="11.8、大小写转换transform、toupper、tolower"></a>11.8、大小写转换transform、toupper、tolower</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;cctype&gt;#include &lt;algorithm&gt;int main ()&#123;    std::string strInput &#x3D; &quot;Hello world!&quot;;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::toupper);  &#x2F;&#x2F; ::toupper为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to upper case is: &quot; &lt;&lt;std:: endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::tolower);  &#x2F;&#x2F; ::tolower为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to lower case is: &quot; &lt;&lt; std::endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">The string converted to upper case is: HELLO WORLD!The string converted to lower case is: hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-9、字符串与其他类型转换"><a href="#11-9、字符串与其他类型转换" class="headerlink" title="11.9、字符串与其他类型转换"></a>11.9、字符串与其他类型转换</h2><h3 id="11-9-1、实数转字符串"><a href="#11-9-1、实数转字符串" class="headerlink" title="11.9.1、实数转字符串"></a>11.9.1、实数转字符串</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 普通字符串std::string to_string(int);std::string to_string(long);std::string to_string(long long);std::string to_string(unsigned);std::string to_string(unsigned long);std::string to_string(unsigned long long);std::string to_string(float);std::string to_string(double);std::string to_string(long double);&#x2F;&#x2F; 宽字符串std::wstring to_wstring(int);std::wstring to_wstring(long);std::wstring to_wstring(long long);std::wstring to_wstring(unsigned);std::wstring to_wstring(unsigned long);std::wstring to_wstring(unsigned long long);std::wstring to_wstring(float);std::wstring to_wstring(double);std::wstring to_wstring(long double);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以使用C函数snprintf</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int snprintf(char *str, size_t size, const char *format, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main ()&#123;    int32_t int_str &#x3D; 123456;    char c_string[20];    snprintf(c_string, 20 - 1, &quot;%09d&quot;, int_str);    std::cout &lt;&lt; &quot;string is: &quot; &lt;&lt; c_string &lt;&lt; &quot;\nint string is: &quot; &lt;&lt; int_str &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">string is: 000123456int string is: 123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将int_str按照format格式转化成字符串，可以指定字符串的长度为9，不足的部分使用字符’0’填充，末尾自动添加\0，然后将转换结果放入c-string之中，成功则返回写入的字符串长度，失败返回负值</p><h3 id="11-9-2、字符串转实数"><a href="#11-9-2、字符串转实数" class="headerlink" title="11.9.2、字符串转实数"></a>11.9.2、字符串转实数</h3><pre class="line-numbers language-none"><code class="language-none">int std::atoi(const char*);long std::atol(const char*);long long std::atoll(const char*);float std::atof(const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果需要转换的字符串起始部分不是数字，返回0，如果是空格，会被忽略掉。</p><pre class="line-numbers language-none"><code class="language-none">long int strtol(const char* nptr, char **endptr, int base);long long int strtoll(const char* nptr, char **endptr, int base);unsigned long int strtoul(const char* nptr, char **endptr, int base);unsigned long long int strtoull(const char* nptr, char **endptr, int base);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将参数nptr按照base的格式转化成整形<br>base是0-36，代表进制，函数会扫描参数nptr，跳过前面的空格字符串，直到遇上数字或正负符号才开始转换(如果是不合法字符，直接退出)，再遇到非数字或字符串结束符停止转换，若endptr不为NULL，则会将遇到的不符合条件而终止的nptr中的字符指针返回。<br>如果base=0，则根据字符串起始部分是0还是0x来判断转换成8进制还是16进制，如果都不是默认转换成10进制</p><pre class="line-numbers language-none"><code class="language-none">using namespace std;int main()&#123;    char *endptr;    char nptr[]&#x3D;&quot;123abc&quot;;    int ret &#x3D; strtol(nptr, &amp;endptr, 10 );    cout &lt;&lt; &quot;*****01*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr &#x3D; &quot;&lt;&lt;endptr&lt;&lt;endl;    char *endptr2;    char nptr2[]&#x3D;&quot; \t    abc&quot;;    ret &#x3D; strtol(nptr2, &amp;endptr2, 10 );     cout &lt;&lt; &quot;\n*****02*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr2 &#x3D; &quot;&lt;&lt;endptr2&lt;&lt;endl;    char *endptr8;    char nptr8[]&#x3D;&quot;0123&quot;;    ret &#x3D; strtol(nptr8, &amp;endptr8,0);     cout &lt;&lt; &quot;\n*****03*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr8 &#x3D; &quot;&lt;&lt;endptr8&lt;&lt;endl;       char *endptr16;    char nptr16[]&#x3D;&quot;0x123&quot;;    ret &#x3D; strtol(nptr16, &amp;endptr16,0);     cout &lt;&lt; &quot;\n*****04*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr16 &#x3D; &quot;&lt;&lt;endptr16&lt;&lt;endl;       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">*****01*****ret &#x3D; 123endptr &#x3D; abc*****02*****ret &#x3D; 0endptr2 &#x3D;      abc*****03*****ret &#x3D; 83endptr8 &#x3D; *****04*****ret &#x3D; 291endptr16 &#x3D; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11-9-3、stringstream类"><a href="#11-9-3、stringstream类" class="headerlink" title="11.9.3、stringstream类"></a>11.9.3、stringstream类</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sstream&gt;using namespace std;int main()&#123;   int32_t int_input &#x3D; 6789;   stringstream converterStream01;   converterStream01 &lt;&lt; int_input;    string str_output;   converterStream01 &gt;&gt; str_output;   cout &lt;&lt; &quot;Integer Input &#x3D; &quot; &lt;&lt; int_input &lt;&lt; endl;   cout &lt;&lt; &quot;String gained from integer, strInput &#x3D; &quot; &lt;&lt; str_output &lt;&lt; endl;   std::string str_input &#x3D; str_output;   stringstream converterStream02;   converterStream02 &lt;&lt; str_input;   int32_t Copy &#x3D; 0;   converterStream02 &gt;&gt; Copy;   cout &lt;&lt; &quot;Integer gained from string, Copy &#x3D; &quot; &lt;&lt; Copy + 1 &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Integer Input &#x3D; 6789String gained from integer, strInput &#x3D; 6789Integer gained from string, Copy &#x3D; 6790<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-10、string转C风格字符串"><a href="#11-10、string转C风格字符串" class="headerlink" title="11.10、string转C风格字符串"></a>11.10、string转C风格字符串</h2><ul><li>data()返回char *指针，指向std::string对象内存放数组的内存空间；</li><li>c_str()返回const char *指针，指向std::string对象内存放数组的内存空间；</li><li>copy()将std::string内容复制至指定字符数组内；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; copy函数原型copy(_CharT* __s, size_type __n, size_type __pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;memory.h&gt;int main()&#123;    std::string str_str &#x3D; &quot;hello&quot;;    char *ptr01;    ptr01 &#x3D; str_str.data();    std::cout &lt;&lt; &quot;execute function data: &quot; &lt;&lt; ptr01 &lt;&lt; std::endl;    const char *ptr02 &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\nexecute function c_str: &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    char array[6];    memset(array, 0, sizeof(array));    str_str.copy(array, 3, 2);    std::cout &lt;&lt; &quot;\nexecute function copy: &quot; &lt;&lt; array &lt;&lt; std::endl;    &#x2F;&#x2F; modify std::string    str_str &#x3D; &quot;Hello world!&quot;;    std::cout &lt;&lt; &quot;\nafter modify:\nptr01 &#x3D; &quot; &lt;&lt; ptr01 &lt;&lt; &quot;\nptr02 &#x3D; &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">execute function data: helloexecute function c_str: helloexecute function copy: lloafter modify:ptr01 &#x3D; Hello world!ptr02 &#x3D; Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-11、其他常用函数"><a href="#11-11、其他常用函数" class="headerlink" title="11.11、其他常用函数"></a>11.11、其他常用函数</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int compare(string);  &#x2F;&#x2F; string比较，相同返回0int capacity() const;  &#x2F;&#x2F;返回string容量，已分配的内存空间int max_size()const;  &#x2F;&#x2F;返回string对象可存放的最大字符串长度，通常是个很大的数int size()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间int length()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间bool empty()const;  &#x2F;&#x2F;当前字符串是否为空void resize(int len, char c)const;&#x2F;&#x2F;把当前字符串大小设置为len，并用字符c填充不足的部分<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;hello world!&quot;;    std::cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; str_str.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nmax_size &#x3D; &quot; &lt;&lt; str_str.max_size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nsize &#x3D; &quot; &lt;&lt; str_str.size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nlength &#x3D; &quot; &lt;&lt; str_str.length() &lt;&lt; std::endl;    str_str.resize(15, &#39;B&#39;);    std::cout &lt;&lt; &quot;\nresize &#x3D; &quot; &lt;&lt; str_str &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-12、C风格字符串"><a href="#11-12、C风格字符串" class="headerlink" title="11.12、C风格字符串"></a>11.12、C风格字符串</h2><h3 id="11-12-1、strcmp的实现"><a href="#11-12-1、strcmp的实现" class="headerlink" title="11.12.1、strcmp的实现"></a>11.12.1、strcmp的实现</h3><pre class="line-numbers language-none"><code class="language-none">int mystrcmp(const char *str1, const char *str2)&#123;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39; &amp;&amp; *str1 &#x3D;&#x3D; *str2)    &#123;        str1++;        str2++;    &#125;        if(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 &#x3D;&#x3D; &#39;\0&#39;)    return 1;    else if(*str1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;)    return -1;    else if(*str1 &gt; *str2)    return 1;    else if (*str1 &lt; *str2)    return -1;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11-12-2、strcpy的实现"><a href="#11-12-2、strcpy的实现" class="headerlink" title="11.12.2、strcpy的实现"></a>11.12.2、strcpy的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrcpy(char *str1, const char *str2)&#123;    char *p &#x3D; str1;    if(p &#x3D;&#x3D; NULL || str2 &#x3D;&#x3D; NULL)    &#123;         printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str2 !&#x3D; &#39;\0&#39;)    &#123;        *p &#x3D; *str2;        p++;        str2++;    &#125;    *p &#x3D; &#39;\0&#39;;    return str1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="11-12-3、strstr的实现"><a href="#11-12-3、strstr的实现" class="headerlink" title="11.12.3、strstr的实现"></a>11.12.3、strstr的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrstr(const char *str1, const char *str2)&#123;    char *src, char *sub;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;    while(*str1 !&#x3D; &#39;\0&#39;)    &#123;        src &#x3D; str1;        sub &#x3D; str2;                do        &#123;            if(*sub &#x3D;&#x3D; &#39;\0&#39;)            &#123;                return str1;            &#125;        &#125;while(*src ++ &#x3D;&#x3D; *sub++);                str1++    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-、字符、字符串相关函数"><a href="#11-、字符、字符串相关函数" class="headerlink" title="11.*、字符、字符串相关函数"></a>11.*、字符、字符串相关函数</h2><ul><li>字母（不区分大小写）：isalpha();</li><li>大写字母：isupper();</li><li>小写字母：islower();</li><li>数字：isdigit();</li><li>字母和数字：isalnum();</li><li>转化为大写：toupper();</li><li>转化为小写：tolower();</li></ul><h1 id="12、lambda表达式"><a href="#12、lambda表达式" class="headerlink" title="12、lambda表达式"></a>12、lambda表达式</h1><p>语法结构：   </p><pre class="line-numbers language-none"><code class="language-none">[capturer]   (params) mutable-&gt;ret   &#123;body;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>capturer是捕获列表</strong>:[]是lambda引出符,编译器根据该引出符判断接下来的代码是lambda表达式；    </li><li><strong>params是参数列表</strong>:如果不需要参数传递，则可以连同括号()一起省略；   </li><li><strong>mutable是修饰符</strong>：默认情况下，lambda总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略；   </li><li><strong>ret是返回类型</strong>：不需要返回值的时候也可以连同符号-＞一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导；    </li><li><strong>body是函数体</strong>；    </li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto f &#x3D; []  (int a) -&gt;int &#123;return a+1;&#125;std::cout&lt;&lt;f(1)&lt;&lt;endl;   &#x2F;&#x2F;输出2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>lambda的捕获列表</strong>：    </p><ul><li>[]不捕获任何变量；</li><li>[&amp;]捕获外部作用域所有变量，并作为引用在函数体中使用；</li><li>[=]捕获外部作用域所有变量，并作为副本在函数体中使用；</li><li>[=,&amp;foo]按值捕获外部作用域所有变量，但按引用捕获foo变量；</li><li>[bar]按值捕获bar变量；</li><li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限；</li></ul><p><strong>通用语法</strong>：    </p><ul><li>必须以方括号[]打头，这个方括号告诉编译器接下来是一个lambda表达式。方括号后面是一个参数列表及函数表达式。[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li><li>stateVar1,stateVar2为状态变量，param1，param2为参数列表；   </li><li>如果要在表达式中修改状态变量，需要添加关键字mutable或捕获左值形式:<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) mutable {lambda表达式}；   </li><li>使用mutable修改状态变量，在离开lambda之后将无效，若要使之有效需使用引用:<br>[&amp;stateVar1,&amp;stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li><li>向编译器指明返回类型：<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) -&gt;returnType {lambda表达式}；</li></ul><p><font color=red><strong>[]只能捕获父作用域的变量；lambda可以直接使用全局变量，不需要额外捕获</strong></font></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;class A&#123;int i_ &#x3D; 0;void func(int x, int y)&#123;auto x1 &#x3D; []&#123;return i_; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量auto x2 &#x3D; [&#x3D;]&#123;return i_ + x + y; &#125;;auto x3 &#x3D; [&amp;]&#123;return i_ + x + y; &#125;;auto x4 &#x3D; [this]&#123;return i_; &#125;;auto x5 &#x3D; [this]&#123;return i_ + x + y; &#125;;  &#x2F;&#x2F;error,没有捕获x和yauto x6 &#x3D; [this, x, y]&#123;return i_ + x + y; &#125;;auto x7 &#x3D; [this]&#123;return i_++; &#125;;&#125;&#125;;int main(void)&#123;&#123;int a &#x3D; 0;int b &#x3D; 1;auto func1 &#x3D; []&#123;return a; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量 auto func2 &#x3D; [&amp;]&#123;return a++; &#125;;auto func3 &#x3D; [&#x3D;]&#123;return a; &#125;;auto func4 &#x3D; [&#x3D;]&#123;return a++; &#125;;  &#x2F;&#x2F;error,a是以复制方式捕获的，无法修改auto func5 &#x3D; [a]&#123;return a + b; &#125;;  &#x2F;&#x2F;error,没有捕获变量bauto func6 &#x3D; [a, &amp;b]&#123;return a + (b++); &#125;;auto func7 &#x3D; [&#x3D;, &amp;b]&#123;return a + (b++); &#125;;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=red>lambda按值捕获时实际捕获的是外部变量的副本，捕获之后的任何修改与原始变量无关，此种行为称作lambda捕获延时性</font></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a&#x3D;0;auto f &#x3D; [&#x3D;] &#123;return a;&#125;;a +&#x3D; 1;cout&lt;&lt;f()&lt;&lt;endl;  &#x2F;&#x2F;结果仍然是0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=red>没有捕获外部变量的lambda表达式可以直接转换为函数指针</font>，可以这么理解：假如lambda捕获了作用域内的rivate、protect成员，lambda转换为函数指针后，若在它处发生调用，函数是不会对private、protect进行检查，这样就破坏了封装性。</p><h2 id="12-1、lambda表达式的类型"><a href="#12-1、lambda表达式的类型" class="headerlink" title="12.1、lambda表达式的类型"></a>12.1、lambda表达式的类型</h2><p>从C++11标准的定义上可以发现，lambda的类型被定义为”<strong>闭包</strong>“（closure）的类，而每个lambda表达式则会产生一个闭包类型的临时对象（右值）。因此，严格地讲，lambda表达式并非函数指针。不过C++11标准却允许lambda表达式向函数指针转换(不允许函数指针向lambda转换)，但前提是lambda函数<strong>没有捕捉任何变量</strong>，且函数指针所示的函数原型， 必须跟lambda表达式类型相同。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int girls&#x3D;3,boys&#x3D;4;auto totalChild&#x3D;[](int x,int y)-＞int&#123;return x+y;&#125;;typedef int(*allChild)(int x,int y);typedef int(*oneChild)(int x);allChild p;p&#x3D;totalChild;oneChild q;q&#x3D;totalChild;&#x2F;&#x2F;编译失败， 参数必须一致decltype(totalChild)allPeople&#x3D;totalChild;&#x2F;&#x2F;需通过decltype获得lambda的类型decltype(totalChild)totalPeople&#x3D;p;&#x2F;&#x2F;编译失败， 指针无法转换为lambdareturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="12-2、lambda的常量性"><a href="#12-2、lambda的常量性" class="headerlink" title="12.2、lambda的常量性"></a>12.2、lambda的常量性</h2><p>lambda默认是const(常量性)，mutable可以修改其常量性，不过极少使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int val;auto const_val_lambda&#x3D;[&#x3D;]()&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;编译失败,不允许在const的lambda中修改按值捕获的变量auto mutable_val_lambda&#x3D;[&#x3D;]()mutable&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;非const的lambda,可以修改捕获的变量。对于按值捕获的变量，修改的是其捕获的副本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="12-3、lambda的底层实现"><a href="#12-3、lambda的底层实现" class="headerlink" title="12.3、lambda的底层实现"></a>12.3、lambda的底层实现</h2><p>lambda表达式被设计的目的就是要就地书写，就地使用。使用lambda的用户，更倾向于在一个文件作用域里看到所有的代码，而不是依靠代码浏览工具在文件间找到函数的实现。在封装的思维层面上，lambda只是一种局部的封装以及局部的共享。<br>由<strong>12.1节</strong>可知lambda是一个闭包类型，那么它的底层是怎么实现的呢？这就要从函数对象说起，函数对象是对函数调用符operator()的重载，详见<strong>4.9.7节</strong><br>lambda的原理与此相关：<font color=red>编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符</font></p><h3 id="12-3-1、无捕获列表-无参数列表"><a href="#12-3-1、无捕获列表-无参数列表" class="headerlink" title="12.3.1、无捕获列表 + 无参数列表"></a>12.3.1、无捕获列表 + 无参数列表</h3><p><code>auto print = []&#123;cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl; &#125;;</code><br>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;用给定的lambda表达式生成相应的类class print_class&#123;public:void operator()(void) const&#123;cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;用构造的类创建对象，print此时就是一个函数对象auto print &#x3D; print_class();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12-3-2、无捕获列表-参数列表"><a href="#12-3-2、无捕获列表-参数列表" class="headerlink" title="12.3.2、无捕获列表 + 参数列表"></a>12.3.2、无捕获列表 + 参数列表</h3><p><code>auto add = [](int a, int b)&#123;return a + b; &#125;;</code><br>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class add_class&#123;public:auto operator()(int a, int b) const&#123;return a + b;&#125;&#125;;auto add &#x3D; add_class();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12-3-3、按值捕获"><a href="#12-3-3、按值捕获" class="headerlink" title="12.3.3、按值捕获"></a>12.3.3、按值捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;&#x2F;&#x2F;采用值捕获，捕获所有的已定义的局部变量，如year，nameauto print &#x3D; [&#x3D;]()&#123;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:&#x2F;&#x2F;根据捕获列表来决定构造函数的参数列表形式print_class(int year, char *name) :year(year), name(name)&#123; &#125;void operator()(void) const&#123;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;private:int year;char *name;&#125;;auto print &#x3D; print_class(a, str);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里需要注意的是：</p><ul><li>值的传递方式是以含参数的构造函数实现；</li><li>按值捕获时lambda默认为const，在编译时以operator() const形式实现，同理mutable将const属性去除，是通过取消operator()的const性实现；</li></ul><h3 id="12-3-4、按引用捕获"><a href="#12-3-4、按引用捕获" class="headerlink" title="12.3.4、按引用捕获"></a>12.3.4、按引用捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;auto print &#x3D; [&amp;]()&#123;year++;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:&#x2F;&#x2F;由于是引用捕获，参数列表采用引用的方式print_class(int &amp;year, char *&amp;name) :year(year), name(name)&#123; &#125;void operator()(void) const&#123;year++;   &#x2F;&#x2F;编译通过，const对引用类型无效cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;private:int &amp;year;char *&amp;name;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="12-4、lambda的优势"><a href="#12-4、lambda的优势" class="headerlink" title="12.4、lambda的优势"></a>12.4、lambda的优势</h2><p><font color=purple>lambda表达式的优势：</font></p><ul><li>提升代码的可读性，它是就地书写，就地使用；</li><li>底层使用函数对象的方法实现，故同函数对象一样的优势，就地展开，避免了频繁的函数调用，性能更加；</li></ul><h1 id="13、I-O操作"><a href="#13、I-O操作" class="headerlink" title="13、I/O操作"></a>13、I/O操作</h1><p>stream流操作是读写功能的通用实现，不管数据来自网络、磁盘、程序或键盘，都以相同的方式处理读写操作。</p><h2 id="13-1、C-stream流操作类与控制符"><a href="#13-1、C-stream流操作类与控制符" class="headerlink" title="13.1、C++ stream流操作类与控制符"></a>13.1、C++ stream流操作类与控制符</h2><p><strong>常用stream类</strong></p><ul><li><strong>cout</strong>—标准输出；   </li><li><strong>cin</strong>—标准输入；   </li><li><strong>cerr</strong>—用于显示错误信息的标准输出流；    </li><li><strong>fstream</strong>—文件的输入输出流，集合了ofstream和ifstream；   </li><li><strong>ifstream</strong>—文件的输入流，用于读取文件；   </li><li><strong>ofstream</strong>—文件的输出流，用于写入文件操作；   </li><li><strong>stringstream</strong>—字符串的输入输出流，继承了istringstream和ostringstream，通常用于字符串和其他类型之间的转换；</li></ul><p><strong>常用stream流控制符</strong></p><ul><li>endl—输出换行符；</li><li>ends—输出空字符；</li><li>oct—以八进制形式进行输入输出；</li><li>dec—以十进制形式进行输入输出；</li><li>hex—以十六进制形式进行输入输出；</li><li>fixed—以定点表示法显示数据；</li><li>scientific—以科学表示法显示数据；</li><li>setprecision—设置小数精度；   </li><li>setw—设置字段宽度；   </li><li>setfill—设置填充字符；   </li><li>setbase—设置基数，与dec、hex、oct等效；   </li><li>setiosflag—通过类型为std::io_base::fmtflags的掩码输入参数设置标志；   </li><li>resetiosflag–重置标志；   </li></ul><h3 id="13-1-1、指定整形输出格式"><a href="#13-1-1、指定整形输出格式" class="headerlink" title="13.1.1、指定整形输出格式"></a>13.1.1、指定整形输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int Input &#x3D; 0;   cin &gt;&gt; Input;   cout &lt;&lt; &quot;Integer in octal: &quot; &lt;&lt; oct &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hexadecimal: &quot; &lt;&lt; hex &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hex using base notation: &quot;;   cout &lt;&lt; setiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer after resetting I&#x2F;O flags: &quot;;   cout &lt;&lt; resetiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 253    Integer in octal: 375   Integer in hexadecimal: fd   Integer in hex using base notation: 0XFD   Integer after resetting I&#x2F;O flags: 253<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-1-2、指定浮点型输出格式"><a href="#13-1-2、指定浮点型输出格式" class="headerlink" title="13.1.2、指定浮点型输出格式"></a>13.1.2、指定浮点型输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   const double Pi &#x3D; (double)22.0 &#x2F; 7;   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 7: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(7);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 10: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(10);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Enter a radius: &quot;;   double Radius &#x3D; 0.0;   cin &gt;&gt; Radius;   cout &lt;&lt; &quot;Area of circle: &quot; &lt;&lt; 2*Pi*Radius*Radius &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Pi&#x3D;3.14286    Setting precision to 7:    Pi&#x3D;3.142857   Fixed Pi &#x3D; 3.1428571    Scientific Pi &#x3D; 3.1428571e+000Setting precision to 10:    Pi&#x3D;3.1428571429e+000   Fixed Pi &#x3D; 3.1428571429  Scientific Pi &#x3D; 3.142857129e+000    Enter a radius:    Area of circle: 6.2731491429e+002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-1-3、设置文本对齐与宽度"><a href="#13-1-3、设置文本对齐与宽度" class="headerlink" title="13.1.3、设置文本对齐与宽度"></a>13.1.3、设置文本对齐与宽度</h3><p>setw设置字段宽度<br>setfill指定字符填充空白区域</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hey - default!&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and left, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setiosflags(ios::left);    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - left aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nback to default:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Hey - back to default!&quot; &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hey - default!weight length &#x3D; 35, and right default               Hey - right aligned!weight length &#x3D; 35, and right default, fill with ****************Hey - right aligned!weight length &#x3D; 35, and left, fill with *Hey - left aligned!****************back to default:Hey - back to default!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-1-4、cin读取"><a href="#13-1-4、cin读取" class="headerlink" title="13.1.4、cin读取"></a>13.1.4、cin读取</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int InputInt &#x3D; 0;   cin &gt;&gt; InputInt;   cout &lt;&lt; &quot;Enter an float: &quot;;   double Pi &#x3D; 0.0;   cin &gt;&gt; Pi;   cout &lt;&lt; &quot;Enter three characters separated by space: &quot; &lt;&lt; endl;   char Char1 &#x3D; &#39;\0&#39;, Char2 &#x3D; &#39;\0&#39;, Char3 &#x3D; &#39;\0&#39;;   cin &gt;&gt; Char1 &gt;&gt; Char2 &gt;&gt; Char3;   cout &lt;&lt; &quot;\nThe recorded variable values are: &quot; &lt;&lt; endl;   cout &lt;&lt; &quot;InputInt: &quot; &lt;&lt; InputInt &lt;&lt; endl;   cout &lt;&lt; &quot;Pi: &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; &quot;The three characters: &quot; &lt;&lt; Char1 &lt;&lt; Char2 &lt;&lt; Char3 &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 123Enter an float: 3.1415926Enter three characters separated by space: a b c    The recorded variable values are: InputInt: 123Pi: 3.14159The three characters: abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><font color=red><strong>读取数组</strong></font><br>可以直接使用cin，但这样存在地址越界的风险，最好使用get函数指定输入长度，避免地址越界</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter a line: &quot; &lt;&lt; endl;   char CStyleStr[10] &#x3D; &#123;0&#125;;   cin.get(CStyleStr, 9);   cout &lt;&lt; &quot;CStyleStr: &quot; &lt;&lt; CStyleStr &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><font color=red><strong>读取字符串</strong></font><br>使用cin读取数据到string时，如果输入流中有空格，cin的读取会停止，所以更好的方法是getline函数</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter your name: &quot;;   string Name;   getline(cin, Name);   &#x2F;&#x2F; 或者   cin.getline(Name);   cout &lt;&lt; &quot;Hi &quot; &lt;&lt; Name &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-1-5、fstream文件流操作"><a href="#13-1-5、fstream文件流操作" class="headerlink" title="13.1.5、fstream文件流操作"></a>13.1.5、fstream文件流操作</h3><p>fstream继承了ifstream和ofstream，需包含头文件<fstream></p><pre class="line-numbers language-none"><code class="language-none">fstream myFile;myFile.open(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);  &#x2F;&#x2F; 或者构造函数形式fstream myFile(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);if(myFile.is_open())&#123;    &#x2F;&#x2F; do something    myFile.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第一个参数为打开文件的路径和名称，未指定路径时，默认为程序当前的执行路径；   </li><li>第二个参数为打开模式，主要有如下几种：   <ul><li>ios_base::app—附加到现有文件末尾，而不是覆盖它；   </li><li>ios_base::ate—切换到文件末尾，但可在文件任何地方写入数据；   </li><li>ios_base::trunc—直接覆盖现有文件，此为默认模式；   </li><li>ios_base::binary—创建二进制文件，默认为文本文件；   </li><li>ios_base::in—以只读方式打开，<strong>注意</strong>：此种打开方式要求文件必须已经存在，否则打开失败；   </li><li>ios_base::out—以只写方式打开；</li></ul></li></ul><p><font color=purple>**&lt;&lt;文本文件写入**</font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;   ofstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::out);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful&quot; &lt;&lt; endl;      myFile &lt;&lt; &quot;My first text file!&quot; &lt;&lt; endl;      myFile &lt;&lt; &quot;Hello file!&quot;;       cout &lt;&lt; &quot;Finished writing to file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=purple><strong>&gt;&gt;文本文件读取</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   ifstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::in);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful. It contains: &quot; &lt;&lt; endl;      string fileContents;      while (myFile.good())      &#123;         getline (myFile, fileContents);       cout &lt;&lt; fileContents &lt;&lt; endl;      &#125;           cout &lt;&lt; &quot;Finished reading file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   else      cout &lt;&lt; &quot;open() failed: check if file is in right folder&quot; &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>good函数用于判断是否到达文件末尾；<br>getline函数逐行读取；   </p><p><font color=purple><strong>二进制文件读写read、write</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;struct Human&#123;Human() &#123;&#125;;   Human(const char* inName, int inAge, const char* inDOB) : Age(inAge)   &#123;      strcpy(Name, inName);      strcpy(DOB, inDOB);   &#125;   char Name[30];   int Age;   char DOB[20];&#125;;int main()&#123;   Human Input(&quot;Siddhartha Rao&quot;, 101, &quot;May 1910&quot;);   ofstream fsOut (&quot;MyBinary.bin&quot;, ios_base::out | ios_base::binary);   if (fsOut.is_open())   &#123;  cout &lt;&lt; &quot;Writing one object of Human to a binary file&quot; &lt;&lt; endl;      fsOut.write(reinterpret_cast&lt;const char*&gt;(&amp;Input), sizeof(Input));      fsOut.close();   &#125;   ifstream fsIn (&quot;MyBinary.bin&quot;, ios_base::in | ios_base::binary);   if(fsIn.is_open())   &#123;      Human somePerson;      fsIn.read((char*)&amp;somePerson, sizeof(somePerson));      cout &lt;&lt; &quot;Reading information from binary file: &quot; &lt;&lt; endl;      cout &lt;&lt; &quot;Name &#x3D; &quot; &lt;&lt; somePerson.Name &lt;&lt; endl;      cout &lt;&lt; &quot;Age &#x3D; &quot; &lt;&lt; somePerson.Age &lt;&lt; endl;      cout &lt;&lt; &quot;Date of Birth &#x3D; &quot; &lt;&lt; somePerson.DOB &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="13-2、C-stream流操作"><a href="#13-2、C-stream流操作" class="headerlink" title="13.2、C stream流操作"></a>13.2、C stream流操作</h2><h3 id="13-2-1、输出64位整型"><a href="#13-2-1、输出64位整型" class="headerlink" title="13.2.1、输出64位整型"></a>13.2.1、输出64位整型</h3><pre class="line-numbers language-none"><code class="language-none">uint64_t num &#x3D; 0;printf(&quot;%llu&quot;, num);或者printf(&quot;%lld&quot;, num);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-2-2、输出到数组"><a href="#13-2-2、输出到数组" class="headerlink" title="13.2.2、输出到数组"></a>13.2.2、输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">char src[32];char dst[32];sprintf(dst, &quot;%s&quot;, src);snprintf(dst, sizeof(dst),&quot;%s&quot;, src);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-2-3、以日期格式输出到数组"><a href="#13-2-3、以日期格式输出到数组" class="headerlink" title="13.2.3、以日期格式输出到数组"></a>13.2.3、以日期格式输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">time_t timeTick &#x3D; time(NULL);char timeStamp[24];strftime(timeStamp, _countof(timeStamp), &quot;%Y-%m-%d %H:%M:%S&quot;, localtime(&amp;timeTick));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-2-4、打开文件"><a href="#13-2-4、打开文件" class="headerlink" title="13.2.4、打开文件"></a>13.2.4、打开文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE *fopen( const char *path, const char *mode );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>函数说明：</strong>   </p><ul><li>path就是指定打开文件的路径，可以是相对路径，也可以绝对路径。mode代表打开文件的方式；</li><li>fopen打开成功，返回FILE的有效地址，失败返回NULL；</li></ul><p><strong>mode模式说明：</strong></p><ul><li><p>r 以只读方式打开文件，该文件必须存在，文件必须是可读的。</p></li><li><p>r+ 以可读写方式打开文件，该文件必须存在。</p></li><li><p>rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。</p></li><li><p>rw+ 读写打开一个文本文件，允许读和写。</p></li><li><p>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</p></li><li><p>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</p></li><li><p>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。<strong>EOF符保留</strong></p></li><li><p>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<strong>原来的EOF符不保留</strong></p></li></ul><h3 id="13-2-5、输出到文本文件"><a href="#13-2-5、输出到文本文件" class="headerlink" title="13.2.5、输出到文本文件"></a>13.2.5、输出到文本文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;fprintf(pfile, &quot;%d%s%c&quot;, num, strName, nChr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-2-6、输出到二进制文件"><a href="#13-2-6、输出到二进制文件" class="headerlink" title="13.2.6、输出到二进制文件"></a>13.2.6、输出到二进制文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;uint32_t num;fwrite(&amp;num, sizeof(uint32_t), 1, pfile);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-2-7、rename"><a href="#13-2-7、rename" class="headerlink" title="13.2.7、rename"></a>13.2.7、rename</h3><p>rename重命名或移动文件，但当目的目录下已存在同名文件时，不能被覆盖，被操作文件无法移动，所以操作之前需要检查目的目录下是否存在同名文件。</p><h2 id="13-3、I-O模型"><a href="#13-3、I-O模型" class="headerlink" title="13.3、I/O模型"></a>13.3、I/O模型</h2><p>I/O模型主要涉及两个对象：用户态、内核态。操作系统中I/O相关操作是内核行为，用户态是不能直接进行I/O操作的，比如读取文件、网络、键盘、鼠标、显示器等，用户态程序需要通过系统调用驱使内核态进行I/O操作。<br>同理同步、异步、阻塞、非阻塞也是针对用户态、内核态而言，相关概念参见：<strong>计算机系统.md第2节</strong>；</p><ul><li>同步阻塞I/O：用户态向内核态发起IO请求之后不做任何事情，死等内核返回IO操作结果；</li><li>同步非阻塞I/O：用户态向内核态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，不用死等。</li><li>异步非阻塞：用户态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，且用户态可以同时发起多次IO请求，内核态也可以同时返回多次IO操作结果；</li><li>异步只有非阻塞；</li></ul><h3 id="13-3-1、常见I-O模型"><a href="#13-3-1、常见I-O模型" class="headerlink" title="13.3.1、常见I/O模型"></a>13.3.1、常见I/O模型</h3><ul><li>阻塞状态下，用户态会一直等待内核返回结果，在此期间用户态会持续占有CPU；</li><li>非阻塞状态下，用户态不会一直等待内核返回结果，那么用户是如何接收内核返回的呢？常见的方式有：一通过轮询的方式检查内核是否结束，二是用户态发起请求之后就进入睡眠状态，待内核完成操作后以通知方式唤醒用户态接收；</li></ul><table><thead><tr><th>1、阻塞IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，排队三天买到一张票</td><td></td></tr><tr><td>耗费：在车站吃喝拉撒睡3天，其他事一件没干</td><td></td></tr></tbody></table><table><thead><tr><th>2、非阻塞IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，隔12小时去火车站问有没有票，三天后买到一张票</td><td></td></tr><tr><td>耗费：往返车站6次，路上6小时，其他时间做了好多事</td><td></td></tr></tbody></table><p><font color=red>这既是传统的轮询方式，轮询的不足之处在于不管IO队列之中是否有读写动作的发生，loop都会进行IO队列的遍历操作，这样便会白白浪费CPU资源。</font></p><p><strong>3、I/O复用模型，一共包括两种</strong></p><table><thead><tr><th>3.1、select/poll模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，委托黄牛，黄牛会监视所有车次的余票，然后每隔6小时老李都会电话询问黄牛，看下是否是自己想要的车次，黄牛三天内买到票，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次</td><td></td></tr><tr><td>select模型下黄牛可以监视的车次有限，poll模型下，黄牛可以监视全国范围内的所有车次</td><td></td></tr></tbody></table><p>这个代理可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个去轮询了，伪代码如下： </p><pre class="line-numbers language-none"><code class="language-none">while true  &#123;      select(streams[]) &#x2F;&#x2F;这一步阻塞在这里，直到有一个流有I&#x2F;O事件时，才往下执行      for i in streams[]      &#123;          if i has data          read until unavailable      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是依然有个问题，我们从select那里仅仅知道有I/O事件发生了，却并不知道是哪个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<br>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><table><thead><tr><th>3.2、epoll模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，委托黄牛，黄牛通过车次编码识别老李需要的车次，黄牛买到后即通知老李去领，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</td><td></td></tr></tbody></table><p>epoll可以理解为event poll，不同于死循环和无差别轮询，epoll会以事件通知的方式反馈指定I/O流是否有事件发生，这样轮询的复杂度降低到了O(1)，伪代码如下：</p><pre class="line-numbers language-none"><code class="language-none">while true  &#123;      active_stream[] &#x3D; epoll_wait(epollfd)      for i in active_stream[]      &#123;          read or write till      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，select/poll和epoll最大的区别就是：select/poll只是告诉你一定数目的流有事件了，至于哪个流有事件，还得一个个地去轮询，而epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到指定的流。</p><p><font color=red><strong>这里的黄牛相当于代理功能的select/poll，epoll</strong>，这个代理位于内核态，可以同时监控多个IO动作。</font></p><table><thead><tr><th>4、信号驱动IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</td><td></td></tr></tbody></table><h3 id="13-3-2、I-O复用的理解"><a href="#13-3-2、I-O复用的理解" class="headerlink" title="13.3.2、I/O复用的理解"></a>13.3.2、I/O复用的理解</h3><p>IO复用产生的原因：<br>如果一个I/O操作到来我们就开启一个task进行处理，那么假设现在有一百万个I/O操作进来，那我们就需要开启一百万个task一一这就是传统意义下的多task并发阻塞处理。思考一下，一百万个task，你的CPU占有会多高，这钟实现方式极其的不合理。所以人们提出了I/O多路复用模型，一个专有task通过记录I/O状态的方式来同时管理多个I/O。</p><p>IO复用的英文单词I/O multiplexing翻译成多路复用其实并不合理，应该理解成将多个task注册的I/O凑在一起交由一个专有task统一管理。注册I/O的task在I/O操作返回之前可以处理其他的事情已到达提升吞吐量的目的，这种涉及模式称作Reactor模式。</p><p>IO复用的实现方式包括：select、poll、epoll</p>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-plus-叁</title>
      <link href="2021/07/10/C-plus-%E5%8F%81/"/>
      <url>2021/07/10/C-plus-%E5%8F%81/</url>
      
        <content type="html"><![CDATA[<h1 id="14、内存对齐"><a href="#14、内存对齐" class="headerlink" title="14、内存对齐"></a>14、内存对齐</h1><p>为什么需要内存对齐？<br>这是因为不是所有硬件平台都能够访问任意位置的内存，考虑到CPU处理内存的方式，比如32位的CPU，一个时钟周期最多可以处理4byte的内存空间，且起始地址一定是偶数。<br>假如将一个4byte的整型存放在奇数内存起始位置上，想把这4个字节读出来，32位的CPU就需要读取两次。<br>但对齐之后，只需要一次读取即可，因为内存对齐之后，数据在内存中的大小将会是4的整数倍。同时此种方式也伴随一个问题，那就是数据在内存之中的存放将不是紧挨着的，而是会出现空隙，这对类似结构体而言，使用sizeof不一定会得到预期的结果。</p><ul><li>内存对齐规则由操作系统 + 编译器共同决定；</li><li>默认对齐系数：32位机一般为4，64位机一般为8；</li></ul><h2 id="14-1、-pragma-pack-k-和-pragma-pack"><a href="#14-1、-pragma-pack-k-和-pragma-pack" class="headerlink" title="14.1、#pragma pack(k)和#pragma pack()"></a>14.1、#pragma pack(k)和#pragma pack()</h2><p>k表示对齐系数，k可以是1,2,3,4,8,16</p><pre class="line-numbers language-none"><code class="language-none">#pragma pack(1) &#x2F;&#x2F;内存对齐设置为1个字节　　struct s1　　&#123;　　　　int i;　　　　char c;　　　　bool f;　　&#125;    &#x2F;&#x2F;struct s2&#123;...&#125;　  &#x2F;&#x2F;...#pragma pack()   &#x2F;&#x2F;恢复默认的内存对齐（与文件开头的指令配对使用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-2、、-pragma-pack-push-1-和-pragma-pack-pop"><a href="#14-2、、-pragma-pack-push-1-和-pragma-pack-pop" class="headerlink" title="14.2、、#pragma pack(push,1)和#pragma pack(pop)"></a>14.2、、#pragma pack(push,1)和#pragma pack(pop)</h2><pre class="line-numbers language-none"><code class="language-none">　#pragma pack(push,1) &#x2F;&#x2F;内存对齐设置为1个字节　　struct s3　　&#123;　　　　int i;　　　　char c;　　　　bool f;　　&#125;&#x2F;&#x2F;struct s4&#123;...&#125;　  &#x2F;&#x2F;...　#pragma pack(pop)   &#x2F;&#x2F;恢复默认的内存对齐(与文件开头的指令配对使用)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-3、C-11新增对齐关键字"><a href="#14-3、C-11新增对齐关键字" class="headerlink" title="14.3、C++11新增对齐关键字"></a>14.3、C++11新增对齐关键字</h2><pre class="line-numbers language-none"><code class="language-none">#include ＜iostream＞using namespace std;&#x2F;&#x2F;自定义的ColorVector， 对齐到32字节的边界struct alignas(32)ColorVector&#123;double r;double g;double b;double a;&#125;;int main()&#123;&#x2F;&#x2F;使用C++11中的alignof来查询ColorVector的对齐方式cout＜＜&quot;alignof(ColorVector):&quot;＜＜alignof(ColorVector)＜＜endl;return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>alignas(32)设置ColorVector对齐值为32字节；<br>alignof(ColorVector)获取ColorVector的对齐系数；</p><h1 id="15、union共用体-联合体"><a href="#15、union共用体-联合体" class="headerlink" title="15、union共用体/联合体"></a>15、union共用体/联合体</h1><p>union的外形看起来与struct非常类似，但二者的区别确实非常明显的</p><ul><li>struct的成员之间是共存的关系，编译器必须要为每一个成员分配内存（占位符除外，比如零长度的数组），不管是否被使用；</li><li>union的成员是互斥的关系，只有一个成员’有效’；</li></ul><p><font color=red><strong>本质</strong>：<br>所谓union就是在内存中申请一块足够大的内存，即占据内存最大的那个成员类型的空间，然后所有成员类型均使用相同的首地址</font>   </p><p><font color=purple><strong>union的使用场合</strong>：<br>是各数据类型各变量占用空间差不多并且对各变量同时使用要求不高的场合</font>    </p><p>借由union的特性可以判断大小端属性，<strong>大小端概念详见&lt;计算机系统.md第3节&gt;</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;union TEST&#123;    short a;    char b[sizeof(short)];&#125;;int main()&#123;    TEST test;    test.a&#x3D;0x0102;&#x2F;&#x2F; 不能引用共用体变量，只能引用共用体变量中的成员。    if(test.b[0]&#x3D;&#x3D;0x01&amp;&amp;test.b[1]&#x3D;&#x3D;0x02)&#123;        cout&lt;&lt;&quot;big endian.&quot;&lt;&lt;endl;    &#125;    else if(test.b[0]&#x3D;&#x3D;0x02&amp;&amp;test.b[1]&#x3D;&#x3D;0x01)&#123;        cout&lt;&lt;&quot;small endian.&quot;&lt;&lt;endl;    &#125;    else&#123;        cout&lt;&lt;&quot;unknown&quot;&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="16、enum枚举类型"><a href="#16、enum枚举类型" class="headerlink" title="16、enum枚举类型"></a>16、enum枚举类型</h1><h2 id="16-1、普通枚举类型"><a href="#16-1、普通枚举类型" class="headerlink" title="16.1、普通枚举类型"></a>16.1、普通枚举类型</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum Months&#123;Jan, Feb, Mar, Apr, May&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=red>普通枚举类型的缺陷</font></p><h3 id="16-1-1、缺陷一：enum成员的名字是全局可见的"><a href="#16-1-1、缺陷一：enum成员的名字是全局可见的" class="headerlink" title="16.1.1、缺陷一：enum成员的名字是全局可见的"></a>16.1.1、缺陷一：enum成员的名字是全局可见的</h3><p>C/C++的enum有个很”奇怪”的设定， 就是具名（有名字） 的enum类型的名字，以及enum的成员的名字都是全局可见的。这与C++中具名的namespace、class/struct及union必须通过”名字::成员名”的方式访问相比是格格不入的（namespace等被称为强作用域类型，而enum则是非强作用域类型），比如：</p><pre class="line-numbers language-none"><code class="language-none">enum Type&#123;General,Light,Medium,Heavy&#125;;enum Category&#123;General,Pistol,MachineGun,Cannon&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Category中的General和Type中的General都是全局的名字，编译时会报错。</p><h3 id="16-1-2、缺陷二：可以隐式地转换为整型"><a href="#16-1-2、缺陷二：可以隐式地转换为整型" class="headerlink" title="16.1.2、缺陷二：可以隐式地转换为整型"></a>16.1.2、缺陷二：可以隐式地转换为整型</h3><p>枚举的成员总是可以被隐式地转换为整型，如上面的例子，General总是可以被隐式的转换为整型值0</p><h3 id="16-1-3、缺陷三：占用的空间大小是一个”不确定量”"><a href="#16-1-3、缺陷三：占用的空间大小是一个”不确定量”" class="headerlink" title="16.1.3、缺陷三：占用的空间大小是一个”不确定量”"></a>16.1.3、缺陷三：占用的空间大小是一个”不确定量”</h3><p>C++枚举所基于的”基础类型”是由编译器来决定的，这会导致枚举类型成员的基本类型的不确定性问题，例如：</p><pre class="line-numbers language-none"><code class="language-none">#include ＜iostream＞using namespace std;enum D&#123;D1&#x3D;1,D2&#x3D;2,Dbig&#x3D;0xFFFFFFF0U&#125;;enum E&#123;E1&#x3D;1,E2&#x3D;2,Ebig&#x3D;0xFFFFFFFFFLL&#125;;int main()&#123;cout＜＜Dbig＜＜endl;&#x2F;&#x2F;编译器输出不同,g++： 4294967280cout＜＜sizeof(D1)＜＜endl;&#x2F;&#x2F;4cout＜＜sizeof(Dbig)＜＜endl;&#x2F;&#x2F;4cout＜＜Ebig＜＜endl;&#x2F;&#x2F;68719476735cout＜＜sizeof(E1)＜＜endl;&#x2F;&#x2F;8return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-2、强枚举类型"><a href="#16-2、强枚举类型" class="headerlink" title="16.2、强枚举类型"></a>16.2、强枚举类型</h2><p>声明强类型枚举非常简单，只需要在enum后加上关键字class。比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum class Type&#123;General,Light,Medium,Heavy&#125;;&#x2F;&#x2F; 例如enum class Months:int&#123;Jan, Feb, Mar, Apr, May&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间，即不能直接被全局可见；</li><li>转换限制， 强类型枚举成员的值不可以与整型隐式地相互转换；</li><li>可以指定底层基础类型，强类型枚举默认的底层类型为int,但也可以显式地指定底层类型， 具体方法为在枚举名称后面加上”：type”，其中type可以是除wchar_t以外的任何整型；<br>如：</li></ul><pre class="line-numbers language-none"><code class="language-none">enum class Type:char&#123;General,Light,Medium,Heavy&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include ＜iostream＞using namespace std;enum class Type&#123;General,Light,Medium,Heavy&#125;;enum class Category&#123;General&#x3D;1,Pistol,MachineGun,Cannon&#125;;int main()&#123;Type t&#x3D;Type::Light;t&#x3D;General;&#x2F;&#x2F;编译失败， 必须使用强类型名称if(t&#x3D;&#x3D;Category::General)&#x2F;&#x2F;编译失败， 必须使用Type中的Generalcout＜＜&quot;General Weapon&quot;＜＜endl;if(t＞Type::General)&#x2F;&#x2F;通过编译cout＜＜&quot;Not General Weapon&quot;＜＜endl;if(t＞0)&#x2F;&#x2F;编译失败， 无法转换为int类型cout＜＜&quot;Not General Weapon&quot;＜＜endl;if((int)t＞0)&#x2F;&#x2F;通过编译cout＜＜&quot;Not General Weapon&quot;＜＜endl;cout＜＜is_pod＜Type＞::value＜＜endl;&#x2F;&#x2F;1cout＜＜is_pod＜Category＞::value＜＜endl;&#x2F;&#x2F;1return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git与Github</title>
      <link href="2021/03/17/Git%E4%B8%8EGithub/"/>
      <url>2021/03/17/Git%E4%B8%8EGithub/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Git简介"><a href="#1、Git简介" class="headerlink" title="1、Git简介"></a>1、Git简介</h1><h2 id="1-1、发展历史"><a href="#1-1、发展历史" class="headerlink" title="1.1、发展历史"></a>1.1、发展历史</h2><ul><li>git开发者是Linux系统创始人Linus；</li><li>在git之前，市场上有免费的版本管理系统CVS、SVN，但它们都是集中式的版本控制系统，不仅速度慢，而且需要联网；</li><li>一开始Linux的源代码是由Linus亲自管理，但到了2002年，由于代码量的急剧上升，Linus就将源代码托管在商用软件BitKeeper上，其母公司BitMover对Linux社区免费。但后来因为Linux社区有人试图破解BitKeeper被发现，而被终止向社区提供服务；</li><li>Linus花费两周时间用C语言开发了分布式的Git；</li><li>2008年GitHub上线，它为开源项目提供免费的源码git存储；</li></ul><h2 id="1-2、git对象"><a href="#1-2、git对象" class="headerlink" title="1.2、git对象"></a>1.2、git对象</h2><p>   首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词”Linux”，在第8行删了一个单词”Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>​    git与其他版本管理系统不同之处在于，git跟踪和管理的对象是修改，而非文件本身。</p><h1 id="2、Git使用-本地版本库-仓"><a href="#2、Git使用-本地版本库-仓" class="headerlink" title="2、Git使用-本地版本库/仓"></a>2、Git使用-本地版本库/仓</h1><h2 id="2-1、创建版本库-仓"><a href="#2-1、创建版本库-仓" class="headerlink" title="2.1、创建版本库/仓"></a>2.1、创建版本库/仓</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   这样就在本地创建了一个空的git，该目录下的所有文件就会被git管理起来。同时本地也会生成一个隐藏目录.git，它是git用来跟踪管理版本库</p><h2 id="2-2、commit修改"><a href="#2-2、commit修改" class="headerlink" title="2.2、commit修改"></a>2.2、commit修改</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git add + pathgit commit -m &quot;comment&quot;&#x2F;&#x2F; 或者进入vi模式进行修改git commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>   不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。如果觉得文件修改到一定程度的时候，就可以”保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作。</p><h2 id="2-3、git-status"><a href="#2-3、git-status" class="headerlink" title="2.3、git status"></a>2.3、git status</h2><p>可以查看当前仓的状态，比如是否有change, 是否有commit等</p><h2 id="2-4、git-diff"><a href="#2-4、git-diff" class="headerlink" title="2.4、git diff"></a>2.4、git diff</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git diff + file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前改动的内容，只能查看本地未commit的修改部分</p><h2 id="2-5、查看修改日志"><a href="#2-5、查看修改日志" class="headerlink" title="2.5、查看修改日志"></a>2.5、查看修改日志</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示的结果中commit ID是16进制SHA1码，是修改记录的唯一标识</p><h2 id="2-6、版本回退"><a href="#2-6、版本回退" class="headerlink" title="2.6、版本回退"></a>2.6、版本回退</h2><p>git中HEAD表示当前版本，依次类推HEAD^是上一个版本，HEAD^^前两个版本……，也可以这样表示HEAD~100前100个版本</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 回退到前一个版本git reset --hard HEAD^# 回退到之前指定的版本,n表示前n个版本git reset --hard HEAD~n# 也可以使用commit id，使用commit id也可以往后回退，防止误回退操作# 如果忘记了回退之前的commit id，可以使用git reflog查看git reset --hard + commit id# --hard表示同时也会回退文件本地的修改，较为危险；不带hard，仅回退暂存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过–hard方式回退的操作，可以回退commit记录，也会将文件本身进行回退</p><h2 id="2-7、git-reflog"><a href="#2-7、git-reflog" class="headerlink" title="2.7、git reflog"></a>2.7、git reflog</h2><p>查看在当前版本库下所有执行过的git命令</p><h2 id="2-8、工作区和暂存区"><a href="#2-8、工作区和暂存区" class="headerlink" title="2.8、工作区和暂存区"></a>2.8、工作区和暂存区</h2><table><thead><tr><th>工作区</th><th>就是执行git init的本地目录</th></tr></thead><tbody><tr><td>版本库/仓</td><td>就是.git目录</td></tr><tr><td>暂存区</td><td>存在于版本库之中，称作stage</td></tr></tbody></table><p>版本库的组成：</p><ul><li>master—git创建的第一个分支</li><li>HEAD—指向master的指针，也就是git仓的当前版本</li></ul><p>git add就是将修改添加到暂存区，git add的操作对象是工作区的文件</p><p>git commit就是将暂存区的所有修改提交到当前分支，即当前版本HEAD，就是向master上提交。git commit的操作对象是暂存区的修改</p><h2 id="2-9、撤销修改"><a href="#2-9、撤销修改" class="headerlink" title="2.9、撤销修改"></a>2.9、撤销修改</h2><h3 id="2-9-1、工作区"><a href="#2-9-1、工作区" class="headerlink" title="2.9.1、工作区"></a>2.9.1、工作区</h3><ul><li>1、如果乱改了工作区文件，但并没有提交到暂存区，即没有执行git add；</li><li>2、已经提交到暂存区，但没有commit到版本/分支，又在工作区做了修改；</li></ul><p>撤销工作区的修改操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -- file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完命令后：</p><ul><li>1、就回到了和当前版本库/分支一样的状态；</li><li>2、就回到了添加到暂存区后的状态；</li></ul><h3 id="2-9-2、暂存区"><a href="#2-9-2、暂存区" class="headerlink" title="2.9.2、暂存区"></a>2.9.2、暂存区</h3><p>1、如果错误的修改被git add到暂存区，但并未commit</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git reset HEAD file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令就会撤回暂存区的修改，此时通过git status可以看到修改撤回到了工作区，如果还想撤回工作区的修改，参考2.9.1即可</p><p>2、或者重新修改文件</p><p>然后重新add，git commit –amend即可</p><h3 id="2-9-3、版本库-仓"><a href="#2-9-3、版本库-仓" class="headerlink" title="2.9.3、版本库/仓"></a>2.9.3、版本库/仓</h3><p>如果错误修改即git add， 也git commit，那就参考2.6，进行版本回退</p><h3 id="2-9-4、远程分支"><a href="#2-9-4、远程分支" class="headerlink" title="2.9.4、远程分支"></a>2.9.4、远程分支</h3><p>如果错误修改即git add， 也git commit，同时又git push到了远程仓库，那就不能参考2.6，进行版本回退了</p><h2 id="2-10、删除文件"><a href="#2-10、删除文件" class="headerlink" title="2.10、删除文件"></a>2.10、删除文件</h2><ul><li>如果提交到版本库之后，在工作区删除了文件，此时工作区与版本库就不一致了，那么git status会告知哪些文件被删除了，如果此时确定需要从版本库删除；</li><li>如果提交到版本库之后，发现有些文件是没必要提交的，那么可以先在工作区删除该文件，然后执行以下命令；</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git rm file namegit commit --amend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果提交到版本库之后，误删了工作区文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -- file name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3、Git使用-远程基线版本"><a href="#3、Git使用-远程基线版本" class="headerlink" title="3、Git使用-远程基线版本"></a>3、Git使用-远程基线版本</h1><h2 id="3-1、基线、master、分支"><a href="#3-1、基线、master、分支" class="headerlink" title="3.1、基线、master、分支"></a>3.1、基线、master、分支</h2><ul><li>从大版本的一个时间节点拉下来的代码作为基线版本，基线版本的管理是放在远程服务器，可以理解成”中央服务器”，基线版本可以理解成所有开发者的主分支master，它只有一条时间线；</li><li>每个开发者从远程服务器拉下来的代码，作为本地的主分支master，所有的本地修改，都是在延长本地分支的时间线；</li><li>分支，本地代码相对于远程服务器基线版本，就是一个分支；基线版本相对于大版本就是一个分支；</li></ul><p>第一次拉完代码后，本地master与远程master是对应起来的，HEAD是指向本地master的，后续的本地修改，都是在延长本地分支的时间线，HEAD指向当前最新本地版本。</p><h2 id="3-2、抓取远程分支"><a href="#3-2、抓取远程分支" class="headerlink" title="3.2、抓取远程分支"></a>3.2、抓取远程分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone ssh:&#x2F;&#x2F;lipin@172.17.122.236:29418&#x2F;&lt;分支名&gt;&#x2F;&#x2F; 或git pull ssh:&#x2F;&#x2F;lipin@gerrit.scm.adc.com:29418&#x2F;amss&#x2F;slpi_proc &lt;最新提交点&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-3、创建本地分支"><a href="#3-3、创建本地分支" class="headerlink" title="3.3、创建本地分支"></a>3.3、创建本地分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以不创建本地分支名，只要在push时知道目标远程分支名即可</p><h2 id="3-4、创建本地分支并与远程分支相关联"><a href="#3-4、创建本地分支并与远程分支相关联" class="headerlink" title="3.4、创建本地分支并与远程分支相关联"></a>3.4、创建本地分支并与远程分支相关联</h2><pre class="line-numbers language-none"><code class="language-none">git checkout -b &lt;local branch name&gt; origin&#x2F;&lt;remote branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-5、设置本地分支与远程分支链接"><a href="#3-5、设置本地分支与远程分支链接" class="headerlink" title="3.5、设置本地分支与远程分支链接"></a>3.5、设置本地分支与远程分支链接</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 第一次clone或pull时并未创建本地分支，后期需要与远程分支相关联时，可执行git branch --set-upstream-to&#x3D;origin&#x2F;&lt;remote branch name&gt; &lt;local branch name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-6、切换分支"><a href="#3-6、切换分支" class="headerlink" title="3.6、切换分支"></a>3.6、切换分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-7、创建本地分支并切换分支"><a href="#3-7、创建本地分支并切换分支" class="headerlink" title="3.7、创建本地分支并切换分支"></a>3.7、创建本地分支并切换分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git checkout -b name&#x2F;&#x2F; 这条命令相当于下面两条命令的合集git branch namegit checkout name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-8、查看分支"><a href="#3-8、查看分支" class="headerlink" title="3.8、查看分支"></a>3.8、查看分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch&#x2F;&#x2F; 或git branch -agit remotegit remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面标’*’的行，就是本地主分支当前master；</p><p>‘origin’行就是远程基线主分支/远程仓库；</p><h2 id="3-9、合并分支"><a href="#3-9、合并分支" class="headerlink" title="3.9、合并分支"></a>3.9、合并分支</h2><h3 id="3-9-1、合并本地分支"><a href="#3-9-1、合并本地分支" class="headerlink" title="3.9.1、合并本地分支"></a>3.9.1、合并本地分支</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git merge 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将其他分支合并到当前分支，使用的是fast forward模式，所以在git log中看不到本次合并历史，如果需要：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git merge --no-ff -m &quot;内容&quot; 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为本次合并需要创建一个新的commit，所以需要加 ‘-m’</p><h2 id="3-10、推送分支"><a href="#3-10、推送分支" class="headerlink" title="3.10、推送分支"></a>3.10、推送分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git push origin master&#x2F;&#x2F; 如果本地未创建master分支，可以通过目标远程分支pushgit push origin HEAD:refs&#x2F;for&#x2F;&lt;远程分支名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上。</p><h2 id="3-11，git-pull"><a href="#3-11，git-pull" class="headerlink" title="3.11，git pull"></a>3.11，git pull</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#x2F;&#x2F; 首次拉远程分支的最新提交点git pull ssh:&#x2F;&#x2F;lipin@gerrit.scm.adc.com:29418&#x2F;amss&#x2F;slpi_proc &lt;最新提交点&gt;&#x2F;&#x2F; 非首次，拉取最新提交点到本地git pull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>git pull的使用场景通常是多人同时对一个分支仓进行修改时，后push的人在push之前需要先pull最新的远程提交点，与自己本地修改合并之后才能顺利push自己的修改提交</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="4、git使用-分支相关"><a href="#4、git使用-分支相关" class="headerlink" title="4、git使用-分支相关"></a>4、git使用-分支相关</h1><h2 id="4-1、解决冲突conflict"><a href="#4-1、解决冲突conflict" class="headerlink" title="4.1、解决冲突conflict"></a>4.1、解决冲突conflict</h2><p>冲突发生的场景：</p><ul><li>合并其他分支到当前分支时，当前分支滞后于其他分支，或者说当前分支不是最新提交点。这个其他分支既可以是本地分支也可以是远程分支</li><li>从其他分支cherry-pick时</li></ul><p>通过git status可以查看冲突的文件，冲突的内容会通过&lt;&lt;&lt;&lt;&lt;&lt;&lt;<code>，</code>=======<code>，</code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;形式标注出来</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new one&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new two&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vim修改冲突部分即可解决</p><h3 id="4-1-1、push到远程分支’Merge-Conflict’"><a href="#4-1-1、push到远程分支’Merge-Conflict’" class="headerlink" title="4.1.1、push到远程分支’Merge Conflict’"></a>4.1.1、push到远程分支’Merge Conflict’</h3><ul><li>首先点击rebase，如果仍然提示冲突</li><li>方案一：不影响本地编译环境</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、先确保本地修改已经push# 2、将有冲突的仓拉取到本地临时目录repo init -u ssh:&#x2F;&#x2F;gerrit.scm.adc.com:29418&#x2F;oplus&#x2F;prjxml&#x2F;mtk&#x2F;r -b r&#x2F;mtk -m mtk_11&#x2F;20131&#x2F;Milestone_XML&#x2F;mtk_11_V7.1_userdebug.xml --reference&#x3D;&#x2F;work&#x2F;oppo_mirror --no-repo-verifyrepo sync -fcq -j4 --no-tags --prune --no-repo-verify 仓库名# 或者直接在已有的gerrit提交网页复制pull命令# 3、将提交的本地修改cherriy pick到临时目录，解决冲突后重新push<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2、git-stash"><a href="#4-2、git-stash" class="headerlink" title="4.2、git stash"></a>4.2、git stash</h2><p>场景：</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交（通过git status查看当前分支未提交的修改）。<br>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？<br>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场”储藏”起来，等以后恢复现场后继续工作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git stashSaved working directory and index state WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在用git status查看工作区，就是干净的。</p><p>bug修复完以后，将之前’储藏’起来的现场恢复：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 方法一： git stash apply + git stash dropgit stash apply stash@&#123;编号&#125;  # 恢复后stash内容不会被删除，需要使用下面的命令删除git stash drop stash@&#123;编号&#125; # 一步到位方式git stash pop stash@&#123;编号&#125; # 查看本地stashgit stash list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3、合并指定修改"><a href="#4-3、合并指定修改" class="headerlink" title="4.3、合并指定修改"></a>4.3、合并指定修改</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 有时候并不想合并完整分支，只是合并某一次的修改commit或远程服务器的其他开发人员的某一次pushgit cherry-pick commit id &#x2F; push地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-4、删除分支"><a href="#4-4、删除分支" class="headerlink" title="4.4、删除分支"></a>4.4、删除分支</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、本地分支# 删除已合并的分支git branch -d 分支名# 删除未合并的分支git branch -D 分支名#删除本地的远程分支git branch -r -D origin&#x2F;分支名# 2、远程分支# 远程删除git服务器上的remote分支git push origin --delete 分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、查看本地分支配置信息-对应的仓名称"><a href="#4-5、查看本地分支配置信息-对应的仓名称" class="headerlink" title="4.5、查看本地分支配置信息/对应的仓名称"></a>4.5、查看本地分支配置信息/对应的仓名称</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config -l# remote.origin.projectname就是对应的远程仓名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-6、查看远程分支信息"><a href="#4-6、查看远程分支信息" class="headerlink" title="4.6、查看远程分支信息"></a>4.6、查看远程分支信息</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git remote<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-7、no-tracking-information-本地分支与远程分支建立链接"><a href="#4-7、no-tracking-information-本地分支与远程分支建立链接" class="headerlink" title="4.7、no tracking information  / 本地分支与远程分支建立链接"></a>4.7、no tracking information  / 本地分支与远程分支建立链接</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git branch --set-upsream-to&#x3D;origin&#x2F;&lt;branch&gt; &lt;branch&gt;# 例如 本地开发分支dev与远程开发分支dev相关联git branch --set-upstream-to&#x3D;origin&#x2F;dev dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="5、速记"><a href="#5、速记" class="headerlink" title="5、速记"></a>5、速记</h1><h2 id="5-1、git配置"><a href="#5-1、git配置" class="headerlink" title="5.1、git配置"></a>5.1、git配置</h2><p>配置的对象有三个层级</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 面向系统的所有用户&#x2F;etc&#x2F;config使用git config --system + paras# 当前用户~&#x2F;.gitconfig使用git config --global + paras# 当前项目.git&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前配置会覆盖前一级别的配置</p><h3 id="5-1-1、用户信息配置"><a href="#5-1-1、用户信息配置" class="headerlink" title="5.1.1、用户信息配置"></a>5.1.1、用户信息配置</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.name &quot;lipin&quot;git config --global user.email &quot;lipin@oppo.con&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-1-2、配置文本编辑器"><a href="#5-1-2、配置文本编辑器" class="headerlink" title="5.1.2、配置文本编辑器"></a>5.1.2、配置文本编辑器</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global core.editor vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-2、查看本地私钥"><a href="#5-2、查看本地私钥" class="headerlink" title="5.2、查看本地私钥"></a>5.2、查看本地私钥</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat ~&#x2F;.ssh&#x2F;id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-3、查看某个文件的提交记录"><a href="#5-3、查看某个文件的提交记录" class="headerlink" title="5.3、查看某个文件的提交记录"></a>5.3、查看某个文件的提交记录</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git log 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-4、合并diff"><a href="#5-4、合并diff" class="headerlink" title="5.4、合并diff"></a>5.4、合并diff</h2><pre class="line-numbers language-none"><code class="language-none"># 先查看是否可以正常何如git apply --check *.diff#  合入git applu *.diff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5、git不跟踪空目录"><a href="#5-5、git不跟踪空目录" class="headerlink" title="5.5、git不跟踪空目录"></a>5.5、git不跟踪空目录</h2><p>git只跟踪文件的变化，对于空目录git status是无变化地</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
