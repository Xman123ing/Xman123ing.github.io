<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机系统_贰</title>
      <link href="2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%B4%B0/"/>
      <url>2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E8%B4%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="6、实时操作系统-FreeRTOS"><a href="#6、实时操作系统-FreeRTOS" class="headerlink" title="6、实时操作系统 FreeRTOS"></a>6、实时操作系统 FreeRTOS</h1><h2 id="6-0、RTOS与OS的区别"><a href="#6-0、RTOS与OS的区别" class="headerlink" title="6.0、RTOS与OS的区别"></a>6.0、RTOS与OS的区别</h2><p><strong>RTOS</strong>(Real Time Operator System)实时操作系统，实时指的是task任务在规定的时间内完成     </p><p><strong>OS</strong>通用操作系统   </p><ul><li>通用操作系统专注于在最短时间内完成尽可能多的计算；</li><li>RTOS强调的是在规定的时间内完成任务；</li><li>通用操作系统通常使用时间共享架构，为每个任务分配一小段时间，多个任务在时间片上进行切换；</li><li>RTOS有时间共享架构，也有事件驱动架构，事件驱动架构仅在发生事件或中断时才切换任务；</li></ul><h2 id="6-1、task"><a href="#6-1、task" class="headerlink" title="6.1、task"></a>6.1、task</h2><h3 id="6-1-1、task的概念"><a href="#6-1-1、task的概念" class="headerlink" title="6.1.1、task的概念"></a>6.1.1、task的概念</h3><p> 对于目前主流的RTOS，比如ucos，freeRTOS，RT-thread等等，都是属于并发的线程，其实从RT-thread名字上看，其表示的就是实时的线程。</p><ul><li><p>对于MCU上的资源所有任务都是共享的，类似单进程多线程模型；</p></li><li><p>MCU一般没有内存管理模块MMU、虚拟内存技术等，通常是直接访问物理内存，这样便无法很好的实现进程的安全隔离，如果用软件实现，开销太大，对于MCU而言没有必要，这也是为什么当某个任务崩溃时往往会导致整个系统故障的原因。</p></li></ul><h3 id="6-1-2、TCB任务控制块"><a href="#6-1-2、TCB任务控制块" class="headerlink" title="6.1.2、TCB任务控制块"></a>6.1.2、TCB任务控制块</h3><p>全称为Task Control Block，也就是任务控制块，这个结构体包含了一个任务所有的信息，它的定义以及相关变量的解释如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef struct tskTaskControlBlock                 &#123;        &#x2F;&#x2F; 这里栈顶指针必须位于TCB第一项是为了便于上下文切换操作，详见xPortPendSVHandler中任务切换的操作。        volatile StackType_t    *pxTopOfStack;            &#x2F;&#x2F; MPU相关暂时不讨论        #if ( portUSING_MPU_WRAPPERS &#x3D;&#x3D; 1 )            xMPU_SETTINGS    xMPUSettings;                #endif        &#x2F;&#x2F; 表示任务状态，不同的状态会挂接在不同的状态链表下        ListItem_t            xStateListItem;            &#x2F;&#x2F; 事件链表项，会挂接到不同事件链表下        ListItem_t            xEventListItem;                &#x2F;&#x2F; 任务优先级，数值越大优先级越高        UBaseType_t            uxPriority;                    &#x2F;&#x2F; 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出        StackType_t            *pxStack;                    &#x2F;&#x2F; 任务名        char                pcTaskName[ configMAX_TASK_NAME_LEN ];        &#x2F;&#x2F; 指向栈尾，可以用来检测堆栈是否溢出        #if ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS &#x3D;&#x3D; 1 ) )            StackType_t        *pxEndOfStack;                #endif        &#x2F;&#x2F; 记录临界段的嵌套层数        #if ( portCRITICAL_NESTING_IN_TCB &#x3D;&#x3D; 1 )            UBaseType_t        uxCriticalNesting;            #endif        &#x2F;&#x2F; 跟踪调试用的变量        #if ( configUSE_TRACE_FACILITY &#x3D;&#x3D; 1 )            UBaseType_t        uxTCBNumber;                    UBaseType_t        uxTaskNumber;                #endif        &#x2F;&#x2F; 任务优先级被临时提高时，保存任务原本的优先级        #if ( configUSE_MUTEXES &#x3D;&#x3D; 1 )            UBaseType_t        uxBasePriority;                    UBaseType_t        uxMutexesHeld;        #endif        &#x2F;&#x2F; 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做Hook    函数调用        #if ( configUSE_APPLICATION_TASK_TAG &#x3D;&#x3D; 1 )            TaskHookFunction_t pxTaskTag;        #endif        &#x2F;&#x2F; 任务的线程本地存储指针，可以理解为这个任务私有的存储空间        #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )            void            *pvThreadLocalStoragePointers[     configNUM_THREAD_LOCAL_STORAGE_POINTERS ];        #endif        &#x2F;&#x2F; 运行时间变量        #if( configGENERATE_RUN_TIME_STATS &#x3D;&#x3D; 1 )            uint32_t        ulRunTimeCounter;            #endif        &#x2F;&#x2F; 支持NEWLIB的一个变量        #if ( configUSE_NEWLIB_REENTRANT &#x3D;&#x3D; 1 )            struct    _reent xNewLib_reent;        #endif        &#x2F;&#x2F; 任务通知功能需要用到的变量        #if( configUSE_TASK_NOTIFICATIONS &#x3D;&#x3D; 1 )            &#x2F;&#x2F; 任务通知的值             volatile uint32_t ulNotifiedValue;            &#x2F;&#x2F; 任务通知的状态            volatile uint8_t ucNotifyState;        #endif        &#x2F;&#x2F; 用来标记这个任务的栈是不是静态分配的        #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE !&#x3D; 0 )             uint8_t    ucStaticallyAllocated;                 #endif        &#x2F;&#x2F; 延时是否被打断        #if( INCLUDE_xTaskAbortDelay &#x3D;&#x3D; 1 )            uint8_t ucDelayAborted;        #endif        &#x2F;&#x2F; 错误标识        #if( configUSE_POSIX_ERRNO &#x3D;&#x3D; 1 )            int iTaskErrno;        #endif    &#125; tskTCB;    typedef tskTCB TCB_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、栈空间生长方向"><a href="#1、栈空间生长方向" class="headerlink" title="1、栈空间生长方向"></a>1、栈空间生长方向</h4><p>在TCB的定义中可以看到根据栈的生长方式的不同，其将具有不同的成员变量pxEndOfStack。</p><p>栈的生长方式可以分为两种，「一种是向下生长，一种是向上生长」，FreeRTOS中用portSTACK_GROWTH来区分这两种生长方式，portSTACK_GROWTH大于0为向上生长，小于零为向下生长</p><ul><li><p>向上生长：入栈时栈顶指针增加，出栈时栈顶指针减小;</p></li><li><p>向下生长：入栈时栈顶指针减小，出栈时栈顶指针增加;</p></li></ul><p>通常Windows与Linux的栈空间都是向下生长，那么为何有些嵌入式系统会存在向上增长呢？这一点主要与芯片涉及的实际需要相关</p><h4 id="2、状态链表项xStateListItem"><a href="#2、状态链表项xStateListItem" class="headerlink" title="2、状态链表项xStateListItem"></a>2、状态链表项xStateListItem</h4><p>xStateListItem表示task的状态，不同的状态会挂载到不同的状态链表之中，根据<strong>6.1.3节task的状态流转</strong>，task的状态链表包括：</p><ul><li>pxCurrentTCB 运行态链表；</li><li>pxReadyTasksLists 就绪态链表；</li><li>pxDelayedTaskList 阻塞态链表；</li><li>xSuspendedTaskList 挂起态链表；</li></ul><p>随着task的状态流转，task的xStateListItem会被挂载到不同的状态链表之上，以示task当前所处的状态。</p><h4 id="3、删除链表-xTasksWaitingTermination"><a href="#3、删除链表-xTasksWaitingTermination" class="headerlink" title="3、删除链表 xTasksWaitingTermination"></a>3、删除链表 xTasksWaitingTermination</h4><p><code>PRIVILEGED_DATA static List_t xTasksWaitingTermination;</code><br>当任务自己删除自己时，其是不能立刻释放自己所占用的内存等资源的，需要将自己挂接到xTasksWaitingTermination这个链表下，然后让IdleTask来回收其所占用的资源。</p><h3 id="6-1-3、task任务状态流转"><a href="#6-1-3、task任务状态流转" class="headerlink" title="6.1.3、task任务状态流转"></a>6.1.3、task任务状态流转</h3><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE22ec6d1654c7c0dfcbe7cc4a70d264f2/40990" alt="image19"></p><h4 id="1、就绪态-Ready"><a href="#1、就绪态-Ready" class="headerlink" title="1、就绪态(Ready)"></a>1、就绪态(Ready)</h4><p>创建任务-&gt;就绪态(Ready)：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。</p><h4 id="2、运行态（Running）"><a href="#2、运行态（Running）" class="headerlink" title="2、运行态（Running）"></a>2、运行态（Running）</h4><p>就绪态-&gt;运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。</p><h4 id="3、运行态-gt-就绪态"><a href="#3、运行态-gt-就绪态" class="headerlink" title="3、运行态-&gt;就绪态"></a>3、运行态-&gt;就绪态</h4><p>运行态-&gt;就绪态：有更高优先级的任务创建或恢复后，会发生任务调度，此时就绪列表中最高优先级的任务变为运行态，那么原来运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务完毕继续运行原来的任务。</p><h4 id="4、阻塞态（Blocked）"><a href="#4、阻塞态（Blocked）" class="headerlink" title="4、阻塞态（Blocked）"></a>4、阻塞态（Blocked）</h4><p>运行态-&gt;阻塞态（Blocked）：正在运行的任务发生阻塞（延时、读取IO、读取信号量、等待通知等）时，该任务会从就绪列表中删除，任务状态由运行态变为阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。</p><h4 id="5、阻塞态-gt-就绪态"><a href="#5、阻塞态-gt-就绪态" class="headerlink" title="5、阻塞态-&gt;就绪态"></a>5、阻塞态-&gt;就绪态</h4><p>阻塞态-&gt;就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读取信号量超时或读取到了信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变为就绪态；如果此时被恢复任务的优先级高于当前正在执行任务的优先级，则会发生任务切换。</p><h4 id="6、挂起态（Suspended）"><a href="#6、挂起态（Suspended）" class="headerlink" title="6、挂起态（Suspended）"></a>6、挂起态（Suspended）</h4><p>就绪态、阻塞态、运行态-&gt;挂起态（Suspended）：任务可以通过调用vTaskSuspend()函数将处于任何状态的任务挂起，被挂起的任务得不到CPU使用权，也不会参与调度；</p><h4 id="7、挂起态-gt-就绪态"><a href="#7、挂起态-gt-就绪态" class="headerlink" title="7、挂起态-&gt;就绪态"></a>7、挂起态-&gt;就绪态</h4><p>挂起态-&gt;就绪态：把一个挂起态的任务恢复的唯一途径就是调用vTaskResume()函数，如果此时被恢复的任务优先级高于正在运行任务的优先级，则会发生任务切换；</p><h3 id="6-1-4、阻塞态与挂起态的理解"><a href="#6-1-4、阻塞态与挂起态的理解" class="headerlink" title="6.1.4、阻塞态与挂起态的理解"></a>6.1.4、阻塞态与挂起态的理解</h3><ul><li>触发task任务进入阻塞态的因素可能是自身主动delay延时、读取IO、读取信号量、等待通知等，而唤起阻塞态的task通常也是上面几种状态的时间或事件的到来，比如delay时间到、IO请求结束、等待的信号量或通知事件到来；</li><li>而task只能通过vTaskSuspend()进入挂起态，仅能通过vTaskResume()被重新唤起，通常在Windows、Linux中被挂起的task不参与系统调度，不占据CPU资源，甚至不占据内存空间，比如长时间不访问的网页，系统会将其从内存区局swap到外部磁盘，以释放系统资源，待task需要被唤醒时，才会重新加载进内存；</li></ul><h3 id="6-1-5、task任务调度"><a href="#6-1-5、task任务调度" class="headerlink" title="6.1.5、task任务调度"></a>6.1.5、task任务调度</h3><p>FreeRTOS中提供的任务调度器是基于优先级的全抢占式调度：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。<br>系统理论上可以支持无数个优先级（0～N，优先级数值越小的任务优先级越低，0为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级），假如使能了configUSE_PORT_OPTIMISED_TASK_SELECTION这个宏，一般强制限定最大可用优先级数目为32个。</p><p>FreeRTOS内核允许创建相同优先级的任务。相同优先级的任务采用时间片轮转的方式进行调度（也就是常说的分时调度），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保持系统的实时性，系统尽最大可能保证高优先级任务得以运行。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立即进行任务切换。</p><h3 id="6-1-6、优先级翻转"><a href="#6-1-6、优先级翻转" class="headerlink" title="6.1.6、优先级翻转"></a>6.1.6、优先级翻转</h3><p>我们知道任务的优先级在创建的时候就已经时设置好的，高优先级可以打断低优先级的任务，抢占CPU的使用权。但是在很多场合中，某个资源只有一个，当低优先级的任务正在占用该资源的时候，即便高优先级的任务也只能乖乖的等待低优先级任务是用完该资源后释放资源。这里高优先级任务无法运行而低优先级任务可以运行的现象称作优先级翻转</p><p>优先级翻转的危害很大，低优先级任务占用资源会导致高优先级任务阻塞时间过长，出现饿死问题。</p><p>需要注意的是，这种场景下，并不是不允许调度高优先级，而是高优先级任务与低优先级任务都需要访问该资源，但同一时刻只能有一个任务能够访问，所以即使发生调度，高优先级任务也无法获得CPU使用权，直到低优先级任务主动释放资源。</p><p>举个例子，现在有 3 个任务分别为 H 任务（High）、M 任务（Middle）、L 任务（Low），3 个任务的优先级顺序为 H 任务&gt;M任务&gt;L 任务。正常运行的时候 H 任务可以打断 M 任务与 L 任务，M 任务可以打断 L 任务，假设系统中有一个资源被保护了，此时该资源被 L 任务正在使用中，某一刻，H 任务需要使用该资源，但是L任务还没使用完，H任务则因为申请不到资源而进入阻塞态，L任务继续使用该资源，此时已经出现了”优先级翻转”现象，高优先级任务在等着低优先级的任务执行，如果在L任务执行的时候刚好M任务被唤醒了，由于 M 任务优先级比 L 任务优先级高，那么会打断 L 任务，抢占了CPU 的使用权，直到 M 任务执行完，再把 CUP 使用权归还给 L 任务，L 任务继续执行，等到执行完毕之后释放该资源，H 任务此时才从阻塞态解除，使用该资源。这个过程，本来是最高优先级的 H 任务，在等待了更低优先级的 L 任务与M任务，其阻塞的时间是M任务运行时间+L任务运行时间，这只是只有3个任务的系统，假如很多个这样子的任务打断最低优先级的任务，那这个系统最高优先级任务岂不是崩溃了，这个现象是绝对不允许出现的，高优先级的任务必须能及时响应。所以，没有优先级继承的情况下，使用资源保护，其危害极大</p><h3 id="6-1-7、优先级继承"><a href="#6-1-7、优先级继承" class="headerlink" title="6.1.7、优先级继承"></a>6.1.7、优先级继承</h3><p>在FreeRTOS操作系统中为了降低优先级翻转问题利用了优先级继承机制，优先级继承算法是指，暂时提高某个占有某种资源的低优先级任务的优先级，使之与在所有等待该资源的任务中优先级最高的那个任务优先级相等，而当低优先级任务执行完毕释放该资源时，优先级重新回到初始设定值。因此，继承优先级的任务避免了系统资源被任何中间优先级的任务抢占。</p><p>对应TCB结构体中的成员：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 任务优先级被临时提高时，保存任务原本的优先级        #if ( configUSE_MUTEXES &#x3D;&#x3D; 1 )            UBaseType_t        uxBasePriority;                    UBaseType_t        uxMutexesHeld;        #endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>uxBasePriority</code>用于记录优先级翻转之前的task优先级；</li><li><code>uxMutexesHeld</code> 记录当前task所持有的mutex，并以此查找其他持有mutex的task，匹配最高优先级；<h2 id="6-2、中断"><a href="#6-2、中断" class="headerlink" title="6.2、中断"></a>6.2、中断</h2><h3 id="6-2-1、中断控制器"><a href="#6-2-1、中断控制器" class="headerlink" title="6.2.1、中断控制器"></a>6.2.1、中断控制器</h3>FreeRTOS + Cortext-M系列中常用的中断控制器是NVIC，全称内嵌式向量中断控制器Nested Vectored Interrupt Controller，最多支持240个中断，中断最多可以有256个优先级<h3 id="6-2-2、中断与临界段"><a href="#6-2-2、中断与临界段" class="headerlink" title="6.2.2、中断与临界段"></a>6.2.2、中断与临界段</h3>FreeRTOS源码中有许多临界段，通常是采用关中断的港式实现，临界段虽然可以保护关键代码的执行不被打断，但也会影响系统的实时性。</li></ul><p>比如，某个时候有一个任务正在运行中，并且该任务的部分程序将中断屏蔽掉，也就是进入临界段中，这个时候如果有一个紧急的中断被触发，这个中断就会被挂起，不能得到及时响应，必须等到开中断后才可以重新得到响应，如果屏蔽中断时间超过了紧急中断能够容忍的限度，危害是可想而知的。</p><p>因此RTOS中调用中断屏蔽函数进入临界段的时候，需要快进快出。当然FreeRTOS也允许一些高优先级的中断不被屏蔽掉，以便能够及时做出响应。</p><h2 id="6-3、时钟"><a href="#6-3、时钟" class="headerlink" title="6.3、时钟"></a>6.3、时钟</h2><h3 id="6-3-1、CPU时钟"><a href="#6-3-1、CPU时钟" class="headerlink" title="6.3.1、CPU时钟"></a>6.3.1、CPU时钟</h3><p>CPU时钟通常采用晶体振荡器作为时钟源，以晶振频率来计数，故它并不是一个时间器，而是一个计数器，体现为CPU运行指令的频率，一个cpu周期称作一个cycle。 </p><h3 id="6-3-2、SysTick-系统时钟节拍"><a href="#6-3-2、SysTick-系统时钟节拍" class="headerlink" title="6.3.2、SysTick 系统时钟节拍"></a>6.3.2、SysTick 系统时钟节拍</h3><p>FreeRTOS的系统时钟的时钟来源通常有两种选择：CPU主频、CPU主频的八分频，默认使用的是CPU主频   </p><p>在任务上下文切换函数vTaskSwitchContext中，会判断每个任务的任务控制块里的延时成员xTicksToDelay的值是否为0，如果为0，表示延时时间到，将对应的任务变成就绪状态，如果不为0，就继续延时。<br>如果一个任务要延时，一开始xTicksToDelay肯定不为0，当xTicksToDelay变为0时，表示延时结束，那么xTicksToDelay是以什么周期在递减？在哪里递减？<br>在FreeRTOS中，这个周期是由SysTick中断提供，操作系统里面最小的时间单位就是SysTick的中断周期，我们称之为一个tick。</p><p>SysTick是硬件定时，所以即使SysTick中中断服务的优先级很低，被其他中断打断也不会影响tickcout的计数操作。<br>【也就是说SysTick中断只有中断服务函数的响应与不响应，与tick的计数无关，它会一直在硬件层面计数】</p><p>这里需要区分CPU频率，比如2.3GHz，指的是cpu运行指令的频率，与tick不同，通常一个tick要远大于cpu周期cycle，这样一个tick周期内才可以让cpu跑多个cycle，让cpu干更多的活。    </p><p>FreeRTOS的tick由宏控制   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define configTICK_RATE_HZ ( ( TickType_t ) 1000 )  &#x2F;&#x2F; 1ms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>FreeRTOS与SysTick相关的时间函数有四个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">vTaskDelay ()vTaskDelayUntil ()xTaskGetTickCount()xTaskGetTickCountFromISR() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-3、FreeRTOS时钟源"><a href="#6-3-3、FreeRTOS时钟源" class="headerlink" title="6.3.3、FreeRTOS时钟源"></a>6.3.3、FreeRTOS时钟源</h3><p>FreeRTOS 任务代码中常用的时钟源为RTC(Real-Time Clock)<code>uint64_t rtcGetTime(void)</code></p><p>通过源码可以看到RTC的晶振频率为13MHz，大概为MTK mcu主频的1/8，可以精确奥ns</p><h2 id="6-4、task通信方式"><a href="#6-4、task通信方式" class="headerlink" title="6.4、task通信方式"></a>6.4、task通信方式</h2><p>FreeRTOS 任务间通信有两种方法：</p><ul><li>直接发送给task自身的，比如通知(Notification)；</li><li>是使用通信对象(Communication objects)； </li></ul><p>主要区别在于通知是发给一个指定的任务，直接改变该任务TCB的某些变量；通信对象是独立于任务的实体，有单独的存储空间，可以实现数据传递和较复杂的同步、互斥功能。</p><h3 id="6-4-1、mutex锁"><a href="#6-4-1、mutex锁" class="headerlink" title="6.4.1、mutex锁"></a>6.4.1、mutex锁</h3><p>互斥量是信号量的一种，与二值信号量类似，两者最大的不同是：互斥量具有优先级继承机制，而信号量没有。也就是说，某个临界资源受到互斥量保护，如果这个资源正在被低优先级任务使用，那么此时的互斥量是闭锁状态，也代表了没有任何其他任务可以申请到这个互斥量，如果此时有个高优先级任务想要对这个资源进行访问，去申请这个互斥量，那么高优先级任务会因为申请不到互斥量而进入阻塞态，那么系统会将现在持有该互斥量的任务的优先级提升到与高优先级任务的优先级相同，这个优先级提升的过程称作优先级继承机制。这个优先级继承机制确保高优先级任务进入阻塞态的时间尽可能的短，以及将已经出现的优先级翻转危害降低到最小。</p><h3 id="6-4-2、任务通知-Notification"><a href="#6-4-2、任务通知-Notification" class="headerlink" title="6.4.2、任务通知 Notification"></a>6.4.2、任务通知 Notification</h3><p>FreeRTOS中任务通知模式默认开启，开启后TCB结构体之中会多出两个成员：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#if( configUSE_TASK_NOTIFICATIONS &#x3D;&#x3D; 1 )        volatile uint32_t ulNotifiedValue;        volatile uint8_t ucNotifyState;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>ulNotifiedValue 接收方的通知值；</li><li>ucNotifyState 接收方的通知状态</li></ul><h4 id="1、通知值ulNotifiedValue"><a href="#1、通知值ulNotifiedValue" class="headerlink" title="1、通知值ulNotifiedValue"></a>1、通知值ulNotifiedValue</h4><p>每个task任务都有一个32位的通知值，任务创建时，这个值被初始化为0。task任务通知相当于直接向任务发送一个事件，接收到通知的任务可以解除阻塞状态，前提是这个阻塞task是因等待通知而引起的。发送通知的同时，也可以可选的改变接收方的通知值。</p><p>接收方更新通知：</p><ul><li>不覆盖接收方的通知值；</li><li>覆盖接收方的通知值；</li><li>设置接收方通知值的某些位；</li><li>增加接收方的通知值（递增）；</li></ul><p>相较于队列、二进制信号量、计数信号量或事件组，使用任务通知更灵活，它无需在使用前单独创建类似前面的通信对象。而且相比于使用信号量解除任务阻塞，使用任务通知可以快45%、使用更少的RAM（使用GCC编译器，-o2优化级别）。</p><h4 id="2、通知状态ucNotifyState"><a href="#2、通知状态ucNotifyState" class="headerlink" title="2、通知状态ucNotifyState"></a>2、通知状态ucNotifyState</h4><p>task的通知状态有三种：</p><ul><li>not waiting notification;</li><li>wating notification;</li><li>received notification;</li></ul><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE6908ac65afa05a2ff716568ad4d9d1d4/41074" alt="imag320"></p><h4 id="3、常见API函数"><a href="#3、常见API函数" class="headerlink" title="3、常见API函数"></a>3、常见API函数</h4><table><thead><tr><th>发送方</th><th>接收方</th></tr></thead><tbody><tr><td>xTaskNotify()</td><td>xTaskNotifyWait()</td></tr><tr><td>xTaskNotifyGive()</td><td>rulTaskNotifyTake()</td></tr></tbody></table><p><font color=red><strong>任务通知函数对 01</strong></font><br>xTaskNotify与xTaskNotifyWait</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BaseType_t xTaskNotify( TaskHandle_txTaskToNotify,                         uint32_t ulValue,                         eNotifyAction eAction);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数：</p><ul><li>xTaskToNotify：被通知的任务句柄；</li><li>ulValue：通知更新值；</li><li>eAction：枚举类型，指明更新通知值的方法；</li></ul><p>枚举变量成员以及作用如下表所示：<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE05d506525ccf9516564465181476d00b/41086" alt="image21"></p><p><strong>返回值</strong>：<br> 参数eAction若为eSetValueWithoutOverwrite时，如果接收方务还没取走上一个通知，又接收到了一个通知，则这次通知值未能更新并返回pdFALSE，否则返回pdPASS</p><p><font color=red><strong>任务通知函数对 02</strong></font><br>xTaskNotifyGive与rulTaskNotifyTake</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实这是一个宏，本质上相当于xTaskNotify( ( xTaskToNotify ), ( 0 ), eIncrement )。可以使用该API函数代替二进制或计数信号量，速度更快。   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">uint32_t ulTaskNotifyTake( BaseType_txClearCountOnExit,                            TickType_txTicksToWait );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数：   </p><ul><li>xClearCountOnExit：如果该参数设置为pdFALSE，则API函数xTaskNotifyTake()退出前，将任务的通知值减1；如果该参数设置为pdTRUE，则API函数xTaskNotifyTake()退出前，将任务通知值清零；</li><li>xTicksToWait：因等待通知而进入阻塞状态的最大时间。时间单位为系统节拍tick。宏pdMS_TO_TICKS用于将指定的毫秒时间转化为相应的系统节拍数;</li></ul><p>API函数xTaskNotifyTake()有两种方法处理任务的通知值，一种方法是在函数退出时将通知值清零，这种方法适用于实现二进制信号量；另外一种方法是在函数退出时将通知值减1，这种方法适用于实现计数信号量。</p><h3 id="6-4-3、信号量"><a href="#6-4-3、信号量" class="headerlink" title="6.4.3、信号量"></a>6.4.3、信号量</h3><p>信号量是操作系统中的概念，在实现任务、进程、线程同步过程中扮演重要的角色，它一种通信对象，需要创建后才可以使用，若不再需要可以调用 vSemaphoreDelete()  进行删除，释放占用的内存。  </p><p>FreeRTOS 提供以下四种类型信号量：</p><table><thead><tr><th>类型</th><th>创建方法</th></tr></thead><tbody><tr><td>普通类/二进制信号量</td><td>xSemaphoreCreateBinary</td></tr><tr><td>计数信号量</td><td>xSemaphoreCreateCounting</td></tr><tr><td>互斥锁</td><td>xSemaphoreCreateMutex</td></tr><tr><td>嵌套互斥锁</td><td>xSemaphoreCreateRecursiveMutex</td></tr></tbody></table><p>前三类信号量都是用 xSemaphoreTake() 和 xSemaphoneGive() 两个 API 分别进行”获取”和”给予”操作。</p><ul><li>普通\二进制的信号量只有两个状态（有/无）；</li><li>计数型的可以是0到某个数之间的整数，代表资源的余量。它们看起来和任务通知的用法很像，也的确经常可以用任务通知替代；</li><li>互斥锁(mutex, 这个词是 mutual exclusion 缩写而来)也只有两个状态，但用法不同。互斥锁用来避免多个任务争用同一资源时的竞态问题，当任务获取它以后别的任务都不能再获取而只能阻塞，直到取得它的任务将其交还出来；</li><li>嵌套互斥锁(recursive mutex)是让同一个任务可以重复申请已取得的互斥锁，避免自己造成死锁这种不合逻辑的现象。对应的操作函数是 xSemaphoreTakeRecursive() 和 xSemaphoreGiveRecursive(). 例如，某任务先获得这个锁，然后调用一个子程序，子程序中又再次申请获得这个锁，那么既然资源是自己独占的，这个申请立即成功。子程序进行一些操作后释放该锁，但更早的申请还有效，资源仍然属于这个任务独占。<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1、FreeRTOS的低功耗模式"><a href="#1、FreeRTOS的低功耗模式" class="headerlink" title="1、FreeRTOS的低功耗模式"></a>1、FreeRTOS的低功耗模式</h3>FreeRTOS 的低功耗模式又称作tickless模式。<br>仅从字母上看 tick 是滴答时钟的意思，less是tick的后缀，表示较少的，这里的含义可以表示为无滴答时钟。 整体看这个字母就是表示滴答时钟节拍停止运行的情况。反映在 FreeRTOS 上，tickless又是怎样一种情况呢？<br>我们都知道，当用户任务都被挂起或者阻塞时，最低优先级的空闲任务会得到执行。 那么 STM32 支持的睡眠模式，停机模式就可以放在空闲任务里面实现。为了实现低功耗最优设计，我们还不能直接把睡眠或者停机模式直接放在空闲任务里。进入空闲任务后，首先要计算可以执行低功耗的最大时间，也就是求出下一个要执行的高优先级任务还剩多少时<br>间。 然后就是把低功耗的唤醒时间设置为这个求出的时间，到时间后系统会从低功耗模式被唤醒，继续执行多任务。这个就是所谓的 tickless 模式。<br>从上面的讲解中可以看出，实现 tickless 模式最麻烦是低功耗可以执行的时间如何获取。 关于这个问题，FreeRTOS 已经为我们做好了。<br>系统进入低功耗模式的条件可以总结为以下两个：   </li></ul><ul><li>当前空闲任务正在运行，所有其它的任务处在挂起状态或者阻塞状态；</li><li>根据用户配置 configEXPECTED_IDLE_TIME_BEFORE_SLEEP的大小，只有当系统可运行于低功耗模式的时钟节拍数大于等于这个参数时，系统才可以进入到低功耗模式；</li></ul><h3 id="2、内存的实时性"><a href="#2、内存的实时性" class="headerlink" title="2、内存的实时性"></a>2、内存的实时性</h3><p>FreeRTOS没有虚拟内存机制<br>通常在RTOS中，由于实时性的要求，很少使用虚拟内存机制。所有的内存操作都需要用户自行管理，直接操作物理内存，故，所分配的内存不能超过物理内存地址空间。 同时，RTOS对内存的分配时间要求更为苛刻，分配内存的时间必须是确定的，必须要保证内存块的分配过程在可预测的时间内完成，否则系统对外部事件的响应将变得不确定，进而扰乱系统的实时性。</p><h1 id="7、中断"><a href="#7、中断" class="headerlink" title="7、中断"></a>7、中断</h1><p>在阐述中断概念之前需要解释一下中断与异常的关系，其实异常的称呼来自于Intel的微处理器架构，将同步中断称之为异常，后文以中断为总称，异常特指同步中断。   </p><p>从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生电信号，通过总线把电信号发送给中断控制器（如 NVIC、APIC），再由中断控制器生成中断请求发送给CPU。</p><p>如果中断的线是激活的，中断控制器就把中断请求发送给处理器的某个特定引脚，处理器于是立即停止自己正在做的事，跳转到中断处理程序的入口点，进行中断处理，处理完后，再回到被中断的地方，继续原来的工作。    </p><p>从广义上来讲，中断不仅仅是外部设备发出的电信号，也可能来自于CPU内部的指令， 比如软中断、异常等。   </p><p>中断是导致处理器脱离正常运行转向执行特殊代码的任何事件，如果不及时处理，轻则系统出错，重则会导致系统毁灭性瘫痪。所以正确的处理中断，避免错误的发生是提高软件稳定性非常重要的一环，对于实时操作系统更是如此。</p><h2 id="7-1、中断的分类"><a href="#7-1、中断的分类" class="headerlink" title="7.1、中断的分类"></a>7.1、中断的分类</h2><p>根据中断源产生的条件，中断通常可以分为两类：</p><ul><li>同步中断：也称作异常，由CPU内部事件产生<br>包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等。</li><li>异步中断：由外部设备源产生的中断<br>包括外部IO设备，例如鼠标、键盘、引起时钟中断的定时器晶振设备等</li></ul><p>同步中断与异步中断的区别还在于：同步中断发生时，系统必须立刻进行处理而不能继续执行原有的指令步骤，而异步中断则可以延缓处理甚至忽略，例如按键中断，系统可以忽略键盘发出的Ctrl + C中断。   </p><p>硬中断与软中断详见：<strong>7.5节</strong></p><h2 id="7-2、中断控制器"><a href="#7-2、中断控制器" class="headerlink" title="7.2、中断控制器"></a>7.2、中断控制器</h2><p>与中断相关的硬件可划分为三类：外设、中断控制器、CPU</p><ul><li><p>外设：当外设需要请求CPU时会产生一个电信号，该信号连接至中断控制器；</p></li><li><p>中断控制器：中断控制器也是CPU众多外设中的一个，它一方面接收其他外设发出的中断信息，另一方面也会向CPU发出中断请求。可以通过对中断控制器编程以实现对中断的优先级设置、触发方式的选择、打开和关闭等操作；</p></li><li><p>CPU：对中断进行响应，同时也可以在指令层面产生异常、软中断；</p></li></ul><p>常见的中断控制器有NVIC、APIC：</p><ul><li>NVIC：详见：<strong>第6节中断控制器</strong>；</li><li>APIC：高级可编程中断控制器Advanced Programmable Interrupt Controller，是linux系统主流的中断控制器；</li></ul><h2 id="7-3、IRQ"><a href="#7-3、IRQ" class="headerlink" title="7.3、IRQ"></a>7.3、IRQ</h2><p>对于外部设备源，它发出的只是特殊的电信号，需要借由中断控制器的标准组件转换成可以被CPU所能识别的中断请求，这种请求称作IRQ，全称Interrupt Request。<br>中断控制器的标准组件所做的工作包括查询中断向量表、查找中断服务函数等。、</p><h2 id="7-4、中断处理程序"><a href="#7-4、中断处理程序" class="headerlink" title="7.4、中断处理程序"></a>7.4、中断处理程序</h2><p>可以理解成一种很”轻”的task，它的上下文很少，建立或终止中断处理需要的时间也很，少它运行在非任务的执行环境下，一般为芯片的一种特殊运行模式，也称作特权模式。   </p><p>中断处理程序是内核运行的最敏感程序之一，因此它必须满足一下约束：</p><ul><li>当内核正打算去完成一些别的事情时，中断随时会到来。因此，内核的目标就是让中断尽可能快地处理完，尽其所能把更多的处理向后推迟。因此，内核响应中断后需要进行的操作分为两部分：关键而紧急的部分，内核立即执行；其余推迟的部分，内核随后执行;</li><li>因为中断随时会到来，所以内核可能正在处理其中的一个中断时，另一个不同类型的中断又发生了。内核应该尽可能地允许这种情况发生，因为这能维持更多的I/O设备得到处理的机会。因此，中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式执行。当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核也应能切换到另外的进程;</li><li>尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核，尤其是中断处理程序，应该在大部分时间内以开中断的方式运行;</li></ul><h3 id="7-4-1、异常处理步骤"><a href="#7-4-1、异常处理步骤" class="headerlink" title="7.4.1、异常处理步骤"></a>7.4.1、异常处理步骤</h3><ul><li>当发生异常时，CPU控制单元产生一个中断出错码；</li><li>CPU根据该中断码在中断向量表内的查找对应向量，根据该向量转到中断处理程序；</li><li>中断处理程序处理完之后向当前进程发送一个SIG***信号；</li><li>若进程定义了相应的信号处理程序则转移到相应的程序执行，若没有，则执行内核定义的操作；</li></ul><h3 id="7-4-2、中断处理步骤"><a href="#7-4-2、中断处理步骤" class="headerlink" title="7.4.2、中断处理步骤"></a>7.4.2、中断处理步骤</h3><ul><li>设备产生中断；</li><li>中断控制器产生一个对应的中断向量；</li><li>与中断向量表中的每一个中断向量进行比较，转到对应的中断处理程序；</li><li>中断处理程序保存当前运行进程的现场等相关工作；</li><li>中断处理结束，内核调度，重新返回被中断之前的进程；</li></ul><h2 id="7-5、硬中断与软中断"><a href="#7-5、硬中断与软中断" class="headerlink" title="7.5、硬中断与软中断"></a>7.5、硬中断与软中断</h2><ul><li>硬中断：通常就是指由外部设备产生的异步中断；</li><li>软中断：为了满足实时系统的要求，中断处理应该是越快越好。操作系统为了实现这个特点，当中断发生的时候，通常硬中断处理那些短时间就可以完成的工作，而将那些需要时间比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成，即bottom-half。</li></ul><h3 id="7-5-1、硬件中断的上半部和下半部"><a href="#7-5-1、硬件中断的上半部和下半部" class="headerlink" title="7.5.1、硬件中断的上半部和下半部"></a>7.5.1、硬件中断的上半部和下半部</h3><p>硬件中断的分类：</p><ul><li>紧急的：这类中断必须立即执行；</li><li>非紧急的：也必须立即执行；</li><li>非紧急可延迟的：半部立即执行，下半部延迟执行</li></ul><p>硬件中断处理程序是一个快速、异步、简单地对硬件做出迅速响应并在最短时间内完成必要操作的中断处理程序。硬中断处理程序可以抢占内核任务并且执 行时还会屏蔽同级中断或其它中断，因此中断处理必须要快、不能阻塞。这样一来对于一些要求处理过程比较复杂的任务就不合适在中断任务中一次处理。比如，网卡接收数据的过程中,首先网卡发送中断信号告诉CPU来取数据，然后系统从网卡中读取数据存入系统缓冲区中，再下来解析数据然后送入应用层。这些如果都让中断处理程序来处理显然过程太长，造成新来的中断丢失。因此Linux开发人员将这种任务分割为两个部分，一个叫上半部分，即中断处理程序，短平快地处理与硬 件相关的操作（如从网卡读数据到系统缓存）；而把对时间要求相对宽松的任务（如解析数据的工作）放在另一个部分执行，这个部分就是我们这里要讲的下半部分。</p><p> 下半部分是一种推后执行任务，它将某些不那么紧迫的任务推迟到系统更方便的时刻运行。因为并不是非常紧急，通常还是比较耗时的，因此由系统自行安排运行时机，不在中断服务上下文中执行。内核中实现 下半底的手段经过不断演化，目前已经从最原始的BH(bottom half)演生出BH、任务队列（Task queues）、软中断（Softirq）、Tasklet、工作队列（Work queues）（2.6内核中新出现的）。</p><h3 id="7-5-1、软中断指令"><a href="#7-5-1、软中断指令" class="headerlink" title="7.5.1、软中断指令"></a>7.5.1、软中断指令</h3><p>软中断是由指令产生的：</p><ul><li>int就是软中断指令</li><li>中断向量表是中断号和中断处理函数地址的对应表；</li><li>int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n；</li></ul><p>比如int 80就是系统调用中断指令，当用户态需要调用内核态时发生</p><h3 id="7-5-2、硬中断和软中断的区别"><a href="#7-5-2、硬中断和软中断的区别" class="headerlink" title="7.5.2、硬中断和软中断的区别"></a>7.5.2、硬中断和软中断的区别</h3><ul><li>软中断是执行中断指令产生的，而硬中断是由外设引发的；</li><li>硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器；</li><li>硬中断是可屏蔽的，软中断不可屏蔽；</li><li>硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部；</li><li>软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部；</li></ul><h3 id="7-5-3、信号与软中断"><a href="#7-5-3、信号与软中断" class="headerlink" title="7.5.3、信号与软中断"></a>7.5.3、信号与软中断</h3><ul><li>首先要区分信号与信号量不同，信号量是进程、线程的一种通信方式；</li><li>信号属于软中断的一种，有中断指令产生，信号可能来自于外部设备，也可能来自于CPU内部，比如Ctrl + C终止task运行信号、SIGSEGV地址访问越界信号；</li></ul><p>Ctrl + C会导致内核向task发送一个SIGINT信号，当task收到后：</p><ul><li>调用task已经通过signal\sigaction函数注册好的响应处理函数，对信号进行处理；</li><li>未注册响应函数时，调用OS默认函数，即终止当前进程；</li><li>可以选择忽略该信号；</li></ul><p>信号是一种用于内核向进程通告某种事件的发生的载体，每一个信号在物理上就是一个数字编码。Linux中有64个信号：</p><ul><li>前31个，属于非实时信号，重复发送的非实时信号会被丢弃；</li><li>其他的信号属于实时信号，重复发送的实时信号会被记录，然后依次处理；</li></ul><h2 id="7-6、中断与临界段"><a href="#7-6、中断与临界段" class="headerlink" title="7.6、中断与临界段"></a>7.6、中断与临界段</h2><p>详见：<strong>计算机系统_贰.6.2.2节.中断与临界段</strong></p><h1 id="8、寄存器"><a href="#8、寄存器" class="headerlink" title="8、寄存器"></a>8、寄存器</h1><h2 id="8-1、寄存器分类"><a href="#8-1、寄存器分类" class="headerlink" title="8.1、寄存器分类"></a>8.1、寄存器分类</h2><p><font color=red>PS：这里的地址根据场景的不同而分别指代虚拟地址与物理地址，对于具有虚拟内存技术的OS而言，寄存器之中地址多数情况下是虚拟地址，而不具备虚拟内存技术的OS之中，都是物理地址，比如RTOS。</font></p><p>寄存器的种类有很多种，这里主要介绍比较常见的几种：</p><ul><li>数据寄存器：<br>Data Register,DR，又称作数据缓存器，主要用来保存操作数和运算结果等信息，作为CPU和主存、外设之间信息传输的中转站，用以弥补CPU和主存、外设之间操作速度上的差异；</li><li>指令寄存器：<br>Instruction Register，IR，存储当前正在执行的指令，当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。指令包括操作码和地址码两个字段；</li><li>程序计数器寄存器：<br>Program Counter，PC，用来指出下一条指令的地址。在程序执行之前，首先将程序的首地址，即程序第一条指令所在的地址送入PC。当执行指令时，CPU能自动递增PC的内容，使其始终保存将要执行的下一条指令的地址，为取下一条指令做好准备；</li><li>地址寄存器：<br>Address Register，AR，用来保存CPU当前所访问的主存单元的地址。<br>由于在主存和CPU之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。<br>当CPU和主存进行信息交换，即CPU向主存存入数据/指令或者从主存读出数据/指令时，都要使用地址寄存器和数据寄存器；</li></ul><h1 id="9、CPU相关"><a href="#9、CPU相关" class="headerlink" title="9、CPU相关"></a>9、CPU相关</h1><h2 id="9-1、CPU、MCU、MPU、DSP"><a href="#9-1、CPU、MCU、MPU、DSP" class="headerlink" title="9.1、CPU、MCU、MPU、DSP"></a>9.1、CPU、MCU、MPU、DSP</h2><p>CPU(Central Processing Unit,中央处理器)，它发展出三个分支：   </p><ul><li>DSP(Digital Signal Processor,数字信号处理)；</li><li>MCU(Micro Control Unit,微控制单元)，多用于集成外围设备，强调不同设备间、设备与操作系统间的流程控制性；</li><li>MPU(Micro Processor Unit,微处理单元)，强调算力密集型；</li></ul><h2 id="9-2、多核CPU架构"><a href="#9-2、多核CPU架构" class="headerlink" title="9.2、多核CPU架构"></a>9.2、多核CPU架构</h2><h3 id="9-2-1、多核处理器分类"><a href="#9-2-1、多核处理器分类" class="headerlink" title="9.2.1、多核处理器分类"></a>9.2.1、多核处理器分类</h3><p>从硬件的角度来看，多核设计分为两类：</p><ul><li>同构多核（homogeneous）：所有的核心具有相同的构架；</li><li>异构多核（heterogeneous）：核心core之间存在多种结构；</li></ul><p>从应用来看，同构多核处理器中大多数由通用处理器核构成，每个核可以独立运行，类似单核处理器。而异构多核处理器往往同时集成了通用处理器、DSP、FPGA、媒体处理器、网络处理器等。每个内核针对不同的需求设定，从而提高应用的计算性能或实时性能。</p><p>常见的异构多核处理器有：MTK的next系列(ARM + DSP)或者称作(Cortex-M4 + DSP)，高通的adsp系列(ARM + DSP) 。<br>同构多处理器就比较多了，日常台式机、笔记本、服务器上的Intel、AMD的商用系列。</p><h3 id="9-2-2、多核处理器运行模式"><a href="#9-2-2、多核处理器运行模式" class="headerlink" title="9.2.2、多核处理器运行模式"></a>9.2.2、多核处理器运行模式</h3><p>从软件的角度来看，多核处理器的运行模式有三种：</p><ul><li><p>SMP-对称多处理，symmetric multi-processing；</p></li><li><p>AMP-非对称多处理，asymmetric multi-processing；</p></li><li><p>BMP-边界多处理（翻译不确定），bound multi-processing；</p></li></ul><p><font color=red>AMP - </font>  </p><ul><li>多个核心相对独立的运行不同的任务，每个核心通常运行不同的操作系统；</li><li>但是有一个主要核心，用来控制整个系统以及其它从核心，具有主从模式<br>举个例子，比如一个主要核心控制用户界面UI，从核心控制数据采集以及输出。还有POS机，一个负责UI，一个负责交易。也就是两者负责不同的任务。</li><li>每个核心有自己独立的内存空间，同时也支持共享的内存空间；</li><li>各个核心之间还有一定的通信机制；</li><li>从硬件上来说，AMP的多核通常是异构的<br>如MCU+DSP，MCU+FPGA等</li></ul><p><font color=red>SMP - </font>   </p><ul><li>这个是目前用的最多的，一个OS同等的管理所以内核，为各个内核分配工作负载；</li><li>大多数的系统都支持SMP模式，如Linux，Vxworks，windows；</li><li>所有的核心共享内存；</li><li>这种模式通常都是同构多核处理器，因为异构的结构不同，实现比较复杂；</li></ul><p>BMP-边界多处理，和SMP类似，也是一个OS管理所有内核，但是不同的是，BMP中，开发者可以指定将某个任务仅在某个指定内核上执行</p>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统_壹</title>
      <link href="2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%A3%B9/"/>
      <url>2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E5%A3%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="0、基础部分"><a href="#0、基础部分" class="headerlink" title="0、基础部分"></a>0、基础部分</h1><h2 id="0-1、从源码到task：进程、线程"><a href="#0-1、从源码到task：进程、线程" class="headerlink" title="0.1、从源码到task：进程、线程"></a>0.1、从源码到task：进程、线程</h2><ul><li>源码：程序员按照语法规则书写的文本文件；</li><li>可执行文件&amp;可链接库：源码经过预处理、编译、汇编、链接而成的二进制文件，与操作系统强绑定，可执行文件也称作程序；</li><li>task：进程、线程：可执行文件经过操作系统loader进内存之中，参与内核调度，task称作程序的运行实体；</li></ul><h2 id="0-2、程序的局部性原理"><a href="#0-2、程序的局部性原理" class="headerlink" title="0.2、程序的局部性原理"></a>0.2、程序的局部性原理</h2><p>包括时间局部性和空间局部性。即最近被CPU访问的数据，短期内CPU 还要访问（时间）；被 CPU 访问的数据附近的数据，CPU 短期内还要访问（空间）。因此如果将刚刚访问过的数据缓存在Cache中，那下次访问时，可以直接从Cache中取，其速度可以得到数量级的提高。<br>此理论是CPU Cache、TLB技术的理论基础。  </p><h2 id="0-3、并发与并行"><a href="#0-3、并发与并行" class="headerlink" title="0.3、并发与并行"></a>0.3、并发与并行</h2><ul><li>例如单核CPU，其对指令的处理都是顺序执行，是一种时间上分时交替处理，给用户一种同时发生的表象，这就是并发；</li><li>并行是指令同一时刻一起运行，这种方式一般在多处理器系统中发生；<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE6b2c709c42fa73920bb4acc2ccc2b13a/39430" alt="image13"></li></ul><h2 id="0-4、进程、线程、协程"><a href="#0-4、进程、线程、协程" class="headerlink" title="0.4、进程、线程、协程"></a>0.4、进程、线程、协程</h2><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEdd745cbe5baa6545fe0005042d80f87b/39433" alt="image14"></p><ul><li>进程  </li></ul><p>进程是一种程序的动态执行过程，进程对CPU并不是独占连续执行的，OS管理所有进程，并对它们进行监控调度。内核中有一个结构体叫做进程控制块PCB(RTOS中称作任务控制块TCB)-(Process Control Block),该结构体包含了该进程几乎所有的信息和资源，OS可以通过这个控制块来获得进程信息并管理进程。<br>进程的设计是为了让各个应用程序能够更好的进行隔离，彼此的运行互不影响，每个进程都有自己独立的内存空间，并且通过内存管理模块MMU和页表机制使得各个进程之间形成了隔离。</p><p>在多进程的并发场景下，势必需要保存当前进程现场信息，比如寄存器，堆栈，更新页表，甚至还需要从外存(比如磁盘中)置换出进程信息等，这样对于CPU的开销非常大，于是为了减少开销便有了进程内的线程并发。</p><ul><li>线程</li></ul><p>进程的目的是隔离并发，那么线程实现的是共享并发，所有的线程共用进程的资源，线程是进程指令流的剥离。<br>由于线程资源共享，所以各个线程之间存在相互的影响，如果一个线程出现崩溃、紊乱，极大可能会影响到该进程中的其他线程，同时对于共享资源的读写操作便会引起竞争问题，那么就产生了一系的共享资源的处理办法，如临界区、互斥、信号等等。</p><p>目前大部分OS对线程的管理、调度和并发都是通过内核完成的，这样就会存在较多系统调用以及从用户态到内核态的切换，会消耗一些时间。为了更进一步减少开销，直接在用户态实现并发便引申出了协程的概念。</p><ul><li>协程</li></ul><p>其实函数调用就类似一种协程的概念，A函数中调用B函数，可以认为是A任务切换到B任务来执行，然后执行完回到A任务，不过这样调用的任务始终是从初始状态开始，如果一个函数能够主动放弃CPU并保存当前现场，然后切换到另外一个函数之前保存的现场，便实现了任意状态函数的并发执行，就实现了协程。  </p><h2 id="0-5、句柄"><a href="#0-5、句柄" class="headerlink" title="0.5、句柄"></a>0.5、句柄</h2><p>句柄是Windows编程中的一个重要概念，是32位无符号整型，表示一个对象的内存地址列表的索引，是分配给资源的唯一标志，这里的对象是指应用程序、窗口、位图等资源对象。     </p><p>句柄并没有直接指向资源对象，而是保存着资源对象在资源注册列表中的索引，也就是说，句柄是间接指向资源对象。资源对象加载到内存时需要将首地址在资源列表中中进行注册，注册后无论资源对象的地址是否发生变化，其在资源列表中的注册位置始终不变。    </p><p>这种设计的原因是资源对象加载到内存后，其地址可能会发生变化。如果资源对象在系统中一直处于空闲状态，操作系统的内存管理模块会将其内存回收，释放给其他资源使用。如果再次访问这个资源，系统会重新为其分配内存。    </p><p>句柄解决了资源对象地址发生变化导致访问失败的问题，资源对象的物理地址是由资源注册列表负责维护，因此句柄只是间接访问资源对象，不需要关心资源对象的物理地址。    </p><p>指针可以修改指向的值，但句柄只能访问资源对象，不能进行修改。</p><h2 id="0-6、main函数"><a href="#0-6、main函数" class="headerlink" title="0.6、main函数"></a>0.6、main函数</h2><p>main函数是程序的入口，这种说法是不准确的。因为通常main函数的返回类型是int，那么必然有地方接收这个返回值，所以从这个角度而言，必然有其他地方在调用main函数，那么main函数就不是程序的第一入口。<br>在main函数之前和之后都发生了什么？<br>main函数之前会调用全局对象和静态对象的构造函数，初始化全局变量和静态变量；main函数之后会调用在atexit函数中注册的函数接收main的返回值。</p><h2 id="0-7、程序加载过程"><a href="#0-7、程序加载过程" class="headerlink" title="0.7、程序加载过程"></a>0.7、程序加载过程</h2><p>参见<strong>计算机系统_壹.4、虚拟内存.</strong></p><h2 id="0-8、计算机是如何启动-重启的？"><a href="#0-8、计算机是如何启动-重启的？" class="headerlink" title="0.8、计算机是如何启动/重启的？"></a>0.8、计算机是如何启动/重启的？</h2><ul><li><p>启动/重启计算机时，相关寄存器进行初始化<br><code>CS：FFFF  IP：0000</code><br>该指令是一条跳转指令   </p></li><li><p>FFFF跳转到ROM/BIOS，开始执行BIOS中的指令；  </p></li><li><p>BIOS中存放的是括装机时就烧录好的一些信息，例如系统参数，开机引导程序等；</p></li><li><p>BIOS将位于硬盘之中主引导扇区的开机引导程序加载到内存，包含指令：  </p><ul><li>A、加载操作系统的自举代码进内存   </li><li>B、执行操作系统自举代码的指令   </li></ul></li><li><p>BIOS的最后一条指令是跳转指令，跳转至已被加载到内存中的开机引导程序的指令处，然后依次执行A、B指令，进入OS的世界</p></li></ul><h2 id="0-9、POSIX标准"><a href="#0-9、POSIX标准" class="headerlink" title="0.9、POSIX标准"></a>0.9、POSIX标准</h2><p>POSIX标准是Unix\Linux可移植性操作系统接口，它规定了操作系统必须提供的：   </p><ul><li>系统服务；</li><li>函数库，包含头文件和库文件；  </li></ul><p>早期，不同操作系统使用不同的系统实现，比如printf函数在不同操作系统中C的实现方式可能千差万别。之后IEEE发布POSIX标准，规定不同的Unix\Linux必须遵守统一的POSIX标准，提供标准的系统服务、函数库，这样开发者在Unix\Linux上能够使用统一的头文件声明，而不用关心不同操作系统的具体实现方式，程序可以在同一标准的系统间移植。   </p><h1 id="1、程序内存空间"><a href="#1、程序内存空间" class="headerlink" title="1、程序内存空间"></a>1、程序内存空间</h1><p><font color=red><strong>程序</strong>：是指令、数据及其组织形式的描述实体</font>，<br>C和C++程序的内存空间从低地址到高地址大致包括：</p><ul><li>text 代码段；</li><li>.rodata 常量区</li><li>data 数据段</li><li>bss(Block Started by Symbol)</li><li>heap 堆</li><li>stack 栈</li></ul><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE3fb96316229f9e3c66564b3928a3a324/38736" alt="image01"></p><h2 id="1-1、text代码段"><a href="#1-1、text代码段" class="headerlink" title="1.1、text代码段"></a>1.1、text代码段</h2><ul><li>用于存放可执行文件的运行指令，属于只读内存空间；</li><li>也可能包括一些只读常量，比如字符串常量；</li></ul><h2 id="1-2、-rodata常量区"><a href="#1-2、-rodata常量区" class="headerlink" title="1.2、.rodata常量区"></a>1.2、.rodata常量区</h2><p>存储只读常量的内存空间称作常量区</p><ul><li><p>字符串字面量==自身==会被默认编译进rodata;</p></li><li><p>全局实数常量会编译进rodata【<strong>不一定正确</strong>】;</p><ul><li>特例：(全局、局部)实数常量会以立即数的形式直接编译进指令之中，位于text段，参见<strong>C++.md的6.3节</strong>；</li></ul></li><li><p>对于字符串字面量，编译器会做去重处理，保证全局只有一份字符串字面量。但字面量实数不会去重；</p></li><li><p>const修饰的全局常量；</p><ul><li>特例：const char *，由于修饰的是指针指向的对象，故此种情况指针不是rodata，只有在修饰指针自身的时候才是rodata，const char * const;</li></ul></li><li><p>const修饰的局部变量，不管是否被字面量赋值，变量自身都不会进入rodata，此操作只是将变量设置为const防止被修改；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;const char * str03 &#x3D; &quot;hello_ketty&quot;;  &#x2F;&#x2F; hello_ketty &#x3D; rodata, str03 &#x3D; data, const修饰的不是指针str03const char * const str04 &#x3D; &quot;hello_ketty&quot;;  &#x2F;&#x2F; 去重,与str03的hello_world是同一块常量区, str04 &#x3D; rodataint a_value &#x3D; 12345;  &#x2F;&#x2F; 12345 &#x3D; rodata, a_value &#x3D; dataint a_value_2 &#x3D; 12345;  &#x2F;&#x2F; 不去重，12345 &#x3D; rodata, a_value_2 &#x3D; dataconst int a_value_const &#x3D; 6789;  &#x2F;&#x2F; 6789 &#x3D; rodata, a_value_const &#x3D; rodataint main()&#123;    int a_value_3 &#x3D; 80000;  &#x2F;&#x2F; 80000 &#x3D; 立即数text, a_value &#x3D; text    const int a_value_const_2 &#x3D; 80000;  &#x2F;&#x2F; 80000 &#x3D; 立即数text, a_value_const_2 &#x3D; text    const char * const str05 &#x3D; &quot;AnglaBaby&quot;;  &#x2F;&#x2F; hello_ketty &#x3D; rodata, str05 &#x3D; text    printf(&quot;hello_everybody %d\n&quot;, 10);  &#x2F;&#x2F; hello_everybody就是存放在常量区&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>printf语句中的格式化字符串，比如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;Hello world %d\n&quot;, c);  &#x2F;&#x2F; Hello world就是存放在常量区<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>.rodata可以在多个进程间共享，这样可以提高内存空间利用率；</p></li></ul><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE1ef895188b31a0dae7b428808eca2723/38746" alt="image06"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE7a306235454a8b18125cb760d13ce70d/38748" alt="image07"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE41f2604e506a0d6965b667d857b30a5d/38750" alt="image08"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEf3d366d7725a2759fce90fbf65f21cf5/38752" alt="image09"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE21ddfb14f95a3543fc5c0bfc1a28d0f2/38754" alt="image10"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEc346c81d9b223a1a3b0215fbdd4489ff/38756" alt="image11"></p><h2 id="1-3、data数据段"><a href="#1-3、data数据段" class="headerlink" title="1.3、data数据段"></a>1.3、data数据段</h2><p>用于存储(非const，非零值)已初始化的全局变量、静态变量，特例：</p><ul><li>而const修饰的会放入rodata常量区；</li><li>初始化为0的变量会被放入BSS段；<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int aValue &#x3D; 6789;  &#x2F;&#x2F; .dataint aValue_2 &#x3D; 0;  &#x2F;&#x2F; .bssconst int aValue_3 &#x3D; 0;  &#x2F;&#x2F; .rodatastatic int aValue_4 &#x3D; 12345;  &#x2F;&#x2F; .datastatic int aValue_5;  &#x2F;&#x2F; .bssint array[4] &#x3D; &#123;0&#125;;  &#x2F;&#x2F; .bssint array_2[4] &#x3D; &#123;3&#125;;  &#x2F;&#x2F; .dataconst char *str444 &#x3D; &quot;hello_world&quot;;  &#x2F;&#x2F; .dataint main()&#123;    std::cout &lt;&lt; aValue + aValue_2 + aValue_3 + aValue_4 + array[0] + array_2[0] &lt;&lt; std::endl;    std::cout &lt;&lt; str444 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE23e23cae97c29bd3976d5e03c92418d2/38738" alt="image02"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEbde8b1c8a83e2f1281607473605265df/38740" alt="image03"></p><h2 id="1-4、BSS未初始化数据段"><a href="#1-4、BSS未初始化数据段" class="headerlink" title="1.4、BSS未初始化数据段"></a>1.4、BSS未初始化数据段</h2><p>用于存储未初始化、(非const)初始化为0的全局变量</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int aValue;  &#x2F;&#x2F; .bssint aValue_2 &#x3D; 0;  &#x2F;&#x2F; .bssconst int aValue_3 &#x3D; 0;  &#x2F;&#x2F; .rodatastatic int aValue_4 &#x3D; 0;  &#x2F;&#x2F; .bssstatic int aValue_5;  &#x2F;&#x2F; .bssint array[4] &#x3D; &#123;0&#125;;  &#x2F;&#x2F; .bssint array_2[4];  &#x2F;&#x2F; .bssint main()&#123;    std::cout &lt;&lt; aValue + aValue_2 + aValue_3 + aValue_4 + array[0] + array_2[0] &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE381a64cce1c8d06d8b0baa1649799a28/38742" alt="image04"><br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE68ddb485649d531b1963df552044bc51/38744" alt="image05"></p><h2 id="1-5、heap堆"><a href="#1-5、heap堆" class="headerlink" title="1.5、heap堆"></a>1.5、heap堆</h2><h3 id="1-5-1、概念"><a href="#1-5-1、概念" class="headerlink" title="1.5.1、概念"></a>1.5.1、概念</h3><p>程序运行期间动态申请的内存空间，由程序员管理其申请与释放周期，由低地址向高地址延伸<br>从物理角度而言，计算机的内存就是一块连续内存空间，并没有堆栈之分，堆栈的区分是OS层面的概念。<br>就是一块能自由分配的内存,<font color=red><strong>是进程中所有线程共享的空间</strong></font>，由低地址向高地址延伸。堆在进程初始化的时候分配，运行过程中也可以向系统申请额外的堆，但需要程序员管理其申请与释放的生命周期，要不然会引起内存泄漏。它允许程序在运行时动态地申请某个大小的内存空间，比如：程序员向操作系统申请一块内存，当系统收到程序的申请时，会遍历一个记录空闲内存地址的链表，寻找第一个大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给申请者。其特点就是分配的速度较慢，地址不连续，容易碎片化并且必须由程序员自行管理。</p><h3 id="1-5-2、heap的线程安全性"><a href="#1-5-2、heap的线程安全性" class="headerlink" title="1.5.2、heap的线程安全性"></a>1.5.2、heap的线程安全性</h3><p>不建议在线程中用new开辟新内存空间，因为heap是共享的，线程调用new是一个同步操作，其他线程都得停下来等，这样就有很大的同步代价。比如m个线程都需要new heap，那么就需要m次内存分配的操作，所有的线程需要等m次。<br>每一次new操作都是很耗时的，我们完全可以只分配一次m*n大小的内存到heap，然后每个线程访问自己需要访问的部分，这样只需要一次内存分配，而且之后的操作没有同步代价。</p><h2 id="1-6、stack栈"><a href="#1-6、stack栈" class="headerlink" title="1.6、stack栈"></a>1.6、stack栈</h2><p>栈是线程私有的，在线程开始时进行初始化，线程间的栈空间是彼此独立的，故栈是线程安全的。</p><ul><li>存放函数局部变量和函数参数；</li><li>进行函数调用时，存储”过程活动记录”；</li><li>作为暂时存储区，比如计算表达式的临时结果；</li><li>栈的释放顺序为先进后出FILO</li><li>由高地址向低地址延伸，故存在栈溢出的可能；</li></ul><h2 id="1-7、堆与栈的不同"><a href="#1-7、堆与栈的不同" class="headerlink" title="1.7、堆与栈的不同"></a>1.7、堆与栈的不同</h2><ul><li>1、申请方式不同<ul><li>栈是由系统管理，自动分配、释放，速度快；</li><li>堆需要程序员自己申请、释放，速度较慢；</li></ul></li><li>2、申请后系统的响应不同<ul><li>当栈空间不足时会报栈溢出错误；</li><li>堆需要先遍历空闲地址表，寻找可用的足够大的堆节点，并在起始地址记录本次申请的内存大小，用于delete时内存释放，当堆空间不足时返回NULL；</li></ul></li><li>3、地址范围不同<ul><li>在线程内，栈空间是连续的，由高地址向低地址扩展，大小是固定的，故存在栈溢出的可能。linux中可通过命令ulimit -a查看栈大小，ulimit -s重新设置栈大小；</li><li>不同堆之间是地址是不连续的，由低地址向高地址扩展，它的大小理论上受制于计算机的实际内存；</li></ul></li></ul><h2 id="1-8、栈顶、栈底、出栈、入栈"><a href="#1-8、栈顶、栈底、出栈、入栈" class="headerlink" title="1.8、栈顶、栈底、出栈、入栈"></a>1.8、栈顶、栈底、出栈、入栈</h2><p>堆栈是一种简单的数据结构，只允许在一端进行插入或删除的线性表。<br>允许插入、删除操作的一端称为栈顶，另一端称为栈底，堆栈的插入和删除操作被称入栈和出栈</p><h2 id="1-9、可执行文件物理体积的影响因素"><a href="#1-9、可执行文件物理体积的影响因素" class="headerlink" title="1.9、可执行文件物理体积的影响因素"></a>1.9、可执行文件物理体积的影响因素</h2><p>可执行文件物理体积包括：</p><ul><li>text代码段；<ul><li>主要是指代码的文本量，严格意义上来说应该是代码编译成机器指令后的指令文本量，不涉及局部变量即将在运行期申请的内存大小<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    int a_valude;  &#x2F;&#x2F; 文本体积    int array[1024];  &#x2F;&#x2F; 文本体积&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>data数据段；</li><li>rodata常量区<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; data与rodata是影响可执行文件体积的主要因素int a_value;  &#x2F;&#x2F; .bss仅一个占位符int a_value_2；  &#x2F;&#x2F; .bss仅一个占位符int a_value_3 &#x3D; 12; &#x2F;&#x2F; &#39;12&#39;在.rodata中的体积，一个整形的长度const char * str &#x3D; &quot;hello_world&quot;;  &#x2F;&#x2F; &quot;hello_world&quot;在.rodata中的体积<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="1-9-1、特殊情况"><a href="#1-9-1、特殊情况" class="headerlink" title="1.9.1、特殊情况"></a>1.9.1、特殊情况</h3><p>正常情况下如果增加N个int全局变量，对应的目标文件体积会增加N * 4个Byte</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int array_2[10240] &#x3D; &#123;0,1,2,3,4,.........&#125;;int array_3[10] &#x3D; &#123;0,1,2,3,4,5,6,7,8,9&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果N值较大，比如N=10240，假如此时明确知晓只是使用了其中很少一部分元素，比如10个，会存在一下两种情形：<ul><li>未使用优化编译项时，目标文件体积会增加10240个int大小；</li><li>如果此时使用了-O2、-O3、-Os等较高等级的优化编译项，编译器会做优化处理，仅仅将使用到的元素编译进来，编译的目标文件只会增加10个int的大小。需要注意的是如果目标文件是库文件，此种优化方式对全局变量不生效，因为库需要为使用者预留尽可能多的元素访问项，如果是全局静态变量，编译器优化仍会生效，因为static是文件作用域的，库的使用者无法访问</li></ul></li><li>如果N值较小，比如N=10<br>不管是否开启编译优化选项，全局变量都会被完全编译，这是因编译器的原地展开原则；</li></ul><h1 id="2、进程、线程"><a href="#2、进程、线程" class="headerlink" title="2、进程、线程"></a>2、进程、线程</h1><ul><li>进程是操作系统中申请资源的最小实体；</li><li>线程是最小的运行实体；</li><li>进程相当于线程的容器，一个进程可以创建多个线程，线程共享进程的代码段、.data段、.rodata段、BSS段、堆空间，栈空间为线程私有；</li></ul><h2 id="2-1、进程"><a href="#2-1、进程" class="headerlink" title="2.1、进程"></a>2.1、进程</h2><p>进程是操作系统中申请资源的最小实体</p><h3 id="2-1-1、进程的创建"><a href="#2-1-1、进程的创建" class="headerlink" title="2.1.1、进程的创建"></a>2.1.1、进程的创建</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;unistd.h&gt;pid_t fork();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>fork函数没有参数，返回值为进程标识符，有以下3种情况:   </p><ul><li>对于父进程，返回创建子进程的PID；   </li><li>对于子进程，返回0；   </li><li>如果创建出错，返回-1；  </li></ul><p><font color=red>为什么fork函数会有两次返回？</font>这就需要从父子进程之间的关系讲起：<br>fork函数会创建一个新的进程，内核会为其分配新的PID、新的内存空间，并复制父进程的.data段、.rodata段、BSS段、堆空间、栈空间，但共享代码段。   </p><p>由于子进程创建时复制了父进程的数据空间，并且共享代码段.text，父子进程均从fork函数处继续，便有了两次返回，父子进程里各一次，通过返回值的不同加以区分。<br><strong>注意</strong>：虽然父子进程之间存在关系，但对于操作系统内核而言，二者的地位是同等的，所以父子进程的执行顺序也是随机的，完全由操作系统的task调度器支配。  </p><ul><li>getpid()获取当前进程的PID;   </li><li>getppid()获取父进程PID；</li></ul><p>示例：  </p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main(void)&#123;    pid_t pid;    pid &#x3D; fork();    if (pid &lt; 0)&#123;        perror(&quot;fail to fork&quot;);        exit(-1);    &#125;    else if (pid &#x3D;&#x3D; 0)&#123;        &#x2F;*子进程*&#x2F;        printf(&quot;Sub-process, PID: %u, PPID: %u\n&quot;, getpid(), getppid());    &#125;    else&#123;&#x2F;*父进程*&#x2F;                printf(&quot;Parent, PID: %u, Sub-process PID: %u\n&quot;, getpid(), pid);   sleep(2);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作系统内核为子进程父子父进程的数据空间</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int global &#x3D; 1; &#x2F;*初始化的全局变量，存在data段*&#x2F;int main(void)&#123;    pid_t pid;&#x2F;*存储进程id*&#x2F;    int   stack &#x3D; 1;&#x2F;*局部变量，存在栈中*&#x2F;    int  *heap;&#x2F;*指向堆变量的指针*&#x2F;    heap &#x3D; (int *)malloc(sizeof(int));    *heap &#x3D; 3;&#x2F;*设置堆中的值是3*&#x2F;    pid &#x3D; fork();&#x2F;*创建一个新的进程*&#x2F;    if (pid &lt; 0)&#123;        perror(&quot;fail to fork&quot;);        exit(-1);    &#125;    else if (pid &#x3D;&#x3D; 0)&#123;        &#x2F;*子进程，改变变量的值*&#x2F;        global++;        stack++;        (*heap)++;        &#x2F;*打印出变量的值*&#x2F;        printf(&quot;In sub-process, global: %d, stack: %d, heap: %d\n&quot;, global, stack, *heap);        exit(0);    &#125;    else&#123;        &#x2F;*父进程*&#x2F;        sleep(2);&#x2F;*休眠2秒钟，确保子进程已执行完毕，再执行父进程*&#x2F;        printf(&quot;In parent-process, global: %d, stack: %d, heap: %d\n&quot;, global, stack, *heap);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">In sub-process, global: 2, stack: 2, heap: 4In parent-process, global: 1, stack: 1, heap: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过子进程中变量global、stack、*heap的初值来看，子进程复制了父进程的数据空间，但复制的时机由操作系统决定，在Linux系统中其遵循”写时复制”原则：</p><h3 id="2-1-2、Copy-On-Write”写时复制”规则"><a href="#2-1-2、Copy-On-Write”写时复制”规则" class="headerlink" title="2.1.2、Copy-On-Write”写时复制”规则"></a>2.1.2、Copy-On-Write”写时复制”规则</h3><p>Linux系统中fork函数在创建子进程时并不会立即复制父进程的数据空间，而是当父进程或子进程的任何一方发生写操作时物理内存复制操作才真正发生，内核才会给子进程分配真实的物理地址空间，并将父进程数据空间的数据复制过来，在此之前子进程都是指向父进程的物理内存空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;main()&#123;    char str[4]&#x3D;&quot;asd&quot;;    pid_t pid&#x3D;fork();    if(pid&#x3D;&#x3D;0)&#123;        str[0]&#x3D;&#39;b&#39;;        printf(&quot;子进程中str&#x3D;%s\n&quot;,str);        printf(&quot;子进程中str指向的首地址:%x\n&quot;,(unsigned int)str);    &#125;    else&#123;        sleep(1);        printf(&quot;父进程中str&#x3D;%s\n&quot;,str);        printf(&quot;父进程中str指向的首地址:%x\n&quot;,(unsigned int)str);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">子进程中str&#x3D;bsd子进程中str指向的首地址:bfc224dc父进程中str&#x3D;asd父进程中str指向的首地址:bfc224dc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>为何在发生了”写操作”后，父子进程中的str地址仍然一样？</strong></font>  这就涉及物理地址与逻辑地址的概念，详见<strong>第4节虚拟地址、物理地址</strong>。   </p><p>父子进程都有自己的虚拟地址空间，二者之间是独立、无关联的，故存在不同进程具有相同的虚拟地址，但值却不一样的情况，因为各自虚拟地址对应的映射物理地址并不相同。</p><h3 id="2-1-3、进程的结束"><a href="#2-1-3、进程的结束" class="headerlink" title="2.1.3、进程的结束"></a>2.1.3、进程的结束</h3><p>进程结束的2钟场景：</p><ul><li>正常结束；</li><li>异常结束；</li></ul><p>详见<strong>第3节task的退出/终止</strong><br>例如main函数的正常return退出会默认调用进程结束函数exit</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdlib.h&gt;void exit(int status)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>exit的参数表示进程的退出状态，这个状态值是一个整形全局变量，Linux系统中保存在$?中。在shell中可以通过命令 <code>echo $?</code>获取最近一个结束进程的状态值。  </p><p><font color=red><strong>注意</strong>：</font>当程序异常退出时，返回值默认为1，所以在编写代码时如果没有出错，不要使其返回值为1。</p><h3 id="2-1-4、wait-waitpid"><a href="#2-1-4、wait-waitpid" class="headerlink" title="2.1.4、wait\waitpid"></a>2.1.4、wait\waitpid</h3><p><font color=red><strong>待重新梳理………</strong></font></p><p>函数原型：  </p><pre class="line-numbers language-none"><code class="language-none">pid_t wait(int * status);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123;    &#x2F;*fork一个子进程*&#x2F;    pid_t pid &#x3D; fork();if(pid&lt;0)&#123;    perror(&quot;fork error\n&quot;);    return 0;&#125;else if(pid &gt; 0)&#123;&#x2F;*父进程*&#x2F;        printf(&quot;Parent process\n&quot;);    pid_t pr&#x3D;wait(NULL);    printf(&quot;Parent process, I catched a child process with pid of %d\n&quot;,pr);    &#125;else if(pid &#x3D;&#x3D; 0)&#123;    printf(&quot;Sub-process, PID: %u, PPID: %u\n&quot;, getpid(), getppid());        exit(0);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过wait的参数status获取子进程退出的状态信息，该值反应子进程是正常退出还是异常退出，以及正常结束时的返回值或被哪一个信号结束等的信息。这些信息存储在一个专门的宏(macro)中，比较常见的两个是：  </p><ul><li>WIFEXITED，用来指出子进程是否正常退出，正常退出时为非零值，这里的参数不同于wait函数中的status参数，而是那个指针所指向的整数；  </li><li>WEXITSTATUS;    </li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123;    &#x2F;*fork一个子进程*&#x2F;    pid_t pid &#x3D; fork();if(pid&lt;0)&#123;    perror(&quot;fork error\n&quot;);        return 0;&#125;else if(pid &gt; 0)&#123;&#x2F;*父进程*&#x2F;        printf(&quot;Parent process\n&quot;);    int status&#x3D;-1;    pid_t pr&#x3D;wait(&amp;status);    if(WIFEXITED(status))&#123;        printf(&quot;the child process %d exit normally.\n&quot;,pr);        printf(&quot;the return code is %d.\n&quot;,WEXITSTATUS(status));    &#125;else&#123;         printf(&quot;the child process %d exit abnormally.\n&quot;,pr);    &#125;    &#125;else if(pid &#x3D;&#x3D; 0)&#123;    printf(&quot;Sub-process, PID: %u, PPID: %u\n&quot;, getpid(), getppid());        exit(3);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>waitpid函数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;types.h&gt;  #include&lt;sys&#x2F;wait.h&gt;pid_t waitpid(pid_t pid, int *statues, int options);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>waitpid是wait函数的封装，只是多了三个可供选择的参数。如果不在意子进程的结束状态，那么status可以设置为NULL。<br>pid的参数含义：    </p><ul><li>pid&lt;-1:等待进程组识别码为pid绝对值的任意子进程；   </li><li>pid=-1::等待任意子进程，相当于wait；  </li><li>pid=0:等待进程组识别码与目前进程相同的任意子进程；   </li><li>pid&gt;0:等待进程识别码为pid的子进程；   </li></ul><p>options的参数含义：   </p><ul><li>options=WNOHANG，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去；   </li><li>options=WUNTRACED，子进程进入暂停马上返回，但结束状态不予理会；   </li><li>options=0，忽略此参数；  </li></ul><p>返回值：  </p><ul><li>当正常返回的时候，waitpid返回收集到的子进程的进程ID；   </li><li>如果调用出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；   </li><li>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被这设置为ECHILD；  </li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;wait.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main()&#123;pid_t pid, pr;pid&#x3D;fork();if(pid&lt;0) &#x2F;* 如果fork出错 *&#x2F;    printf(&quot;Error occured on forking.\n&quot;);    else if(pid&#x3D;&#x3D;0)&#123; &#x2F;* 如果是子进程 *&#x2F;    printf(&quot;Sub process will sleep for 10 seconds.\n&quot;)        sleep(10); &#x2F;* 睡眠10秒 *&#x2F;        exit(0);    &#125;else if(pid&gt;0)&#123;&#x2F;* 如果是父进程 *&#x2F;do&#123;  pr&#x3D;waitpid(pid, NULL, WNOHANG);                &#x2F;* 使用了WNOHANG参数，waitpid不会在这里等待 *&#x2F; if(pr&#x3D;&#x3D;0)&#123; &#x2F;* 如果没有收集到子进程 *&#x2F;                  printf(&quot;No child exited\n&quot;);                  sleep(1);                &#125;&#125;while(pr&#x3D;&#x3D;0); &#x2F;* 没有收集到子进程，就回去继续尝试 *&#x2F;              if(pr&#x3D;&#x3D;pid)printf(&quot;successfully get child %d\n&quot;, pr);elseprintf(&quot;some error occured\n&quot;);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-5、僵死进程-孤儿进程"><a href="#2-1-5、僵死进程-孤儿进程" class="headerlink" title="2.1.5、僵死进程\孤儿进程"></a>2.1.5、僵死进程\孤儿进程</h3><p>对于操作系统而言并不会区别对待父子进程，与其他进程一样参与调度，也无法预测它们的行为，于是便有了孤儿进程和僵尸进程产生的可能   </p><ul><li>孤儿进程：父进程退出后，子进程仍在运行，此时子进程便成为孤儿进程。这些孤儿进程最终会被init进程(进程号为1)所收养，并由init进程对它们进行管理。   </li><li>僵尸进程：子进程退出，但是父进程并未使用wait或waitpid获取子进程的状态信息，无法对其进行管理，子进程的进程描述符仍然保留在系统中，就像一个无用的躯壳残留，实际并不在运行了，称作僵死进程</li></ul><p>linux中通过命令<code>ps aux | grep -w &#39;Z&#39;</code>可以查看系统中存在的僵尸进程</p><h3 id="2-1-6、守护进程"><a href="#2-1-6、守护进程" class="headerlink" title="2.1.6、守护进程"></a>2.1.6、守护进程</h3><p><font color=red><strong>待重新梳理………</strong></font></p><p>在linux或windows中存在很多系统启动时就开启的服务，这些服务称作守护进程。守护进程是独立于终端并且在后台运行的。<br>在linux中，每一个系统与用户交流的界面都被称作终端，每一个从此终端开始运行的进程都会依赖于这个终端，这个终端被称作控制终端，当控制终端关闭时，相应的进程都会关闭，但是守护进程却能突破这种限制。<br>在介绍守护进程的创建之前需要先了解两个概念：进程组和会话期   </p><ul><li><p>进程组<br>是一个或多个进程的集合，进程组由进程组ID来唯一标识，每一个进程组都有一个组长进程，其进程ID与进程组ID相同，且该进程组ID不会因为组长进程的退出受到影响；   </p></li><li><p>会话期<br>通常，一个会话开始于用户登录，结束于用户退出，在此期间该用户运行的所有进程都属于这个会话期；   </p></li></ul><p>创建一个守护进程的简单步骤：   </p><ol><li><p>创建子进程，父进程退出<br>这是编写守护进程的第一步，父进程退出，在形式上做到了与控制终端脱离的假象。   </p></li><li><p>在子进程中创建新会话<br>父进程退出，会导致子进程变成孤儿进程，此时需要调用setsid函数创建新的会话，并担任会话组的组长，调用setsid的3个作用：1、让进程摆脱原会话的控制；2、摆脱原进程组的控制；3、摆脱原控制终端的控制；<br>为什么调用setsid？<br>由于fork函数创建子进程时，全盘拷贝了父进程的会话期、进程组、控制终端。   </p></li><li><p>改变当前目录为根目录<br>由于子进程继承了父进程的当前目录，会对以后的使用造成麻烦，通常的做法是把’&#39;当做守护进程的工作目录，当然也可指定为其他目录；   </p></li><li><p>重设文件权限掩码<br>即重设守护进程的文件访问权限，解除守护进程文件访问的麻烦，调用函数umask可以实现；   </p></li><li><p>关闭文件描述符<br>由于守护进程已经脱离控制终端，终端的输入无法到达守护进程，守护进程的输出也无法到达终端，此时便需要关闭文件描述符0、1、2；   </p></li></ol><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;wait.h&gt;#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;#define MAXFILE 65535int main()&#123;pid_t pc;int i,fd,len;char *buf&#x3D;&quot;this is a Dameon\n&quot;;len &#x3D; strlen(buf);pc &#x3D; fork(); &#x2F;*第一步*&#x2F;if(pc&lt;0)&#123;printf(&quot;error fork\n&quot;);exit(1);&#125;else if(pc&gt;0)&#123;exit(0);&#125;setsid(); &#x2F;*第二步*&#x2F;chdir(&quot;&#x2F;&quot;); &#x2F;*第三步*&#x2F;umask(0); &#x2F;*第四步*&#x2F;for(i&#x3D;0;i&lt;MAXFILE;i++) &#x2F;*第五步*&#x2F;    close(i);    while(1)&#123;if((fd&#x3D;open(&quot;&#x2F;tmp&#x2F;dameon.log&quot;,O_CREAT|O_WRONLY|O_APPEND,0600))&lt;0)&#123;perror(&quot;open&quot;);exit(1);&#125;write(fd,buf,len+1);close(fd);sleep(10);  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-7、IPC-进程间通信"><a href="#2-1-7、IPC-进程间通信" class="headerlink" title="2.1.7、IPC 进程间通信"></a>2.1.7、IPC 进程间通信</h3><p>进程间通信方式包括：</p><ul><li>管道；</li><li>消息队列；</li><li>共享内存；</li><li>信号量；</li><li>套接字；</li></ul><p>前四种用于同一操作系统之中的进程通信，套接字socket用于跨主机间的进程通信</p><h4 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h4><ul><li>无名管道；</li><li>具名管道；</li></ul><p><font color=red><strong>无名管道</strong></font></p><ul><li>无名管道为半双工模式，数据流只能由一个进程流向另一个进程；</li><li>只能用于父子进程或兄弟进程，也就是说必须是具有亲缘关系的进程；</li></ul><p>管道实际上是一种存在于内存之中的文件，在管道尾部写入，头部读出。<font color=red>而且管道的操作是由内核完成，频繁的调用会影响系统性能。</font></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分别用fd[0]和fd[1]来描述管道读端、写端</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;unistd.h&gt; #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define INPUT 0 #define OUTPUT 1 int main() &#123;int fd[2];&#x2F;*定义子进程号 *&#x2F; pid_t pid; char buf[256]; int returned_count; &#x2F;*创建无名管道*&#x2F; pipe(fd);&#x2F;*创建子进程*&#x2F;    pid&#x3D;fork();if(pid&lt;0) &#123;printf(&quot;Error in fork\n&quot;);exit(1); &#125;else if(pid &#x3D;&#x3D; 0) &#123; &#x2F;*执行子进程*&#x2F;    printf(&quot;in the child process...\n&quot;); &#x2F;*子进程向父进程写数据，关闭管道的读端*&#x2F; close(fd[INPUT]); write(fd[OUTPUT], &quot;hello world&quot;, strlen(&quot;hello world&quot;));exit(0); &#125;else &#123; &#x2F;*执行父进程*&#x2F;     printf(&quot;in the parent process...\n&quot;); &#x2F;*父进程从管道读取子进程写的数据，关闭管道的写端*&#x2F;close(fd[OUTPUT]); returned_count &#x3D; read(fd[INPUT], buf, sizeof(buf)); printf(&quot;%d bytes of data received from child process: %s\n&quot;, returned_count, buf);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种有名管道，可用于不具有亲缘关系的进程间通信 </p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;stat.h&gt;int mkfifo(const char *pathname, mode_t mode);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二个参数与普通文件open()函数中的参数mode类似</p><pre class="line-numbers language-none"><code class="language-none">read：#include &lt;stdio.h&gt;#include &lt;sys&#x2F;stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define P_FIFO &quot;&#x2F;tmp&#x2F;p_fifo&quot;int main(int argc, char** argv)&#123;char cache[100];int fd;memset(cache,0, sizeof(cache));   &#x2F;*初始化内存*&#x2F;if(access(P_FIFO,F_OK)&#x3D;&#x3D;0)&#123;  &#x2F;*管道文件存在*&#x2F;      execlp(&quot;rm&quot;,&quot;-f&quot;, P_FIFO, NULL);  &#x2F;*删掉*&#x2F;printf(&quot;access.\n&quot;);&#125;if(mkfifo(P_FIFO, 0777) &lt; 0)&#123;printf(&quot;createnamed pipe failed.\n&quot;);&#125;fd&#x3D; open(P_FIFO,O_RDONLY|O_NONBLOCK); &#x2F;*非阻塞方式打开，只读*&#x2F;while(1)&#123;memset(cache,0, sizeof(cache));if((read(fd,cache, 100)) &#x3D;&#x3D; 0 )&#123; &#x2F;*没有读到数据*&#x2F;    printf(&quot;nodata:\n&quot;);&#125;else&#123;                 printf(&quot;getdata:%s\n&quot;, cache); &#x2F;*读到数据，将其打印*&#x2F;              &#125;sleep(1);&#x2F;*休眠1s*&#x2F;    &#125;    close(fd);    return 0;&#125;write:#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define P_FIFO &quot;&#x2F;tmp&#x2F;p_fifo&quot;int main(int argc, char **argv)&#123;int fd;if(argc&lt; 2)&#123;printf(&quot;please input the write data.\n&quot;);&#125;fd&#x3D; open(P_FIFO,O_WRONLY|O_NONBLOCK); &#x2F;*非阻塞方式*&#x2F;    write(fd,argv[1], 100); &#x2F;*将argv[1]写道fd里面去*&#x2F;close(fd);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、消息队列"><a href="#2、消息队列" class="headerlink" title="2、消息队列"></a>2、消息队列</h4><p>基本已废弃</p><h4 id="3、共享内存"><a href="#3、共享内存" class="headerlink" title="3、共享内存"></a>3、共享内存</h4><ul><li>进程通过shmget向操作系统申请一段物理内存，然后通过shmat将物理地址映射进进程的虚拟内存空间，<font color=red>这些函数调用都属于内核态的系统调用；</font></li><li>共享内存在进程间不提供同步机制，故当一个进程在共享内存进行写操作时，并不能阻止另一个进程读共享内存操作；</li></ul><p><font color=purple><strong>创建共享内存</strong></font><br> <pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;shm.h&gt;int shmget(key_t key, int size, int flag);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><ul><li>key：共享内存名字，可自定义；</li><li>size：单位为byte，设置需要创建的共享内存大小；</li><li>flag：权限标志，设置共享内存的访问权限；</li><li>返回值：运行成功时返回一个与key相关的内存标识符，失败则返回-1；</li></ul><p><font color=purple><strong>链接共享内存</strong></font></p><pre class="line-numbers language-none"><code class="language-none">void *shmat(int shmid, void *addr,int flag);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>shmid是shmget函数返回值；    </li><li>返回值：进程所链接共享内存的实际地址；</li></ul><p><font color=purple><strong>剥离共享内存</strong></font>：   </p><pre class="line-numbers language-none"><code class="language-none">int shmdt(const void *shmaddr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>shmaddr：shmat返回的地址指针；   </li></ul><p>consumer.cpp创建共享内存：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &quot;shm_com.h&quot;int main()&#123;int shmid;srand((unsigned int)getpid());shmid &#x3D; shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);if (shmid &#x3D;&#x3D; -1) &#123;  fprintf(stderr, &quot;shmget failed\n&quot;);  exit(EXIT_FAILURE);&#125;void *shared_memory &#x3D; (void *)0;    shared_memory &#x3D; shmat(shmid, (void *)0, 0);if (shared_memory &#x3D;&#x3D; (void *)-1) &#123;  fprintf(stderr, &quot;shmat failed\n&quot;);  exit(EXIT_FAILURE);&#125;printf(&quot;Memory attached at %X\n&quot;, (long)shared_memory);struct shared_use_st *shared_stuff;shared_stuff &#x3D; (struct shared_use_st *)shared_memory;shared_stuff-&gt;written &#x3D; 0;int running &#x3D; 1;while(running)&#123;  if (shared_stuff-&gt;written)&#123;    printf(&quot;You wrote: %s&quot;, shared_stuff-&gt;text);    sleep( rand() % 4 );    shared_stuff-&gt;written &#x3D; 0;    if (strncmp(shared_stuff-&gt;text, &quot;end&quot;, 3) &#x3D;&#x3D; 0) &#123;running &#x3D; 0;    &#125;   &#125;&#125;if (shmdt(shared_memory) &#x3D;&#x3D; -1)&#123;    fprintf(stderr, &quot;shmdt failed\n&quot;);    exit(EXIT_FAILURE);&#125;if (shmctl(shmid, IPC_RMID, 0) &#x3D;&#x3D; -1)&#123;    fprintf(stderr, &quot;shmctl(IPC_RMID) failed\n&quot;);    exit(EXIT_FAILURE);&#125;exit(EXIT_SUCCESS);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>producer.cpp向共享内存写数据：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &quot;shm_com.h&quot;int main()&#123;int shmid;shmid &#x3D; shmget((key_t)1234, sizeof(struct shared_use_st), 0666 | IPC_CREAT);if (shmid &#x3D;&#x3D; -1)&#123;fprintf(stderr, &quot;shmget failed\n&quot;);exit(EXIT_FAILURE);&#125;void *shared_memory &#x3D; (void *)0;shared_memory &#x3D; shmat(shmid, (void *)0, 0);if (shared_memory &#x3D;&#x3D; (void *)-1)&#123;fprintf(stderr, &quot;shmat failed\n&quot;);exit(EXIT_FAILURE);&#125;printf(&quot;Memory attached at %X\n&quot;, (long)shared_memory);struct shared_use_st *shared_stuff;shared_stuff &#x3D; (struct shared_use_st *)shared_memory;int running &#x3D; 1;char buffer[BUFSIZ];while(running)&#123;while(shared_stuff-&gt;written &#x3D;&#x3D; 1)&#123;sleep(1);printf(&quot;waiting for client...\n&quot;);&#125;printf(&quot;Enter some text: &quot;);fgets(buffer, BUFSIZ, stdin);strncpy(shared_stuff-&gt;text, buffer, TEXT_SZ);shared_stuff-&gt;written &#x3D; 1;if (strncmp(buffer, &quot;end&quot;, 3) &#x3D;&#x3D; 0) &#123;running &#x3D; 0;&#125;&#125;if (shmdt(shared_memory) &#x3D;&#x3D; -1) &#123;fprintf(stderr, &quot;shmdt failed\n&quot;);exit(EXIT_FAILURE);&#125;exit(EXIT_SUCCESS);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>共享内存结构体：</p><pre class="line-numbers language-none"><code class="language-none">#ifndef _SHMCOM_H_HEADER  #define _SHMCOM_H_HEADER#define TEXT_SZ 2048struct shared_use_st &#123;  int written;  char text[TEXT_SZ];&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、信号量"><a href="#4、信号量" class="headerlink" title="4、信号量"></a>4、信号量</h4><p>信号量除了可以用于进程、线程的通信外，它还是最早期的锁机制，详见：<strong>计算机系统_壹.2、进行、线程.2.5.*节</strong>  </p><p><font color=purple><strong>创建信号量</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;sys&#x2F;types.h&gt;#include&lt;sys&#x2F;ipc.h&gt;#include&lt;sys&#x2F;sem.h&gt;int semget(key_t key, int nsems, int semflag);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>key：信号量名字，可自定义；</li><li>nsems：创建信号量的个数，如果只是访问而不创建可以指定该值为0；</li><li>semflag：设置信号量的读写权限；</li><li>返回值：信号量标识符，失败返回-1；</li></ul><p>一旦创建了信号量，就不能更改该信号量的个数。若不删除某个信号量的情况下，重新调用semget函数创建该信号量时，并不会引起重复创建，返回值仍然是第一次创建的信号量。</p><p><font color=purple><strong>更新信号量的值</strong></font></p><pre class="line-numbers language-none"><code class="language-none">int semop(int semid, struct sembuf *sops, unsigned nsops);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>semid：semget函数的返回值；</li><li>sembuf结构体定义：   </li></ul><pre class="line-numbers language-none"><code class="language-none">struct sembuf   &#123;    short sem_num;  &#x2F;&#x2F;除非使用一组信号量，否则为0       short sem_op;  &#x2F;&#x2F;信号量在一次读写中需要改变的值，通常是两个数                       &#x2F;&#x2F;一个是-1，即P（等待）操作，一个是+1，即V（发送信号）操作；        short sem_flag;   &#x2F;&#x2F;通常为SEM_UNDO                   &#125;     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=purple><strong>控制信号量</strong></font></p><pre class="line-numbers language-none"><code class="language-none">int semctl(int semid, int semnum, int cmd,...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前两个参数与前面一个函数一样，cmd通常为SETVAL，IPC_RMID。<br>SETVAL用来将信号量初始化为一个已知的值；<br>IPC_RMID用于删除一个不再使用的信号量标识符；<br>如果有第四个参数，就是union semnum：    </p><pre class="line-numbers language-none"><code class="language-none">uinion semnum&#123;    int val;        struct semid_ds *buf;       unsigned short *arry;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>semnum表示第几个信号量，union semnum表示对第几个信号量初始化这是的值   </p><p>reader.cpp读数据</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;sem.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &lt;errno.h&gt;#define SEM_KEY 4001#define SHM_KEY 5678union semun &#123;int val;&#125;;int main(void)&#123;&#x2F;*create a shm*&#x2F;int semid,shmid;shmid &#x3D; shmget(SHM_KEY,sizeof(int),IPC_CREAT|0666);if(shmid&lt;0)&#123;printf(&quot;create shm error\n&quot;);return -1;&#125;void * shmptr;shmptr &#x3D;shmat(shmid,NULL,0);if(shmptr &#x3D;&#x3D; (void *)-1)&#123;printf(&quot;shmat error:%s\n&quot;,strerror(errno));return -1;&#125;int * data &#x3D; (int *)shmptr;semid &#x3D; semget(SEM_KEY,2,IPC_CREAT|0666);&#x2F;*这里是创建一个semid，并且有两个信号量*&#x2F;union semun semun1;&#x2F;*下面这四行就是初始化那两个信号量，一个val&#x3D;0,另一个val&#x3D;1*&#x2F;semun1.val&#x3D;0;semctl(semid,0,SETVAL,semun1);semun1.val&#x3D;1;semctl(semid,1,SETVAL,semun1);struct sembuf sembuf1;while(1)&#123;  sembuf1.sem_num&#x3D;0;&#x2F;*sem_num&#x3D;0指的是下面操作指向第一个信号量，上面设置可知其 val&#x3D;0*&#x2F;  sembuf1.sem_op&#x3D;-1; &#x2F;*初始化值为0，再-1的话就会等待*&#x2F;  sembuf1.sem_flg&#x3D;SEM_UNDO;  semop(semid,&amp;sembuf1,1);&#x2F;*reader在这里会阻塞,直到收到信号*&#x2F;  printf(&quot;the NUM:%d\n&quot;,*data);&#x2F;*输出结果*&#x2F;  sembuf1.sem_num&#x3D;1;&#x2F;*这里让writer再次就绪，就这样循环*&#x2F;  sembuf1.sem_op&#x3D;1;  sembuf1.sem_flg&#x3D;SEM_UNDO;  semop(semid,&amp;sembuf1,1);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>writer.cpp写数据</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;ipc.h&gt;#include &lt;sys&#x2F;sem.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys&#x2F;shm.h&gt;#include &lt;errno.h&gt;#define SEM_KEY 4001#define SHM_KEY 5678union semun &#123;int val;&#125;;int main(void)&#123;&#x2F;*create a shm*&#x2F;int semid,shmid;shmid &#x3D; shmget(SHM_KEY,sizeof(int),IPC_CREAT|0666);if(shmid&lt;0)&#123;  printf(&quot;create shm error\n&quot;);  return -1;&#125;void * shmptr;shmptr &#x3D;shmat(shmid,NULL,0);if(shmptr &#x3D;&#x3D; (void *)-1)&#123;  printf(&quot;shmat error:%s\n&quot;,strerror(errno));  return -1;&#125;int * data &#x3D; (int *)shmptr;semid &#x3D; semget(SEM_KEY,2,0666);struct sembuf sembuf1;union semun semun1;while(1)&#123;  sembuf1.sem_num&#x3D;1;&#x2F;*这里指向第2个信号量（sem_num&#x3D;1）*&#x2F;  sembuf1.sem_op&#x3D;-1;&#x2F;*操作是-1，因为第2个信号量初始值为1，所以下面不会阻塞*&#x2F;      sembuf1.sem_flg&#x3D;SEM_UNDO;  semop(semid,&amp;sembuf1,1);&#x2F;*继续*&#x2F;  scanf(&quot;%d&quot;,data);  &#x2F;*用户在终端输入数据*&#x2F;  sembuf1.sem_num&#x3D;0;&#x2F;*这里指向第一个信号量*&#x2F;  sembuf1.sem_op&#x3D;1;&#x2F;*操作加1*&#x2F;  sembuf1.sem_flg&#x3D;SEM_UNDO;  semop(semid,&amp;sembuf1,1);&#x2F;*执行+1后，我们发现，reader阻塞正是由于第一个信号量为0，无法减一，而现在writer先为其加1，那reader就绪！writer继续循环，发现第二个信号量已经减为0，则阻塞了，我们回到reader*&#x2F;    &#125; return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-8、IPC相关命令"><a href="#2-1-8、IPC相关命令" class="headerlink" title="2.1.8、IPC相关命令"></a>2.1.8、IPC相关命令</h3><table><thead><tr><th>ipcs命令</th><th></th></tr></thead><tbody><tr><td>ipcs -a  列出所有的消息队列，共享内存，信号量等；</td><td></td></tr><tr><td>ipcs -q  列出所有的消息队列；</td><td></td></tr><tr><td>ipcs -s  列出所有的信号量；</td><td></td></tr><tr><td>ipcs -m  列出所有的共享内存</td><td></td></tr><tr><td>ipcs -l  列出系统限额；</td><td></td></tr><tr><td>ipcs -t  列出最后的访问时间；</td><td></td></tr><tr><td>ipcs -u  列出当前的使用情况；</td><td></td></tr></tbody></table><h2 id="2-2、线程"><a href="#2-2、线程" class="headerlink" title="2.2、线程"></a>2.2、线程</h2><h3 id="2-2-1、线程的创建"><a href="#2-2-1、线程的创建" class="headerlink" title="2.2.1、线程的创建"></a>2.2.1、线程的创建</h3><ul><li><p>C++<br><font color=purple><strong>创建线程</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;thread&gt;void func()&#123;    &#x2F;&#x2F; do something&#125;int main()&#123;    std::thread t(func);    t.join();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向线程入口函数传递参数</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;thread&gt;void func(int i, double d, string s)&#123;    cout &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; d &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;&#125;int main()&#123;    std::thread t(func, 1, 2, &quot;test&quot;);    t.join();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=purple><strong>剥离线程</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;thread&gt;void func()&#123;    &#x2F;&#x2F; do something&#125;int main()&#123;    std::thread t(func);    t.detach();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>detach之后线程与其创建者就分离了，新创建的线程会作为后台线程运行，再也无法与其创建者发生联系。 </p></li><li><p>C<br><font color=purple><strong>创建线程</strong></font></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t, void *(*start_routine), void *arg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ul><li>thread：指向线程标识符的指针；   </li><li>pthread_attr_t：设置线程属性；   </li><li>start_routine：线程入口函数地址；   </li><li>arg：需要传入线程入口函数的参数；</li><li>返回值：若创建成功，返回0，失败则返回错误编码；</li></ul><p>创建线程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;void* say_hello(void* args)&#123;&#x2F;*线程的运行函数，必须void*，没说的表示返回通用指针、输入通用指针*&#x2F;printf(&quot;hello from thread\n&quot;);pthread_exit((void*)1);&#125;int main()&#123;pthread_t tid;    int iRet &#x3D; pthread_create(&amp;tid, NULL, say_hello, NULL);&#x2F;*参数依次是：创建的线程id，线程参数，调用函数名，传入的函数参数*&#x2F;    if (iRet)&#123;    printf(&quot;pthread_create error: iRet&#x3D;%d\n&quot;,iRet);        return iRet;    &#125;void *retval;iRet&#x3D;pthread_join(tid,&amp;retval);if (iRet)&#123;    printf(&quot;pthread_join error: iRet&#x3D;%d\n&quot;,iRet);        return iRet;    &#125;printf(&quot;retval&#x3D;%ld\n&quot;,(long)retval);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2、线程的结束"><a href="#2-2-2、线程的结束" class="headerlink" title="2.2.2、线程的结束"></a>2.2.2、线程的结束</h3><p><font color=purple><strong>等待线程结束</strong></font></p><pre class="line-numbers language-none"><code class="language-none">int pthread_join(pthread_t thread, void **retval);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>thread：线程标识符；   </li><li>retval：被等待线程的返回值；   </li></ul><p>该函数为阻塞函数，调用后会一直等到线程结束为止。<br>线程的结束有两种途径，一是线程正常终止；二是通过函数pthread_exit函数强制结束；<br><font color=purple><strong>强制结束线程</strong></font></p><pre class="line-numbers language-none"><code class="language-none">pthread_exit(void *retval);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>retval：设置线程的返回码；</li></ul><p>线程通过pthread_exit传递一个返回值，而后其他task通过pthread_join获得返回值，从而判断线程的退出状态。</p><h3 id="2-2-3、线程相关操作"><a href="#2-2-3、线程相关操作" class="headerlink" title="2.2.3、线程相关操作"></a>2.2.3、线程相关操作</h3><ul><li>C++<br><font color=purple><strong>获取线程ID、CPU核数</strong></font><pre class="line-numbers language-none"><code class="language-none">#include&lt;thread&gt;void func()&#123;    &#x2F;&#x2F; do something&#125;int main()&#123;    std::thread t(func);    cout &lt;&lt; t.get_id() &lt;&lt; endl;   &#x2F;&#x2F; 获取当前线程ID    cout &lt;&lt; std::thread::hardware_concurrency() &lt;&lt; endl;  &#x2F;&#x2F; 获取CPU核数，失败返回0        t.join();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color=purple><strong>线程休眠</strong></font><pre class="line-numbers language-none"><code class="language-none">#include&lt;thread&gt;void func()&#123;    std::this_thread::sleep_for(std::chrono::seconds(3));  &#x2F;&#x2F; 当前线程休眠3s&#125;int main()&#123;    std::thread t(func);    t.join();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-4、线程属性"><a href="#2-2-4、线程属性" class="headerlink" title="2.2.4、线程属性"></a>2.2.4、线程属性</h3>线程属性被封装在结构体phtread_attr_t之中<pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;pthread.h&gt;typedef struct   &#123;      int etachstate;  &#x2F;&#x2F; 线程的分离状态      int schedpolicy; &#x2F;&#x2F; 线程调度策略       struct sched_param schedparam;  &#x2F;&#x2F; 线程调度参数       int inheridsched;  &#x2F;&#x2F; 线程的继承性        int scope;  &#x2F;&#x2F; 线程作用域       size_t guardsize;  &#x2F;&#x2F; 线程末尾的警戒缓冲区大小       int stackaddr_set; &#x2F;&#x2F; 线程栈设置       void* stackaddr;  &#x2F;&#x2F; 线程栈位置       size_t stacksize;  &#x2F;&#x2F; 线程栈大小   &#125;phtread_attr_t；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>线程的属性不能被直接操作，须使用pthread_attr_init函数在初始化时进行设置，且初始化操作必须在pthread_create函数之前调用。当线程结束时还须用pthread_attr_destroy函数来释放资源。   </li></ul><p><font color=red><strong>线程的默认属性为：非绑定、非分离、默认1MB的堆栈、与父进程同样的优先级。</strong></font></p><h4 id="1、分离状态-detach-state"><a href="#1、分离状态-detach-state" class="headerlink" title="1、分离状态(detach state)"></a>1、分离状态(detach state)</h4><p>将线程设置为分离状态时，线程终止之后，操作系统将不会保留线程终止的状态，线程的结束状态也不会被其创建者捕获。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 创建线程之前设置其分离状态&#x2F;&#x2F; 分离状态可选项：PTHREAD_CREATE_DETACHD、PTHREAD_CREATE_JOINABLE   &#x2F;&#x2F; 设置线程分离状态int pthread_attr_setdetachstate(pthread_attr_t *attr, int state);&#x2F;&#x2F; 获取线程分离状态int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;string.h&gt;void * tfn1(void * arg)&#123;     printf(&quot;the thread\n&quot;);      return NULL; &#125;  int main(void)&#123;     int iRet;     pthread_t tid;     pthread_attr_t attr;      iRet &#x3D; pthread_attr_init(&amp;attr);     if(iRet)&#123;         printf(&quot;can&#39;t init attr %s&#x2F;n&quot;, strerror(iRet));     return iRet;    &#125;     iRet &#x3D; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);    if(iRet)&#123;         printf(&quot;can&#39;t set attr %s\n&quot;, strerror(iRet));     return iRet;    &#125;     iRet &#x3D; pthread_create(&amp;tid, &amp;attr, tfn1, NULL);    if(iRet)&#123;         printf(&quot;can&#39;t create thread %s\n&quot;, strerror(iRet));     return iRet;     &#125;     iRet &#x3D; pthread_join(tid, NULL);    if(iRet)&#123;         printf(&quot;thread has been detached\n&quot;);     return iRet;    &#125;    return 0; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>也可使用函数pthread_detach(pthread_t pid)将一个已经创建好的线程进行分离</strong></font></p><h4 id="2、设置线程栈空间"><a href="#2、设置线程栈空间" class="headerlink" title="2、设置线程栈空间"></a>2、设置线程栈空间</h4><p>每个线程具有默认栈大小</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; 创建线程之前设置栈空间大小int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size);&#x2F;&#x2F; 获取线程栈空间大小int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5、线程间通信"><a href="#2-2-5、线程间通信" class="headerlink" title="2.2.5、线程间通信"></a>2.2.5、线程间通信</h3><p>IPC同样适用于线程，但通常线程间更关注的是同步方式，而且线程通常是共享父进程的地址空间，故往往以全局变量的方式进行通信是最方便的。</p><h3 id="2-2-6、线程同步"><a href="#2-2-6、线程同步" class="headerlink" title="2.2.6、线程同步"></a>2.2.6、线程同步</h3><p>常见的线程同步方式：</p><ul><li>互斥锁(mutex)；</li><li>条件变量(condition variable)；</li><li>读写锁(read-write lock)；</li></ul><h4 id="1、互斥锁-mutex"><a href="#1、互斥锁-mutex" class="headerlink" title="1、互斥锁(mutex)"></a>1、互斥锁(mutex)</h4><p>参见<strong>计算机系统_壹.2、进程、线程.2.5节</strong></p><ul><li>C++<br>独占互斥量std::mutex  <ul><li>lock和unlock必须成对出现;</li><li>try_lock是尝试锁定互斥量，成功返回true，失败false，它是非阻塞的，可以避免因拿不到锁而长时间阻塞；   </li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex g_lock;void func()&#123;g_lock.lock();std::cout &lt;&lt; &quot;entered thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;std::this_thread::sleep_for(std::chrono::seconds(1));std::cout &lt;&lt; &quot;leaving thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;g_lock.unlock();&#125;int main(void)&#123;std::thread t1(func);std::thread t2(func);std::thread t3(func);t1.join();t2.join();t3.join();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=purple><strong>lock_guard</strong></font><br>使用lock_guard可以简化lock/unlock的写法，同时也更为安全，因为lock_guard在构造的时候会自动锁定互斥量，退出作用域后进行析构时会自动解锁，从而保证了互斥量的正确操作：   </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::mutex g_lock;void func()&#123;    std::lock_guard&lt;std::mutex&gt; locker(g_lock);  &#x2F;&#x2F; 出作用域后自动解锁std::cout &lt;&lt; &quot;entered thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;std::this_thread::sleep_for(std::chrono::seconds(1));std::cout &lt;&lt; &quot;leaving thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;&#125;int main(void)&#123;std::thread t1(func);std::thread t2(func);std::thread t3(func);t1.join();t2.join();t3.join();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=purple><strong>带超时的独占互斥量std::timed_mutex</strong></font><br>增加了获取锁超时等待功能，因为不清楚获取锁需要多长时间，为了不至于一直等待下去，设置一个等待超时时间，在超时后还可以做其他事情。   </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;std::timed_mutex mutex;void work()&#123;std::chrono::milliseconds timeout(100);while (true)&#123;if (mutex.try_lock_for(timeout))&#123;std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work with the mutex&quot; &lt;&lt; std::endl;std::chrono::milliseconds sleepDuration(250);std::this_thread::sleep_for(sleepDuration);mutex.unlock();std::this_thread::sleep_for(sleepDuration);&#125;else&#123;std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work without the mutex&quot; &lt;&lt; std::endl;std::chrono::milliseconds sleepDuration(100);std::this_thread::sleep_for(sleepDuration);&#125;&#125;&#125;int main(void)&#123;std::thread t1(work);std::thread t2(work);t1.join();t2.join();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C<br>可把互斥锁想象成一个只能容纳一个人的洗手间，当有人进去之后，其他人就无法进入，只有人出来才会被其他人使用。<strong>但外面等候的人并没有排队</strong>，谁看到洗手间空了，就可以冲进去。<br>相关的函数有：   </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">pthread_mutex_init; &#x2F;&#x2F;动态初始化（静态初始化：pthread_mutex_t mt&#x3D; PTHREAD_MUTEX_INITIALIZER）pthread_mutex_destroy; &#x2F;&#x2F;销毁锁pthread_mutex_lock; &#x2F;&#x2F;加锁pthread_mutex_unlock; &#x2F;&#x2F;解锁pthread_mutex_trylock; &#x2F;&#x2F;尝试加锁，与加锁的不同之处在于在锁已经被占用时返回EBUSY，而不是挂起等待<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>互斥锁的不足之处：  </p><ul><li><strong>在外面等候的人并没有排队</strong>，谁看到洗手间空了，就可以冲进去，即不存在优先级；</li><li>如果存在某个线程没有使用锁，而直接修改临界资源，那么互斥锁是无从知晓的，也不能阻止修改操作，这样互斥锁就失去了保护意义，即防君子不防小人； </li><li>对于需要频繁加解锁的场景，会极其浪费CPU资源；</li></ul><p><strong>使用互斥锁解决售票问题：</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;pthread_mutex_t mutex_x&#x3D; PTHREAD_MUTEX_INITIALIZER;int total_ticket_num&#x3D;20;void *sell_ticket1(void *arg)&#123;for(int i&#x3D;0;i&lt;20;i++)&#123;pthread_mutex_lock(&amp;mutex_x);if(total_ticket_num&gt;0)&#123;printf(&quot;thread1 sell the %dth ticket\n&quot;,20-total_ticket_num+1);total_ticket_num--;&#125;                sleep(1);pthread_mutex_unlock(&amp;mutex_x);sleep(1);&#125;return 0;&#125;void *sell_ticket2(void *arg)&#123;    int iRet&#x3D;0;for(int i&#x3D;0;i&lt;10;i++)&#123;    iRet&#x3D;pthread_mutex_trylock(&amp;mutex_x);    if(iRet&#x3D;&#x3D;EBUSY)&#123;        printf (&quot;sell_ticket2:the variable is locked by sell_ticket1.\n&quot;);    &#125;else if(iRet&#x3D;&#x3D;0)&#123;if(total_ticket_num&gt;0)&#123;    printf(&quot;thread2 sell the %dth ticket\n&quot;,20-total_ticket_num+1);    total_ticket_num--;&#125;pthread_mutex_unlock(&amp;mutex_x);    &#125;    sleep(1);&#125;return 0;&#125;int main()&#123;    pthread_t tids[2];int iRet &#x3D; pthread_create(&amp;tids[0], NULL, &amp;sell_ticket1, NULL);if(iRet)&#123;    printf(&quot;pthread_create error, iRet&#x3D;%d\n&quot;,iRet);    return iRet;&#125;iRet &#x3D; pthread_create(&amp;tids[1], NULL, &amp;sell_ticket2, NULL);if(iRet)&#123;    printf(&quot;pthread_create error, iRet&#x3D;%d\n&quot;,iRet);    return iRet;&#125;sleep(30);void *retval;iRet&#x3D;pthread_join(tids[0], &amp;retval);if(iRet)&#123;    printf(&quot;tid&#x3D;%d join error, iRet&#x3D;%d\n&quot;,tids[0],iRet);&#125;else&#123;    printf(&quot;retval&#x3D;%ld\n&quot;,(long*)retval);&#125;iRet&#x3D;pthread_join(tids[1], &amp;retval);if(iRet)&#123;    printf(&quot;tid&#x3D;%d join error, iRet&#x3D;%d\n&quot;,tids[1],iRet);&#125;else&#123;    printf(&quot;retval&#x3D;%ld\n&quot;,(long*)retval);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、条件变量"><a href="#2、条件变量" class="headerlink" title="2、条件变量"></a>2、条件变量</h4><ul><li>C++<br>它能阻塞一个或多个线程，直到收到另一个线程发出通知或超时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合使用，C++11提供了两种类型的条件变量：    <ul><li>condition_variable,需配合std::unique_lock<a href="std::mutex">std::mutex</a>进行wait操作；   </li><li>condition_variable_any，和任意带有lock、unlock语义的mutex搭配使用。比较灵活，但是效率不如前者；    </li></ul></li></ul><p>notify_one、notify_all用于唤醒等待中的线程。    </p><ul><li>notify_one只会唤醒阻塞队列中的第一个线程，不存在锁争用，可以立即获取锁；</li><li>notify_all会唤醒阻塞队列中的所有线程，存在锁争用，只有一个线程能够获得锁，而其他未获取锁的线程会继续尝试获得锁(类似于轮询)，并不会再次主动阻塞。当持有锁的线程释放锁时，这些线程中的一个会获得锁，依次进行……</li></ul><p><font color=red><strong>notify的失效问题</strong></font>  </p><ul><li>当notify早于wait时，由于阻塞队列之中并没有阻塞线程，故此时的notify会丢失；</li><li>类似上面的逻辑，当原本需要wait的线程正在处理其他事情，而未进入阻塞状态，此时的notify也会丢失；</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; SyncQueue.h#pragma once#include&lt;list&gt;#include&lt;mutex&gt;#include&lt;thread&gt;#include&lt;condition_variable&gt;#include &lt;iostream&gt;template&lt;typename T&gt;class SyncQueue&#123;private:bool IsFull() const&#123;return m_queue.size() &#x3D;&#x3D; m_maxSize;&#125;bool IsEmpty() const&#123;return m_queue.empty();&#125;public:SyncQueue(int maxSize) : m_maxSize(maxSize)&#123;&#125;void Put(const T&amp; x)&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);while (IsFull())&#123;std::cout &lt;&lt; &quot;缓冲区满了，需要等待...&quot; &lt;&lt; std::endl;m_notFull.wait(m_mutex);&#125;m_queue.push_back(x);m_notEmpty.notify_one();&#125;void Take(T&amp; x)&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);while (IsEmpty())&#123;std::cout &lt;&lt; &quot;缓冲区空了，需要等待...&quot; &lt;&lt; std::endl;m_notEmpty.wait(m_mutex);&#125;x &#x3D; m_queue.front();m_queue.pop_front();m_notFull.notify_one();&#125;bool Empty()&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);return m_queue.empty();&#125;bool Full()&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);return m_queue.size() &#x3D;&#x3D; m_maxSize;&#125;size_t Size()&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);return m_queue.size();&#125;int Count()&#123;return m_queue.size();&#125;private:std::list&lt;T&gt; m_queue;                  &#x2F;&#x2F;缓冲区std::mutex m_mutex;                    &#x2F;&#x2F;互斥量和条件变量结合起来使用std::condition_variable_any m_notEmpty;&#x2F;&#x2F;不为空的条件变量std::condition_variable_any m_notFull; &#x2F;&#x2F;没有满的条件变量int m_maxSize;                         &#x2F;&#x2F;同步队列最大的size&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Test.cpp#include &quot;SyncQueue.hpp&quot;#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;SyncQueue&lt;int&gt; syncQueue(5);void PutDatas()&#123;for (int i &#x3D; 0; i &lt; 20; ++i)&#123;syncQueue.Put(888);&#125;&#125;void TakeDatas()&#123;int x &#x3D; 0;for (int i &#x3D; 0; i &lt; 20; ++i)&#123;syncQueue.Take(x);std::cout &lt;&lt; x &lt;&lt; std::endl;&#125;&#125;int main(void)&#123;std::thread t1(PutDatas);std::thread t2(TakeDatas);t1.join();t2.join();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>wait方法还可以接收一个条件</strong>：</p><pre class="line-numbers language-none"><code class="language-none">    std::lock_guard&lt;std::mutex&gt; locker(m_mutex);      &#x2F;&#x2F; 代码块1while (IsFull())&#123;std::cout &lt;&lt; &quot;缓冲区满了，需要等待...&quot; &lt;&lt; std::endl;m_notFull.wait(m_mutex);&#125;&#x2F;&#x2F;以上代码改写成&#x2F;&#x2F; 代码块2&#123;std::lock_guard&lt;std::mutex&gt; locker(m_mutex);std::cout &lt;&lt; &quot;缓冲区满了，需要等待...&quot; &lt;&lt; std::endl;m_notFull.wait(locker, [this]&#123;return !IsFull();&#125;);  &#x2F;&#x2F;此处就可以不用while循环&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>wait函数的执行逻辑:</strong></font>  </p><ul><li>IsFull() == true时wait阻塞当前线程；</li><li>当另一个线程发出notify后唤醒wait；</li><li>wait被唤醒后首先尝试获取m_mutex，当拿到锁之后当前线程拿到访问临界区的权限，继续处理，直到释放锁；</li></ul><p>对于代码块1而言，wait被唤醒且成功拿到锁之后继续执行while循环体，判断IsFull() == false后退出循环，继续执行其他操作，若IsFull() == true则释放锁并重新阻塞当前线程，所以若没有while循环，容易出现虚假唤醒的情况；  </p><p>对于代码块2而言，wait被唤醒且成功拿到锁之后会首先判断lambda表达式，为true则继续执行其他操作，若为false则释放锁并重新阻塞当前线程；</p><p>此外还有另外两个wait函数：   </p><ul><li>指定时长超时wait—wait_for</li><li>指定时刻超时—wait_until</li></ul><p><font color=purple><strong>虚假唤醒 spurious wakeup</strong></font><br>对于不带判断条件的wait函数，会存在虚假唤醒的情况，例如：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; push queuelock(mutex);queue.push_back(x);unlock(mutex);cond.notify_one();&#x2F;&#x2F; pop queuelock(mutex);if(queue.empty())   cond.wait();x&#x3D;queue.pop();unlock(mutex);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，我们现在有一个生产者-消费者队列和三个线程;</p><ul><li>1号线程从队列中获取了一个元素，此时队列变为空;</li><li>2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空;</li><li>这时，3号线程将一个元素入队，并调用cond.notify_one()唤醒wait线程;</li><li>处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(重新获取mutex锁，然后获取队列中的元素)；</li><li>然而可能出现这样的情况：当2号线程准备重新获得mutex锁时，此时1号线程刚好执行完之前的元素操作，然后再去请求获得mutex锁，1号线程在2号线程之前获得了mutex，并且锁检查到队列非空，就获取到了3号线程刚刚入队的元素，处理完之后释放mutex锁；</li><li>等到2号线程获得队列锁，从cond.wait()之后的位置开始执行代码，此时并不再去检查queue.empty()，1号线程”偷走了”这个元素，所以对于2号线程而言，这次唤醒就是”虚假”的，它需要再次等待队列非空；</li></ul><p>所以，我们需要使用while来避免虚假唤醒</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; push queuelock(mutex);queue.push_back(x);unlock(mutex);cond.notify_one();&#x2F;&#x2F; pop queuelock(mutex);while(queue.empty())   &#123;       cond.wait();   &#125;x&#x3D;queue.pop();unlock(mutex);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里需要注意的是</strong>：<br>对于带条件判断的wait、wait_for、wait_until函数而言已经具备避免虚假唤醒的情况，不需要使用while</p><ul><li>C<br>在需要频繁查询临界资源某个状态的场景下，若使用互斥锁mutex，其频繁的加解锁操作会严重浪费CPU资源。<br>如果让线程在等待特定条件到来之前，使线程进入休眠状态，一旦条件满足，立即唤醒睡眠的线程，这便是条件变量的同步方式，通常会搭配互斥锁一起使用。<br>常用函数：   </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;动态初始化pthread_cond_init(pthread_cond_t *cond, pthread_cond_attr_t *cond_attr)；&#x2F;&#x2F;第二个参数通常为空&#x2F;&#x2F;静态初始化pthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER&#x2F;&#x2F;销毁,只有在没有线程在该条件变量上等待的时候才能注销此变量，否则返回EBUSY&#x2F;&#x2F;由于条件变量没有分配什么资源，所以注销动作只是检查是否有等待线程int pthread_cond_destroy(pthread_cond_t *cond);&#x2F;&#x2F;等待，分为条件等待和时间等待，无论是哪种等待必须配合互斥锁，以防止多个线程对这两个等到函数产生竞争int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *bastime);&#x2F;&#x2F;触发，分为两种激发方式激活一个等待线程和激活所有等待线程&#x2F;&#x2F;如果没有线程在等待，pthread_cond_singal也会成功返回，即提前返回，之后的pthread_cond_wait将无法捕捉pthread_cond_singalpthread_cond_broadcast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>条件变量加互斥锁解决出租车问题：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;iostream&gt;#include &lt;pthread.h&gt;using namespace std;&#x2F;*提示出租车到达的条件变量*&#x2F;pthread_cond_t taxiCond &#x3D; PTHREAD_COND_INITIALIZER; &#x2F;*同步锁*&#x2F;pthread_mutex_t taxiMutex &#x3D; PTHREAD_MUTEX_INITIALIZER;   int travelerCound&#x3D;0;void * traveler_arrive(void * name)&#123;cout&lt;&lt;&quot;Traveler: &quot;&lt;&lt;(char *)name&lt;&lt;&quot; needs a taxi now!&quot;&lt;&lt;endl;pthread_mutex_lock(&amp;taxiMutex);travelerCound++;    pthread_cond_wait(&amp;taxiCond,&amp;taxiMutex);    pthread_mutex_unlock(&amp;taxiMutex);cout&lt;&lt;&quot;Traveler: &quot;&lt;&lt;(char *)name&lt;&lt;&quot; now got a taxi!&quot;&lt;&lt;endl;pthread_exit((void*)0);&#125;void * taxi_arrive(void * name)&#123;cout&lt;&lt;&quot;Taxi: &quot;&lt;&lt;(char *)name&lt;&lt;&quot; arrives.&quot;&lt;&lt;endl;while(1)&#123;pthread_mutex_lock(&amp;taxiMutex);if(travelerCound&gt;0)&#123;pthread_cond_signal(&amp;taxiCond);pthread_mutex_unlock(&amp;taxiMutex);            break;&#125;pthread_mutex_unlock(&amp;taxiMutex);&#125;pthread_exit((void*)0);&#125;int main()&#123;pthread_t tids[3];int iRet &#x3D; pthread_create(&amp;tids[0],NULL,taxi_arrive,(void*)(&quot; Jack &quot;));if(iRet)&#123;printf(&quot;pthread_create error: iRet&#x3D;%d\n&quot;,iRet);return iRet;&#125;printf(&quot;Time passing by.\n&quot;);sleep(1);iRet &#x3D; pthread_create(&amp;tids[1],NULL,traveler_arrive,(void*)(&quot; Susan &quot;));if(iRet)&#123;printf(&quot;pthread_create error: iRet&#x3D;%d\n&quot;,iRet);return iRet;&#125;printf(&quot;Time passing by.\n&quot;);sleep(1);iRet &#x3D; pthread_create(&amp;tids[2],NULL,taxi_arrive,(void*)(&quot; Mike &quot;));if(iRet)&#123;printf(&quot;pthread_create error: iRet&#x3D;%d\n&quot;,iRet);return iRet;&#125;printf(&quot;Time passing by.\n&quot;);sleep(1);void *retval;for(int i&#x3D;0;i&lt;3;i++)&#123;iRet&#x3D;pthread_join(tids[i],&amp;retval);if (iRet)&#123;printf(&quot;pthread_join error: iRet&#x3D;%d\n&quot;,iRet);return iRet;&#125;printf(&quot;retval&#x3D;%ld\n&quot;,(long)retval);&#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、读写锁"><a href="#3、读写锁" class="headerlink" title="3、读写锁"></a>3、读写锁</h4><p>对于读写者问题，存在两种情况：</p><ul><li>访问必须是排他的，即独占；</li><li>访问方式是共享的，即多个线程可同时访问临界资源；</li></ul><p>所以读写问题也叫共享-独占问题，适用于读写者问题的同步方式便是读写锁。   </p><p>读写锁的三种状态：</p><ul><li>读模式下加锁状态；<br>所有试图以加读锁的线程都可以得到访问权，若此时有另外的线程试图以写模式加锁，通常会阻塞随后的读锁请求，优先让写锁持有临界资源。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足的问题</li><li>写模式下加锁状态；<br>在解锁之前，所有试图加锁的线程都会被阻塞</li><li>不加锁状态；</li></ul><p>读写锁也叫做共享-独占锁，当以读模式锁住时，它是共享模式锁；当他以写模式锁住时，它是独占模式锁住。 </p><p>处理读写者问题的两种常见策略是强读者和强写者，常用函数如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F;初始化和销毁int pthread_rwlock_init(pthread_rwlock_t *rwptr, const pthread_rwlockattr_t *attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwptr);&#x2F;&#x2F;获取和释放int pthread_rwlock_rdlock;int pthread_rwlock_wrlock;int pthread_rwlock_tryrdlock;  &#x2F;&#x2F;非阻塞方式，如果锁被占用，立即返回EBUSYint pthread_rwlock_trywrlock;int pthread_rwlock_unlock;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define THREADNUM 5pthread_rwlock_t rwlock;void *readers(void *arg)&#123;    pthread_rwlock_rdlock(&amp;rwlock);    printf(&quot;reader %ld got the lock\n&quot;, (long)arg);    pthread_rwlock_unlock(&amp;rwlock);    pthread_exit((void*)0);&#125; void *writers(void *arg)&#123;    pthread_rwlock_wrlock(&amp;rwlock);    printf(&quot;writer %ld got the lock\n&quot;, (long)arg);    pthread_rwlock_unlock(&amp;rwlock);    pthread_exit((void*)0);&#125;int main(int argc, char **argv)&#123;    int iRet, i;    pthread_t writer_id, reader_id;    pthread_attr_t attr;    int nreadercount &#x3D; 1, nwritercount &#x3D; 1;    iRet &#x3D; pthread_rwlock_init(&amp;rwlock, NULL);    if (iRet) &#123;        fprintf(stderr, &quot;init lock failed\n&quot;);        return iRet;    &#125;    pthread_attr_init(&amp;attr);    &#x2F;*pthread_attr_setdetachstate用来设置线程的分离状态    也就是说一个线程怎么样终止自己，状态设置为PTHREAD_CREATE_DETACHED    表示以分离状态启动线程*&#x2F;    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);    for (i &#x3D; 0; i &lt; THREADNUM; i++)&#123;        if (i % 3) &#123;            pthread_create(&amp;reader_id, &amp;attr, readers, (void *)nreadercount);            printf(&quot;create reader %d\n&quot;, nreadercount++);        &#125; else &#123;            pthread_create(&amp;writer_id, &amp;attr, writers, (void *)nwritercount);            printf(&quot;create writer %d\n&quot;, nwritercount++);        &#125;    &#125;    sleep(5);&#x2F;*sleep是为了等待另外的线程的执行*&#x2F;    return 0;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、原子类型"><a href="#4、原子类型" class="headerlink" title="4、原子类型"></a>4、原子类型</h4><p>C++11提供了一个原子类型std::atomic<T>，可以将指定类型设置为原子量以达到无锁原子操作的目的<br>比如一个计数器原子量的实现：   </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;atomic&gt;struct Counter&#123;std::atomic&lt;int&gt; value &#x3D; 0;void increment()&#123;++value;&#125;void decrement()&#123;--value;&#125;int get()&#123;return value;&#125;&#125;;Counter g_counter;void Increments()&#123;for (int i &#x3D; 0; i &lt; 10; ++i)&#123;g_counter.increment();std::cout &lt;&lt; g_counter.get() &lt;&lt; std::endl;&#125;&#125;void Decrements()&#123;for (int i &#x3D; 0; i &lt; 5; ++i)&#123;g_counter.decrement();std::cout &lt;&lt; g_counter.get() &lt;&lt; std::endl;&#125;&#125;int main(void)&#123;std::thread t1(Increments);std::thread t2(Decrements);t1.join();t2.join();system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的问题：  </p><ul><li>不是所有类型都可以设置为原子量；</li><li>即使设置为原子量，其底层实现仍然可能是用锁实现的；</li></ul><p>详见：<br><a href="https://www.cnblogs.com/FateTHarlaown/p/8919235.html">C++11的原子量与内存序浅析</a><br><a href="https://blog.csdn.net/hdadiao/article/details/104614702">操作系统-原子性与锁机制</a></p><h2 id="2-3、线程标识"><a href="#2-3、线程标识" class="headerlink" title="2.3、线程标识"></a>2.3、线程标识</h2><p>这里主要阐述linux上的线程标识，POSIX threads库提供了pthread_self函数用于返回当前线程的标识符，其类型为pthread_t，pthread_t不一定是一个数值类型（整型或指针），也可能是一个结构体，因此Pthreads专门提供了pthread_equal函数对比两个线程标识符是否相等，这就带来了一系列问题：</p><ul><li>无法打印输出pthread_t；</li><li>无法比较pthread_t的大小或计算hash值，也无法用作关联容器的key；</li><li>无法定义一个非法的pthread_t值，用来表示绝对不可能存在的线程ID；</li><li>pthread_t只在进程内有意义，与操作系统的任务调度之间无法建立有效的关联；</li><li>Pthreads只保证同一进程之内，同一时刻的各个线程的id不同，不能保证同一进程先后多个线程具有不同的ID，更不用说一台机器上多个进程之间的线程ID的唯一性了；</li></ul><p>linux系统上建议使用gettid(2)系统调用的返回值作为线程ID，这么做的好处是：</p><ul><li>它的类型是pid_t，通常是一个小整数；</li><li>它直接表示内核的任务调度id；</li><li>任何时刻它都是全局唯一的，并且由于linux分配新pid采用递增轮回办法，短时间内启动的多个线程也会具有不同的id；</li><li>0是非法值，因为操作系统的第一个进程init的pid是1；</li></ul><p>但是C/C++标准并未封装gettid，此时可以使用boost::this_thread::get_id()，该函数利用__thread变量缓存gettid的返回值，这样只有在本线程第一次调用它的时候才会进行系统调用，以后都是直接从thread local缓存中直接获取，效率无忧。</p><h2 id="2-4、线程的销毁"><a href="#2-4、线程的销毁" class="headerlink" title="2.4、线程的销毁"></a>2.4、线程的销毁</h2><p>线程的销毁有几种方式：</p><ul><li>自然死亡：线程任务执行完毕正常退出；</li><li>非正常死亡：线程抛出异常、触发segfault信号等非法操作；</li><li>自杀：在线程中调用pthread_exit()退出线程；</li><li>他杀：其他task调用pthread_cancel()来强制终止；</li></ul><p>详见：<br><a href="https://blog.csdn.net/jasonchen_gbd/article/details/78674716">Linux编程–终止线程的正常方式及取消点</a><br><a href="https://www.cnblogs.com/cthon/p/9078042.html">Linux线程退出、资源回收、资源清理的方法</a>  </p><h2 id="2-5、锁"><a href="#2-5、锁" class="headerlink" title="2.5、锁"></a>2.5、锁</h2><p>可参考<strong>计算机系统_贰.6、实时操作系统 FreeRTOS.6.4.3节信号量</strong></p><h3 id="2-5-1、锁的本质"><a href="#2-5-1、锁的本质" class="headerlink" title="2.5.1、锁的本质"></a>2.5.1、锁的本质</h3><p>锁是解决多核心并发访问共享资源时产生的缓存时序一致性的必要手段，当给资源加锁时，只有一个线程能够访问资源，其他线程将阻塞。<br>底层实现是利用处理器提供的带锁的访存指令或原子操作指令。</p><p><font color=red><strong>锁的底层实现:</strong></font></p><p>对于一个锁而言，其无非就是一个flag位，例如flag为1表示锁定，flag为0表示未锁定。加锁的过程即为先读取flag的值，如果是0则flag置为1，否则线程阻塞。读取flag与flag置1这个两个操作合起来则不是一个原子操作，需要通过一定的机制来保证该操作的原子性。</p><p>实现加锁的关键还是读取锁和置锁的过程必须是原子的，所以：</p><ul><li>对于单核CPU而言，最好的方法就是关中断，这样可以保证在读取锁和置锁期间不会发生任务的调度；</li><li>对于多核CPU而言，类似递减这样的简单指令，实际上需要三个操作才能完成，先从内存读取数据到寄存器、寄存器内完成递减、最后将结果写回内存，在这种场景下，即便是一条指令，也无法保证原子性。因此多核CPU通常采用的方法是：<ul><li>锁总线：即在指令执行前先通过总线锁锁住CPU和内存的通信。总线锁会引起其他核的其他任务同时被锁住，导致多核的并行变成了串行化，开销太大；</li><li>缓存锁：详见：<strong>详见下方1小节</strong></li></ul></li></ul><p><font color=red><strong>重要</strong>：锁所锁住的到底是什么呢？<br>锁住的既不是代码段也不是内存段，锁的动作仅是确保获取锁的时刻是原子操作，确保仅有一个task拿到锁，其他获取不到锁的task使其阻塞，保证同一时刻只有一个task能够访问”锁住的资源”，进而实现数据的一致性。</font></p><h4 id="1、-缓存锁"><a href="#1、-缓存锁" class="headerlink" title="1、 缓存锁"></a>1、 缓存锁</h4><p>通过缓存一致性机制来保证原子操作，缓存一致性即MESI协议，如下：</p><ul><li>每个CPU有自己的高速缓存，高速缓存以缓存行的形式存在，而MESI就是给每个缓存行保存一个标志位，标志位如下：<ul><li>M：被修改的，当前缓存行中的数据相对内存而言已经被修改了，但是还没有更新到内存中，同时处于该状态的数据只有当前CPU缓存中有，而其他CPU缓存中没有；</li><li>E：独占的，缓存行中的数据没有被修改，但是数据被当前CPU独占；</li><li>S：共享的，缓存行中的数据被多个CPU共享；</li><li>I：无效的，当前缓存行中的数据已经无效</li></ul></li></ul><p>一个处于M状态的缓存行，要时刻监听所有试图读取该缓存行对应内存的CPU，如果监听到，则必须在其他CPU读取前，先将缓存行中的数据写入；一个处于S状态的缓存行，必须时刻监听其他试图修改该缓存数据或者独占该缓存数据的请求，如果监听到，则将S状态置为I；一个处于E状态的缓冲行必须时刻监听其他试图读取该数据内存地址的CPU，如果监听到，则将E置为S。<br>有了上述的准备过程后，CPU对数据的读写过程如下：</p><ul><li>读：如果缓存行中的数据是I的，则需要从内存中读取，但是要先等其他拥有此数据的处于M状态的CPU将数据写回内存，如果是S的，则可以直接使用缓存行中的数据；</li><li>写：如果缓存行中的数据是M/E，则CPU可以直接写，如果缓存行中的数据是S的，则要通过总线事务通知其他CPU将缓存置为无效I，这种情况下开销大，之后CPU可以向缓存行中写，写完后将缓存行置为M（这里的读写都是针对CPU对高速缓存的读写）</li></ul><h3 id="2-5-2、信号量"><a href="#2-5-2、信号量" class="headerlink" title="2.5.2、信号量"></a>2.5.2、信号量</h3><p>最早期的锁是Semaphore信号量，由荷兰计算机科学家发明，将信号量的值初始化为1，加锁操作即锁变量-1，解锁操作即锁变量+1。   </p><p>其将加锁函数设计为阻塞模式，也就是说如果拿不到锁，则函数会把当前进程设置为阻塞状态，直到其他进程解锁，才会由解锁函数将阻塞的进程重新设置为运行态。 </p><p>信号量的分类详见：<strong>计算机系统_贰.6、实时操作系统 FreeRTOS.6.4.3节信号量</strong>   </p><p><font color=red>信号量作为锁的缺点: </font></p><ul><li>无权限检查机制，即A进程加的锁，可能会被B进程解锁，进而引起紊乱；</li><li>没有考虑优先级翻转的问题，详见<strong>计算机系统_贰.第6章.6.1.6、优先级翻转</strong>；</li></ul><p>正因为信号量作为锁存在上述问题，故出现了改进版本，即目前常用的mutex</p><h3 id="2-5-3、mutex互斥量"><a href="#2-5-3、mutex互斥量" class="headerlink" title="2.5.3、mutex互斥量"></a>2.5.3、mutex互斥量</h3><p>mutex的全称Mutual Exclusion   </p><p>mutex相比信号量的最大不同在于，mutex可以对加锁和解锁的人做检查，只允许加锁者解锁。  </p><p>对于拿不到mutex的task会进入阻塞态，直到持mutex方释放，才会获得mutex进而重新进入运行态。但对于实时性要求比较高的场景下，比如驱动程序，当拿不到mutex后进入阻塞态，可能会导致某些关键task的延时，故衍生出另一种锁机制—spinlock</p><h3 id="2-5-4、spinlock"><a href="#2-5-4、spinlock" class="headerlink" title="2.5.4、spinlock"></a>2.5.4、spinlock</h3><p>当task拿不到锁时，不停的尝试拿锁，直到拿到为止，这种做法属于spinlock自旋锁，意即原地等待，也称作忙等。此种机制将会非常耗费CPU资源，因为的它的实现基本就是while(1)循环方式，<font color=red><strong>所以spinlock最适合的场景是每个task不会长时间占有锁</strong></font>。spinlock是一种拿锁方式，semaphore与mutex的底层实现中有些地方就是使用了这种方式，比如对队列解锁时。   </p><p>spinlock只是一种拿锁方式，而不是一种独特的锁形式，semaphore与mutex是在基本的spinlock持锁方式之上，封装了抢不到就等待以及对应的唤醒机制。</p><h3 id="2-5-5、Futex"><a href="#2-5-5、Futex" class="headerlink" title="2.5.5、Futex"></a>2.5.5、Futex</h3><p>semaphore、mutex、spinlock都是内核态的调用，相比于用户态，系统调用的内核态开销是非常大的。基于这样的背景，衍生出了用户态的互斥锁Futex(Fast User Mode Mutex)。   </p><p>Futex是在用户态使用spinlock方式抢锁，那些抢不到锁的task通过系统调用通知内核将自己阻塞休眠，同时如果其他占有该锁的task后续释放了锁，则由内核负责第一时间唤醒自己来继续抢锁，这种方式比较合理，不会过多浪费CPU资源（毕竟还是需要内核态挂起、唤醒task）。   </p><p>值得一提的是Futex支持多进程间的互斥锁，其内部使用mmap方式让多个进程之间共享同一块物理内存，然后将锁变量放置其中，而被多个进程访问，且Futex支持优先级继承，可避免优先级翻转问题的出现。</p><h3 id="2-5-、死锁"><a href="#2-5-、死锁" class="headerlink" title="2.5.*、死锁"></a>2.5.*、死锁</h3><ul><li><strong>情况一</strong>：同一个线程中重复加锁会出现死锁，假如线程A中，第一次加锁mutxeA，未解锁之前又第二次加锁mutxeA，此时它就会等待第一次加锁后的解锁操作，但是由于是在同一个线程中，就永远等不到第一次加锁的解锁操作，陷入了永久的自我等待中，于是死锁，<font color=red>此种情况只针对普通锁，嵌套锁是可以重复加锁的</font>；</li><li><strong>情况二</strong>：线程间嵌套引起的重复加锁会出现死锁，假如线程A首先加锁mutxeA，然后线程B加锁mutxeB，紧接着线程A加锁mutxeB，然后线程B加锁mutxeA，当线程A加锁mutxeB时，线程B已经获取mutxeB了，此时线程A就会等待线程B释放mutxeB，然而在线程B加锁mutxeA时，线程A也已经获取了mutxeA，线程B就会等待线程A释放mutxeA，两个线程陷入了互相等待的过程，于是死锁；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Counter&#123;    public:    int value;    Mutex mutex_;&#125;void swap(Counter &amp;a, Counter &amp;b)&#123;    MutexLockGuard alock(a.mutex_);    MutexLockGuard block(b.mutex_);    ...value....&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果线程A执行swap(a,b)，而线程B同时执行swap(b,a)，就可能出现死锁。     </p><p>一个函数如果要锁住相同类型的多个对象，为了保证始终按照相同顺序加锁，可以通过比较mutex的对象地址，始终先加锁地址小的。</p><h2 id="2-6、线程安全"><a href="#2-6、线程安全" class="headerlink" title="2.6、线程安全"></a>2.6、线程安全</h2><p>所谓线程安全，即采用加锁机制，对某个共享数据进行互斥的访问，当某个task获取锁后才能访问该共享资源，而其他task是不能访问的，处于阻塞状态，当该task释放了锁，其他task才有机会获取锁，对共享资源进行访问，这样就不会出现数据不一致的问题，避免了脏数据的出现。</p><p>为什么会有线程安全问题？</p><p>因为当多个线程访问共享资源时（如全局变量，静态变量，堆内存），可能出现数据不一致的情况，例如一个写一个读发生时。</p><h2 id="2-、其他"><a href="#2-、其他" class="headerlink" title="2.#、其他"></a>2.#、其他</h2><h3 id="2-1、函数在多线程模式下只调用一次"><a href="#2-1、函数在多线程模式下只调用一次" class="headerlink" title="2.#.1、函数在多线程模式下只调用一次"></a>2.#.1、函数在多线程模式下只调用一次</h3><p>底层实现原理：猜测应该是使用了原子操作</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iosream&gt;#include&lt;thread&gt;#include&lt;mutex&gt;std::once_flag flag;void do_once()&#123;    std::call_once(flag, []()&#123;std::cout &lt;&lt; &quot;called once&quot;&lt;&lt;endl;&#125;);&#125;int main()&#123;    std::thread t1(do_once);    std::thread t2(do_once);    std::thread t3(do_once);        t1.join();    t2.join();    t3.join();        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：    </p><pre class="line-numbers language-none"><code class="language-none">called once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2、exit函数的线程安全问题"><a href="#2-2、exit函数的线程安全问题" class="headerlink" title="2.#.2、exit函数的线程安全问题"></a>2.#.2、exit函数的线程安全问题</h3><p><font color=red>有待商讨</font><br>关于exit，还可参考《C++知识小点》的13节和《多线程和进程》的3.2.2节。<br>exit()函数在C++之中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象，这样就会存在死锁的可能等其他问题</p><pre class="line-numbers language-none"><code class="language-none">void somethingCallExit()&#123;    exit();&#125;class GlobalObject&#123;    public:    void doit()    &#123;        MutexLockGuard lock(mutex_);        somethingCallExit();    &#125;        ~GlobalObject()    &#123;         MutexLockGuard lock(mutex_);         &#x2F;&#x2F; 清理操作    &#125;    private：    MutexLock mutex_;&#125;GlobalObject gobj;int main()&#123;    gobj.doit();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>GlobalObject::doit()函数辗转调用了exit()，从而触发了全局对象gobj的析构，GlobalObject的析构函数会试图加锁mutex_，而此时mutex_已经被GlobalObject::doit锁住了，于是出现了死锁；</li><li>还有一种可能是在其他线程a中调用exit，触发全局对象gobj的析构，然而此时又有线程b调用gobj，由于gobj已被析构，程序试图访问一个被析构的对象出现崩溃；</li></ul><p>所以说由于exit在退出时会触发全局对象的释放这一特性，不建议在线程之中调用exit，如果非要调用，那么可以直接使用_exit，此函数不会进行任何清理操作而直接退出进程。</p><h3 id="2-3、线程比进程调度开销小的原因"><a href="#2-3、线程比进程调度开销小的原因" class="headerlink" title="2.#.3、线程比进程调度开销小的原因"></a>2.#.3、线程比进程调度开销小的原因</h3><p>首先需要了解两点：</p><ul><li>进程与线程的差异；<br>从概念上上来讲，线程是进程的一部分，同样参与task调度，线程是任务调度的最小单元；<br>进程拥有资源，归属于同一进程下的所有线程共享这些资源，进程是操作系统分配资源的最小单元；<br>Linux中对于内核而言，并不区分进程和线程，二者使用同样的数据结构<code>struct task_struct</code>，具备独立的task标识参与进任务调度；<pre class="line-numbers language-c" data-language="c"><code class="language-c">struct task_struct &#123;    &#x2F;&#x2F; 进程状态    long              state;    &#x2F;&#x2F; 虚拟内存结构体    struct mm_struct  *mm;    &#x2F;&#x2F; 进程号    pid_t             pid;    &#x2F;&#x2F; 指向父进程的指针    struct task_struct   *parent;    &#x2F;&#x2F; 子进程列表    struct list_head      children;    &#x2F;&#x2F; 存放文件系统信息的指针    struct fs_struct      *fs;    &#x2F;&#x2F; 一个数组，包含该进程打开的文件指针    struct files_struct   *files;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>线程共享进程的资源主要包括两个部分，如上结构体中的mm(内存空间中除了栈空间是线程私有的)、files(文件系统)</li><li>任务task调度的开销；<br>主要有两方面的开销：<br> 1、上下文切换开销；<br> 2、任务调度后的CPU Cache、TLB不命中的开销,TLB是Translation Lookaside Buffer；</li></ul><p><font color=red><strong>对于上下文切换开销，进程与线程都是必须的，例如保存task运行的指令位置、寄存器、堆栈等信息，二者没有本质区别。<br>那么既然线程调度的struct task_struct都使用相同的资源，是不是就意味着，即使切换到了其他的线程，CPU Cache/TLB命中的概率会高很多？相反，进程调度使用的是不同的资源，每次换了个进程，就意味着原有的CPU Cache/TLB就不适用了，命中概率低很多甚至需要触发更多的缺页中断以便从内存重新加载，开销自然就更多。</strong></font>   </p><h4 id="1、CPU-cache"><a href="#1、CPU-cache" class="headerlink" title="1、CPU cache"></a>1、CPU cache</h4><p>CPU cache是用来对内存数据进行缓存，以缓解CPU执行速度与内存访问速度的巨大差距，提升操作系统运行效率。<br>CPU 的 Cache 又被细分了几层，常见的有 L1 Cache, L2 Cache, L3 Cache等，其访问延迟依次增加，实现的成本依次降低。<br>现代系统采用从 Register -&gt; L1 Cache -&gt; L2 Cache -&gt; L3 Cache -&gt; Memory -&gt; Mass storage的层次结构，是为解决性能与价格矛盾所采用的折中设计。程序的指令部分和数据部分一般分别存放在两片不同的cache中，对应指令缓存（I-Cache）和数据缓存（D-Cache）。<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE660639b078d54db53d5a9a56b3b4193a/39404" alt="image12">   </p><p>CPU cache的理论基础即<strong>0.2节的程序的局部性原理</strong>   </p><h4 id="2、TLB-Translation-Lookaside-Buffer"><a href="#2、TLB-Translation-Lookaside-Buffer" class="headerlink" title="2、TLB Translation Lookaside Buffer"></a>2、TLB Translation Lookaside Buffer</h4><p>首先需要了解页表的概念：<br>页表是虚拟内存技术的基础，用于虚拟地址或者说逻辑地址到物理地址的映射。   </p><p>页表存放在内存中，在处理器器引入MMU功能后，读取指令、数据需要访问两次内存：</p><ul><li>首先通过查询页表得到物理地址；</li><li>然后访问该物理地址读取指令、数据；</li></ul><p>为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称，可翻译为”地址转换后援缓冲器”，也可简称为”快表”。简单地说，TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，即无法命中时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。   </p><p>TLB的理论基础是<strong>0.2节程序的局部性原理</strong></p><h3 id="2-4、对象构造时的线程安全"><a href="#2-4、对象构造时的线程安全" class="headerlink" title="2.#.4、对象构造时的线程安全"></a>2.#.4、对象构造时的线程安全</h3><p>详见：<strong>C++壹的4.9.11节</strong></p><h3 id="2-5、对象销毁时的线程安全"><a href="#2-5、对象销毁时的线程安全" class="headerlink" title="2.#.5、对象销毁时的线程安全"></a>2.#.5、对象销毁时的线程安全</h3><p>详见：<strong>C++壹的4.9.12节</strong></p><h3 id="2-6、指针赋值为NULL的线程不安全性"><a href="#2-6、指针赋值为NULL的线程不安全性" class="headerlink" title="2.#.6、指针赋值为NULL的线程不安全性"></a>2.#.6、指针赋值为NULL的线程不安全性</h3><p>详见：<strong>C++壹的4.9.12节</strong></p><h1 id="3、task的退出-终止"><a href="#3、task的退出-终止" class="headerlink" title="3、task的退出/终止"></a>3、task的退出/终止</h1><p>在C++程序中，我们常常会看到一些有关”终止”的函数，如terminate、abort、exit等。这些函数容易让人产生疑惑，因为它们看起来都只是终止程序的运行而已，不过实际上它们还是有很大的区别的。   </p><h2 id="3-1、terminate函数-异常退出"><a href="#3-1、terminate函数-异常退出" class="headerlink" title="3.1、terminate函数(异常退出)"></a>3.1、terminate函数(异常退出)</h2><p>terminate函数实际上是C++语言中异常处理的一部分（包含在＜exception＞头文件里）。一般而言，当程序抛出异常或出现了非预期的行为便会调用terminate函数。<font color=red>terminate函数在默认情况下会去调用abort函数的</font>，不过用户可以通过set_terminate函数来改变默认的行为。    </p><h2 id="3-2、abort函数-异常退出"><a href="#3-2、abort函数-异常退出" class="headerlink" title="3.2、abort函数(异常退出)"></a>3.2、abort函数(异常退出)</h2><p>abort是更加底层的函数，<strong>它不会调用任何的析构函数，直接释放进程所有资源</strong>，多数时候这样直接退出进程是没有问题的，但是当进程与其他进程有交互，强制退出时，有可能导致其他进程处于意想不到的”中间状态”。    </p><h2 id="3-3、exit函数-正常退出"><a href="#3-3、exit函数-正常退出" class="headerlink" title="3.3、exit函数(正常退出)"></a>3.3、exit函数(正常退出)</h2><p>exit属于”正常退出”范畴的程序终止，exit函数会正常调用析构函数，并且还会调用atexit注册的函数，自定义一些退出前的操作，main函数return后会默认调用exit函数结束task：</p><pre class="line-numbers language-none"><code class="language-none">#include ＜cstdlib＞#include ＜iostream＞using namespace std;void openDevice()&#123;cout＜＜&quot;device is opened.&quot;＜＜endl;&#125;void resetDeviceStat()&#123;cout＜＜&quot;device stat is reset.&quot;＜＜endl;&#125;void closeDevice()&#123;cout＜＜&quot;device is closed.&quot;＜＜endl;&#125;int main()&#123;atexit(closeDevice);atexit(resetDeviceStat);openDevice();exit(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>值得注意的是</strong>:<br>注册的函数被调用的次序与其注册顺序相反。<br>main函数的正常退出或者exit函数的退出有些时候并不是那么令人满意，比如当堆空间有大量零散的内存时，用析构函数来释放的话，会相当费时。假如交由系统统一释放，反而更加快速；再比如，如果存在大量线程，进程退出时，需要等待线程的结束响应，如果恰好线程卡在I\O结束状态，那么整个进程就会处于”卡死”状态。</p><h2 id="3-4、-exit"><a href="#3-4、-exit" class="headerlink" title="3.4、_exit"></a>3.4、_exit</h2><p>详见《多线程和进程》3.2.2节，exit是对_exit函数的封装。</p><h2 id="3-5、quick-exit和at-quick-exit-正常退出"><a href="#3-5、quick-exit和at-quick-exit-正常退出" class="headerlink" title="3.5、quick_exit和at_quick_exit(正常退出)"></a>3.5、quick_exit和at_quick_exit(正常退出)</h2><p>快速退出函数quick_exit并不执行析构函数，而只是使程序终止。与abort不同的是，abort通常是异常退出（可能系统还会进行coredump等以辅助程序员进行问题分析），而quick_exit与exit同属于正常退出。此外，使用at_quick_exit注册的函数也可以在quick_exit的时候被调用。这样一来，我们同样可以像exit一样做一些清理的工作。</p><h2 id="3-6、exit与-exit的区别"><a href="#3-6、exit与-exit的区别" class="headerlink" title="3.6、exit与_exit的区别"></a>3.6、exit与_exit的区别</h2><p>exit定义在stdlib.h中，_exit定义在unistd.h中。_exit执行后立即返回给内核，而exit执行后要先执行一些清理操作，然后才会将控制权交给系统。_exit会直接关闭task的所有文件描述符，并不会刷新文件流。exit是_exit的封装，其会自动调用_exit，并在之前先刷新文件流，使内存缓存区里的文件流数据输出至”文件”之中；  </p><ul><li>最大的区别就在于，exit会先检查文件的打开情况，把内存缓存区的内容写回文件；  </li></ul><p>例子：   </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123;printf(&quot;using _exit.\n&quot;);printf(&quot;This is the content in buffer&quot;);_exit(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123;printf(&quot;using exit.\n&quot;);printf(&quot;This is the content in buffer&quot;);exit(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; .&#x2F;_exit  using _exit.  &#x2F;&#x2F; .&#x2F;exit  using _exit.  This is the content in buffer <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>1、printf函数在遇到\n才会从内存缓冲区中将记录输出至显示器；</li><li>2、_exit会直接关闭task的所有文件描述符，包括标准输出流，但并不会刷新标准流，而exit会先刷新标准输出流，然后再调用_exit函数;</li></ul><h1 id="4、虚拟内存"><a href="#4、虚拟内存" class="headerlink" title="4、虚拟内存"></a>4、虚拟内存</h1><h2 id="4-1、虚拟内存技术背景"><a href="#4-1、虚拟内存技术背景" class="headerlink" title="4.1、虚拟内存技术背景"></a>4.1、虚拟内存技术背景</h2><p>这就需要考量直接访问物理内存存在的问题：</p><ul><li><p>物理内存空间利用率的问题<br>task对内存的使用会导致内存碎片化，例如，当需要用malloc分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了；</p></li><li><p>直接读取物理内存的安全性问题<br>物理内存本身是不限制访问的，任何地址都可以被无权限读写，而现代操作系统需要实现不同的访问权限，例如只读数据、有效访问区间等；</p></li><li><p>task间的安全问题<br>task之间没有独立的地址空间，一个task由于执行错误指令或是恶意代码都可以直接修改其它task的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的</p></li><li><p>物理内存读写的效率问题<br>当大量task同时运行，需要分配给task的内存总和大于实际可用的物理内存时，往往需要将其他task暂时拷贝到硬盘当中，暂停运行，然后将新的task装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低；</p></li></ul><h2 id="4-2、程序加载过程"><a href="#4-2、程序加载过程" class="headerlink" title="4.2、程序加载过程"></a>4.2、程序加载过程</h2><p><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE78c8195da3c96c4770db263887025679/40363" alt="image15"><br>程序/可执行文件通过loader装载进操作系统之后可能存放的位置：</p><ul><li>物理内存：绝大多数情况下会存放在物理内存之中；</li><li>swap区：即外部磁盘存储器<br>当操作系统发现程序的某些物理内存空间长时间未被使用时，就会将其搬移至外部磁盘上，且此操作对于程序而言是不可见的，这部分被交换出去的内存空间位于swap区；</li><li>虚拟内存：CPU生成的地址空间，不是真实存在的地址，由物理地址映射而来；</li></ul><p>Windows或Linux之中用户task通常是看不到，也不关心物理地址，用户task所能看到的地址称作逻辑地址或者虚拟地址，由虚拟内存技术实现，让用户task的地址空间看起来是从0到max连续的(max = 操作系统所允许的最大地址范围)。相当于在用户task与物理地址之间搭建了一座桥梁，构造逻辑地址与物理地址的映射关系，这种映射称之为地址重定向，由操作系统的内存管理单元MMU来实现，与用户task无关。   </p><h2 id="4-3、虚拟内存映射"><a href="#4-3、虚拟内存映射" class="headerlink" title="4.3、虚拟内存映射"></a>4.3、虚拟内存映射</h2><p>Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的，进程可以很方便地访问。<br>虚拟内存空间又被划分为内核空间、用户空间，二者主要是访问权限上的差别。<br>进程所能看到的虚拟地址空间是这个样子的：<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCE930aaeb6d742be709fb56c77485017cb/40377" alt="image16"><br>这里会有一种错觉，每个进程似乎占用了OS的所有内存空间，事实上这是一种”假象”的做法，每个进程都以为自己占据了全部的地址空间，其实只有在实际使用虚拟内存的时候，才会分配物理内存；</p><p>虚拟内存映射框架<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEdfcb923a3ee6ba83edabf8025e56464f/40389" alt="image17"></p><h3 id="4-3-1、虚拟内存映射物理内存的时机"><a href="#4-3-1、虚拟内存映射物理内存的时机" class="headerlink" title="4.3.1、虚拟内存映射物理内存的时机"></a>4.3.1、虚拟内存映射物理内存的时机</h3><p>只有在虚拟内存被真正使用的时候才会通过缺页异常\中断触发系统调度进入内核态，然后通过MMU在物理主存上申请物理地址并映射进所在用户进程的虚拟地址空间之中。</p><h2 id="4-4、虚拟内存背景下CPU访问主存的过程"><a href="#4-4、虚拟内存背景下CPU访问主存的过程" class="headerlink" title="4.4、虚拟内存背景下CPU访问主存的过程"></a>4.4、虚拟内存背景下CPU访问主存的过程</h2><ul><li>把进程指令使用的虚拟地址通过MMU转换成物理地址；</li><li>把物理地址映射到高速缓存的缓存行，比如L1、L2级缓存；</li><li>如果高速缓存命中就返回；</li><li>如果不命中，则会产生一个缓存缺失中断，从主存相应的物理地址取值，并加载到高速缓存中；</li><li>CPU从中断中恢复，继续执行中断前的指令；</li></ul><p>所以高速缓存是与物理地址相映射的，使用虚拟内存的OS中指令寄存器中使用到的是虚拟地址。<br><img src="http://note.youdao.com/yws/public/resource/07f0d97f1d0985232b7b530dce4909ec/xmlnote/WEBRESOURCEbf31e0935cd2809be99d28a280b7c801/40414" alt="image18"></p><h2 id="4-5、虚拟内存的主要功能"><a href="#4-5、虚拟内存的主要功能" class="headerlink" title="4.5、虚拟内存的主要功能"></a>4.5、虚拟内存的主要功能</h2><ul><li>给所有进程提供一致的地址空间，每个进程都认为自己是在独占使用系统内存资源；</li><li>保护每个进程的地址空间不被其他进程破坏，隔离了进程的地址访问；</li><li>提供类似写时复制”Copy-On-Write”功能，虚拟内存只有在被访问时才会触发缺页中断进行物理地址的映射；</li></ul><h1 id="5、同步、异步、阻塞、非阻塞"><a href="#5、同步、异步、阻塞、非阻塞" class="headerlink" title="5、同步、异步、阻塞、非阻塞"></a>5、同步、异步、阻塞、非阻塞</h1><p><font color=green><strong>同步与异步是对应的</strong>:</font></p><ul><li>同步是one_by_one模型，比如两人对话，一问一答，必须在对方回到之后才能进行下一次问答称作同步；</li><li>异步是lot_by_lot模型，比如两人对话，可以多问多答，可以同时问多个问题，也可以同时多回答几个问题；</li></ul><p><font color=green><strong>阻塞与非阻塞是对应的</strong>:</font></p><ul><li>阻塞就是死等，比如两人对话，问完问题之后，死等对方回答，在此期间询问者不做任何其他事情；</li><li>非阻塞，比如两人对话，问完问题之后，询问者可以去做其他事情，不用一种等着对方回答；</li></ul><h1 id="6、大端、小端"><a href="#6、大端、小端" class="headerlink" title="6、大端、小端"></a>6、大端、小端</h1><p><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/WEBRESOURCEbb7b59cbdeea9443c2a4b52b1ad871a5/32669" alt="image">   </p><p>“大端”和”小端”可以追溯到1726年的Jonathan-Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争，之后此概念引入到了计算机中，在计算机的世界里用于描述数据在内存中的存放方式。</p><p>“大端”和小端可以以”高尾端”、”低尾端”的角度来理解会更容易一些。  </p><p>比如0X11223344十六进制整数，内存的最小存储单元为bit，8个bit为一个byte，对于十六进制而言，一位正好对应二进制的4位bit，那么一个byte则能存放两位十六进制数。以byte为单位来看的话，0X11223344的首端是0X11，尾端就是0X44<br><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/751165B18A904573AD028F92415E0C60/23503" alt="image"></p><h2 id="5-1、网络字节顺序"><a href="#5-1、网络字节顺序" class="headerlink" title="5.1、网络字节顺序"></a>5.1、网络字节顺序</h2><p>所有网络协议均是大端，但具体的字节顺序取决于数据类型和字节长度，如IP地址是字符串形式，不需要进行大小端转化，而端口号是整型且占两个字节，需要进行大小端转化。通常大端也称作网络字节序。</p><h2 id="5-2、主机字节顺序"><a href="#5-2、主机字节顺序" class="headerlink" title="5.2、主机字节顺序"></a>5.2、主机字节顺序</h2><p>对于操作系统而言，数据处理的字节顺序取决于CPU结构，通常而言都是小端模式。所以小端也称作主机字节序。</p>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-plus-零</title>
      <link href="2021/07/10/C-plus-%E9%9B%B6/"/>
      <url>2021/07/10/C-plus-%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1、基础部分"><a href="#1、基础部分" class="headerlink" title="1、基础部分"></a>1、基础部分</h1><h2 id="1-1、声明、定义、初始化、签名"><a href="#1-1、声明、定义、初始化、签名" class="headerlink" title="1.1、声明、定义、初始化、签名"></a>1.1、声明、定义、初始化、签名</h2><h3 id="1-1-1、声明式-declaraation"><a href="#1-1-1、声明式-declaraation" class="headerlink" title="1.1.1、声明式 declaraation"></a>1.1.1、声明式 declaraation</h3><p>告诉编译器某个对象的名称和类型，但略去细节，例如：</p><pre class="line-numbers language-none"><code class="language-none">int x;  &#x2F;&#x2F; no 对于内置类型，声明式即是定义式，因为它会自动生成默认值extern float y;  &#x2F;&#x2F; OK 外部引用声明class Weigth;  &#x2F;&#x2F; OK 类的前置声明int add(int a, int b);  &#x2F;&#x2F; OK 函数的前置声明template&lt;typename T&gt; class GraphNone;  &#x2F;&#x2F; OK 模板声明Using std::cin;   &#x2F;&#x2F; OK 名字空间引用声明Friend f;         &#x2F;&#x2F; OK 友元声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要区别的地方参见15.5</p><h3 id="1-1-2、定义式-definition"><a href="#1-1-2、定义式-definition" class="headerlink" title="1.1.2、定义式 definition"></a>1.1.2、定义式 definition</h3><p>提供声明式所遗漏的细节，对对象而言，定义式是编译器为对象申请内存，对函数而言，定义式提供代码本体，对class而言，定义式列出它们的成员。   </p><p>类的静态常量成员可以只有声明式（编译器的优化替换行为）：</p><pre class="line-numbers language-none"><code class="language-none">class A&#123;    public:    static const int a &#x3D; 10;  &#x2F;&#x2F; 这是常量声明式，并非定义式    static const float ftt &#x3D; 3.5;  &#x2F;&#x2F; 错误，不能直接在类中这样声明非整型静态常量成员&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照C++的规则，对于所使用的变量必须提供一个定义式，但是对于类的静态整型常量是个特殊情况，只要不访问其地址，就可省略其定义式，否则就需要在.cpp文件显示定义。<br>对于非整型的静态常量必须提供定义式，且不能在类的定义中直接赋予初值，如上面类中的ftt就是错误的声明式，报错：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error: &#39;constexpr&#39; needed for in-class initialization of static data member &#39;const float A::ftt&#39; of non-integral type [-fpermissive]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-1-3、签名式-signature"><a href="#1-1-3、签名式-signature" class="headerlink" title="1.1.3、签名式 signature"></a>1.1.3、签名式 signature</h3><p>函数的声明式即是其签名式，也就是参数和返回类型，函数的签名式等同于该函数的类型，C++官方并不把返回类型定义为签名式的一部分。</p><h3 id="1-1-4、初始化-initialization"><a href="#1-1-4、初始化-initialization" class="headerlink" title="1.1.4、初始化 initialization"></a>1.1.4、初始化 initialization</h3><p>它是给予对象初值的过程，对于类而言，就是执行构造函数的过程</p><ul><li>位于堆和栈中未初始化的变量保有不确定的值；</li><li>全局变量、静态全局变量、静态局部变量会被默认初始化为0</li><li>静态全局/局部变量只会被初始化一次</li><li>全局变量、静态全局变量、静态局部变量初始化时机<br>C：编译阶段已经完成默认初始化动作，所以C中不能使用普通变量对全局变量进行初始化；<br>C++：对于对象而言，首次执行相关代码的时候才会进行初始化，因为C++引入对象后，初始化动作要执行构造函数/析构函数，在构造函数/析构函数中需要执行一些特殊的操作，并非简单的内存分配；</li><li>类的const成员变量初始化：<br>必须在初始化列表里进行初始化，也可在class的声明处初始化，此方法与在构造函数的初始化列表里初始化相同，如果此时初始化列表重新指定值，那么声明时的值就会被修改掉；</li></ul><p><font color=red><strong>跨编译单元的初始化顺序问题</strong></font><br>C++对于”定义在不同编译单元内的全局对象”的初始化相对次序并无明确定义，也就是说根本无法确定初始化顺序，例如：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; a.cppclass FileSystem&#123;    size_t numDisks();&#125;extern FileSystem tfs;&#x2F;&#x2F;b.cppclass Directory&#123;    Directory();&#125;Directory::Directory()&#123;    size_t disks &#x3D; tfs.numDisks();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Directory使用tfs之前根本无法确定tfs是否已经初始化，这时候一个小小的操作便可解决，即：</p><ul><li>人为明确指定初始化顺序；</li><li>将每个non-local static对象搬到自己的专属函数内，此函数内对象被声明为static，同时返回引用指向该对象；</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; a.cppclass FileSystem&#123;    size_t numDisks();&#125;FileSystem &amp;tfs()&#123;    static FileSystem fs;    return fs&#125;&#x2F;&#x2F;b.cppclass Directory&#123;    Directory();&#125;Directory::Directory()&#123;    size_t disks &#x3D; tfs().numDisks();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法的基础在于：C++保证，函数内的local static对象会在该函数被调用期间，首次遇到该对象的定义式时进行初始化；    </p><h3 id="1-1-5、头文件include时的重复定义问题"><a href="#1-1-5、头文件include时的重复定义问题" class="headerlink" title="1.1.5、头文件include时的重复定义问题"></a>1.1.5、头文件include时的重复定义问题</h3><p>当在头文件中定义变量或函数时，如果该头文件被其他多个.cpp或.h包含时，会报重复定义的错误，<strong>因为C\C++定义只能有一次，而声明可以有无数次</strong>。  </p><p><strong>内置类型的声明式会默认初始化，所以头文件中内置类型的声明在多文件包含时也会报出重复定义问题。</strong></p><p><strong>以下是例外</strong>：    </p><ul><li>全局常量(const修饰的变量)可以声明并定义在头文件中，全局常量会以独立副本的形式存在于包含它的源文件之中； </li><li>静态全局变量(static修饰的)可以声明并定义在头文件中。但，假如a.cpp和b.cpp同时包含了静态变量，在b.cpp中修改操作并不会涉及到a.cpp中，彼此之间互不相关，因为它是以独立副本的形式存在；</li><li>类中的静态变量成员，如果类外定义的部分放在头文件之中，会报重复定义的错误，只能将类外定义放在.cpp文件，相当于在.cpp文件之中定义了类作用域的静态全局变量；</li><li>类的定义可以放在头文件中；</li><li>类的成员函数定义也可以放在头文件，默认为inline类型；</li><li>模板的定义可以放在头文件中；</li><li>inline函数定义可以放在头文件中</li></ul><p>值得注意的是如果声明了类、模板类型的头文件被多个其他文件重复包含，需要#pragma once，否则也会报重复定义错误。   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; test02.hpp#include &lt;iostream&gt;static int32_t static_i &#x3D; 10;const int32_t const_j &#x3D; 20;void print02();void print03();&#x2F;&#x2F; test02.cpp#include &quot;test02.hpp&quot;void print02()&#123;    printf(&quot;static value &#x3D; %d, address &#x3D; %p\n&quot;, static_i, &amp;static_i);    printf(&quot;const value &#x3D; %d, address &#x3D; %p\n&quot;, const_j, &amp;const_j);&#125;&#x2F;&#x2F; test03.cpp#include &quot;test02.hpp&quot;void print03()&#123;    printf(&quot;static value &#x3D; %d, address &#x3D; %p\n&quot;, static_i, &amp;static_i);    printf(&quot;const value &#x3D; %d, address &#x3D; %p\n&quot;, const_j, &amp;const_j);&#125;int main()&#123;    print02();    print03();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">static value &#x3D; 10, address &#x3D; 0x55d339171010const value &#x3D; 20, address &#x3D; 0x55d33916f050static value &#x3D; 10, address &#x3D; 0x55d339171014const value &#x3D; 20, address &#x3D; 0x55d33916f054<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2、对象的构造过程都发生了什么"><a href="#1-2、对象的构造过程都发生了什么" class="headerlink" title="1.2、对象的构造过程都发生了什么"></a>1.2、对象的构造过程都发生了什么</h2><ul><li><p>类类型   </p><ul><li>申请一块内存；</li><li>调用构造函数，赋予这块内存空间数据类型；</li><li>进入构造函数代码块之前，完成初始化；</li><li>构造函数代码块之内，完成赋值；</li></ul></li><li><p>内置类型：与类类型差不多，只是少了构造函数部分；</p></li></ul><h3 id="1-2-1、内存分配时机"><a href="#1-2-1、内存分配时机" class="headerlink" title="1.2.1、内存分配时机"></a>1.2.1、内存分配时机</h3><ul><li>全局变量、静态变量(包括局部静态变量)，在编译阶段由编译器完成内存分配；</li><li>其他变量，主要是堆栈上的变量，在运行期完成内存分配；</li></ul><h3 id="1-2-2、初始化时机"><a href="#1-2-2、初始化时机" class="headerlink" title="1.2.2、初始化时机"></a>1.2.2、初始化时机</h3><p>根据C++标准，全局变量的初始化要在main函数执行前完成，但是这个说法有点含糊，main 函数执行前又是什么时候呢？是编译时还是运行时？答案是既有编译时，也可能会有运行时。 从语言的层面来说，全局变量的初始化可以划分为以下两个阶段（c++11 N3690 3.6.2)：</p><ul><li>static initialization:<br>静态初始化（不是那个静态变量，注意区分概念）指的是用常量来对变量进行初始化,主要包括 zero initialization 和 const initialization。对简单类型(内建类型，POD等)来说，初始化在编译期由编译器完成（或者说，在程序加载的过程中完成），zero initialization 的变量会被保存在bss段，const initialization 的变量则保存在data段内，这与c语言里的全局变量初始化基本是一致的；<br><font color=purple> ps：zero initialization通常发生在隐式初始化时刻，即给全局变量显示指定初始化值的时候；</font></li><li>dynamic initialization：动态初始化主要是指需要经过函数调用才能完成的初始化，比如说，类类型的初始化（需要调用构造函数）等。这些变量的初始化会在运行期在main函数执行前进行；</li></ul><h3 id="1-2-3、全局类对象的初始化和析构执行者"><a href="#1-2-3、全局类对象的初始化和析构执行者" class="headerlink" title="1.2.3、全局类对象的初始化和析构执行者"></a>1.2.3、全局类对象的初始化和析构执行者</h3><p>由1.2.1与1.2.2节可知全局类对象的内存分配是在编译期完成的，而初始化是在运行期以动态初始化形式完成，那么是由谁来完成的呢？<br>答案是编译器，要注意不是编译期，它是由编译器在编译期生成相应代码，在运行期执行，比如：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;&#x2F; a.cppclass A&#123;public:    A();    ~A();&#125;;A g_a;  &#x2F;&#x2F; 全局变量&#x2F;&#x2F; b.cppA g_b;  &#x2F;&#x2F; 全局变量&#x2F;&#x2F; main.cppint main()&#123;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器会在每个单元编译的时候，获取单元内定义的全局变量，然后生成两个函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">_sti()_std()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这两个函数的代码大致如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">_sti_cppa()&#123;    g_a.A::A();&#125;_std_cppa()&#123;    g_a.A::~A();&#125;_sti_cppb()&#123;    g_b.A::A();&#125;_std_cppb()&#123;    g_b.A::~A();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，编译器为何要生成_sti、_std这两个函数？<br>因为，对于内置类型通常是使用常量给全局变量指定初始化值，但对于类类型，由于构造函数不是常量表达式，即非编译期常量，因此无法用构造函数给全局类对象指定初始化值，于是才有了编译器自动生成函数进行初始化的操作。</p><h2 id="1-3、深复制、浅复制、移动复制"><a href="#1-3、深复制、浅复制、移动复制" class="headerlink" title="1.3、深复制、浅复制、移动复制"></a>1.3、深复制、浅复制、移动复制</h2><p><font color=red><strong>1、深拷贝/浅拷贝</strong></font>   </p><p>概念是针对类的指针成员变量而言，常发生在拷贝构造函数和重载赋值操作符：</p><ul><li>浅拷贝：对于拷贝双方而言，二者的指针成员变量均指向同一块内存空间，拷贝的仅仅是指针变量本身而已。会引发多次析构同一堆空间问题；</li><li>深拷贝：对于拷贝双双方而言，二者的指针成员变量指向不同的内存空间，拷贝的不仅仅是指针变量，还有指针指向的内存空间；</li></ul><p><strong>【PS：普通拷贝构造函数、普通赋值操作符都是浅拷贝】</strong></p><p>示例：   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 浅拷贝#ifndef __COPY_HPP__#define __COPY_HPP__#include &lt;iostream&gt;class DeepCOPY&#123;    public:    DeepCOPY(const int tmp_value):m_ptr_(new int(tmp_value))&#123;&#125;    DeepCOPY(const DeepCOPY&amp; copyer):m_ptr_(copyer.m_ptr_)&#123;&#125;  &#x2F;&#x2F; 仿写默认拷贝构造函数    DeepCOPY&amp; operator&#x3D;(const DeepCOPY &amp;copyer)&#123;  &#x2F;&#x2F; 仿写默认重载赋值操作符            if (this !&#x3D; &amp;copyer) &#123;            this-&gt;m_ptr_ &#x3D; copyer.m_ptr_;        &#125;        return *this;    &#125;        ~DeepCOPY()    &#123;        if (m_ptr_ !&#x3D; nullptr) &#123;            delete m_ptr_;        &#125;    &#125;        int *m_ptr_;&#125;;#endifint main()&#123;    DeepCOPY copyer(10);    DeepCOPY copyed(copyer);    std::cout &lt;&lt; *(copyer.m_ptr_) &lt;&lt; std::endl;    std::cout &lt;&lt; *(copyed.m_ptr_) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于m_ptr指向同一块内存，copyer、copyed析构时会被重复delete</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 深拷贝#ifndef __COPY_HPP__#define __COPY_HPP__#include &lt;iostream&gt;class DeepCOPY&#123;    public:    DeepCOPY(const int tmp_value):m_ptr_(new int(tmp_value))&#123;&#125;    DeepCOPY(const DeepCOPY&amp; copyer):m_ptr_(new int(*(copyer.m_ptr_)))&#123;&#125;  &#x2F;&#x2F; 仿写默认拷贝构造函数    DeepCOPY&amp; operator&#x3D;(const DeepCOPY &amp;copyer)&#123;  &#x2F;&#x2F; 仿写默认重载赋值操作符            if (this !&#x3D; &amp;copyer) &#123;            this-&gt;m_ptr_ &#x3D; new int(*(copyer.m_ptr_));        &#125;        return *this;    &#125;    ~DeepCOPY()    &#123;        if (m_ptr_ !&#x3D; nullptr) &#123;            delete m_ptr_;        &#125;    &#125;        int *m_ptr_;&#125;;#endifint main()&#123;    DeepCOPY copyer(10);    DeepCOPY copyed(copyer);    std::cout &lt;&lt; *(copyer.m_ptr_) &lt;&lt; std::endl;    std::cout &lt;&lt; *(copyed.m_ptr_) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>2、移动复制参见5.5</strong>节</font> </p><h2 id="1-4、编译期常量"><a href="#1-4、编译期常量" class="headerlink" title="1.4、编译期常量"></a>1.4、编译期常量</h2><p>Compile-time constants在编译时期就要确定的变量，编译期常量主要来源：</p><ul><li>字面常量；</li><li>枚举量；</li><li>sizeof，编译器需要在编译期知道变量所占内存大小；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int count &#x3D; 10;  &#x2F;&#x2F; 整形字面常量 char name[4] &#x3D; &quot;Jack&quot;;  &#x2F;&#x2F; char型字面常量enum &#123;ONE&#x3D;1&#125;;  &#x2F;&#x2F; 枚举常量int buffer[sizeof(count)];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译期常量除了应用于变量类型之外，最常用到的地方就是数组、switch的case标签和模板</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">const int a &#x3D; 123;  &#x2F;&#x2F; 字面常量char str[12] &#x3D; &quot;abscdrf&quot;;  &#x2F;&#x2F; 12switch(a) &#123;    case 0:    break;    case 1:    break;    default:&#125;  &#x2F;&#x2F; 0、1template&lt;int i&gt; class StrTest&#123;    public:    int value_[i];&#125;StrTest&lt;10&gt; a_StrTest;  &#x2F;&#x2F; 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5、struct：C-C"><a href="#1-5、struct：C-C" class="headerlink" title="1.5、struct：C\C++"></a>1.5、struct：C\C++</h2><ul><li>C语言中struct是用户数据类型UDT，C++中struct是抽象数据类型ADT，支持成员函数的定义；</li><li>C中struct不具有访问权限设置，只是变量的集合体，可以封装数据但不可隐藏数据，而且成员不能是函数，C++中struct具有访问权限，默认为public，可以像类一样具有成员函数；</li></ul><h2 id="1-6、指针与引用的区别"><a href="#1-6、指针与引用的区别" class="headerlink" title="1.6、指针与引用的区别"></a>1.6、指针与引用的区别</h2><ul><li>指针是变量的地址，是一个实体，需要分配内存空间，引用只是变量的别名；</li><li>引用必须初始化，且不能为NULL；</li><li>指针可以被修改而指向其他变量，引用初始化之后不能被修改为其他变量的别名；</li><li>指针有二级、三级、多级指针；</li><li>指针的自增/减运算是指向下一个地址空间，引用的自增/减运算是变量自身的±1；</li><li>指针对变量是间接访问，需要解引用符号*，引用是直接访问；</li><li>sizeof引用得到的是变量自身的内存空间，sizeof指针仅是指针的内存空间， 与指针的类型不同；</li><li>作为函数参数时，传指针的实质是传值，传引用的实质是传地址；</li></ul><h2 id="1-7、零长度数组"><a href="#1-7、零长度数组" class="headerlink" title="1.7、零长度数组"></a>1.7、零长度数组</h2><h2 id="1-8、RAII"><a href="#1-8、RAII" class="headerlink" title="1.8、RAII"></a>1.8、RAII</h2><p>RAII是C++的发明者Bjarne Stroustrup提出的概念，RAII全称是”Resource Acquisition is Initialization”，直译过来是”资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象离开作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>智能指针即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。<font color=red>本质就是在栈空间上创建对象，封装一层指针，使其指向堆内存，当离开栈空间时，对象析构进而释放堆内存。</font></p><h2 id="1-9、查询变量类型"><a href="#1-9、查询变量类型" class="headerlink" title="1.9、查询变量类型"></a>1.9、查询变量类型</h2><p>typeid可查询变量的类型，返回值是type_info类型，type_info的name成员函数可以返回类型的名字。 在C++11中又增加了hash_code成员函数，返回该类型唯一的哈希值</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;using namespace std;class White&#123;&#125;;class Black&#123;&#125;;int main()&#123;    White a;    Black b;        cout &lt;&lt; typeid(a).name() &lt;&lt; endl;&#x2F;&#x2F;5White    cout &lt;&lt; typeid(b).name() &lt;&lt; endl;&#x2F;&#x2F;5Black    White c;    bool a_b_sametype&#x3D;(typeid(a).hash_code()&#x3D;&#x3D;typeid(b).hash_code());    bool a_c_sametype&#x3D;(typeid(a).hash_code()&#x3D;&#x3D;typeid(c).hash_code());    cout &lt;&lt; &quot;\nSame type?&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;A and B ? &quot; &lt;&lt; (int)a_b_sametype &lt;&lt; endl;&#x2F;&#x2F;0    cout &lt;&lt; &quot;A and C ? &quot; &lt;&lt; (int)a_c_sametype &lt;&lt; endl;&#x2F;&#x2F;1    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">5White5BlackSame type?A and B ? 0A and C ? 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-10、sizeof"><a href="#1-10、sizeof" class="headerlink" title="1.10、sizeof"></a>1.10、sizeof</h2><p>sizeof是一个关键字，以宏的形式实现，用于获取对象占用内存大小，单位byte。   </p><ul><li>sizeof(class / object)，只计算类成员占用内存之和，不包括静态成员、函数；</li><li>sizeof不能用于函数名、表达式，会报错</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">error: ISO C++ forbids applying &#39;sizeof&#39; to an expression of function type [-fpermissive]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将数组名作为sizeof运算符的操作数可以获得整个数组所占内存空间，但作为函数参数传递时就退化为指针；</li></ul><h2 id="1-11、不能重载的运算符-关键字"><a href="#1-11、不能重载的运算符-关键字" class="headerlink" title="1.11、不能重载的运算符/关键字"></a>1.11、不能重载的运算符/关键字</h2><p>不是所有运算符都能重载，<code>成员运算符&#39;.&#39;、&#39;.*&#39;(指向类成员的指针操作符)、域运算符::、长度运算符sizeof、条件运算符&#39;?&#39;</code>都不能重载，虽然’.*‘不能被重载，但是’-&gt;*’却是可以被重载的；<br>还有new/delete也不能重载，因为它们是关键字，但它们的二级调用operator new / operator delete可以被重载；</p><h2 id="1-12、位运算"><a href="#1-12、位运算" class="headerlink" title="1.12、位运算"></a>1.12、位运算</h2><h3 id="1-12-1、不使用临时变量，交换a和b的值"><a href="#1-12-1、不使用临时变量，交换a和b的值" class="headerlink" title="1.12.1、不使用临时变量，交换a和b的值"></a>1.12.1、不使用临时变量，交换a和b的值</h3><pre class="line-numbers language-none"><code class="language-none">a &#x3D; a ^ b;b &#x3D; a ^ b;a &#x3D; a ^ b;&#x2F;&#x2F; 或者a &#x3D; a - b;b &#x3D; b + a;a &#x3D; b - a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了异或操作的交换律:</p><pre class="line-numbers language-none"><code class="language-none">a ^ b ^ a &#x3D;&#x3D; a ^ a ^ b &#x3D;&#x3D;b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-12-2、唯一出现奇数次的元素"><a href="#1-12-2、唯一出现奇数次的元素" class="headerlink" title="1.12.2、唯一出现奇数次的元素"></a>1.12.2、唯一出现奇数次的元素</h3><p>一个数组中除了一个数字出现一次之外，其他均出现偶数次，只扫描一次，找出这个数字：    </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 异或操作交换律int GetSingleDog(int *a, int n)&#123;    int result &#x3D; 0;    for(int i; i&lt;n;i++)    &#123;        result ^&#x3D;a[i];    &#125;    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-13、main函数"><a href="#1-13、main函数" class="headerlink" title="1.13、main函数"></a>1.13、main函数</h2><p>main函数是程序的入口，这种说法是不准确的。因为通常main函数的返回类型是int，那么必然有地方接收这个返回值，所以从这个角度而言，必然有其他地方在调用main函数，那么main函数就不是程序的第一入口。<br>在main函数之前和之后都发生了什么？<br>main函数之前会调用全局对象和静态对象的构造函数，初始化全局变量和静态变量；main函数之后会调用在atexit函数中注册的函数接收main的返回值。</p><h2 id="1-14、new-delete的重载"><a href="#1-14、new-delete的重载" class="headerlink" title="1.14、new/delete的重载"></a>1.14、new/delete的重载</h2><p>参考<strong>C++贰.7.7节</strong></p><h3 id="1-14-1、new与delete的调用流程"><a href="#1-14-1、new与delete的调用流程" class="headerlink" title="1.14.1、new与delete的调用流程"></a>1.14.1、new与delete的调用流程</h3><p><code>new --- operator new --- constructor</code><br>当编译器发现new关键字时，就会依次在当前类、基类中寻找operator new，找不到就在全局中找，再找不到就用默认的。   </p><p>类中的operator new默认是static属性。<br>delete的调用流程类似new  </p><p>operator new重载可以放在全局，也可以放到类内部   </p><h3 id="1-14-2、重载operator-new、operator-delete"><a href="#1-14-2、重载operator-new、operator-delete" class="headerlink" title="1.14.2、重载operator new、operator delete"></a>1.14.2、重载operator new、operator delete</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Test&#123;public:    Test(int32_t val):val_(val)&#123;&#125;    int32_t val_;    void * operator new(size_t size)    &#123;        std::cout &lt;&lt; &quot;overload operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;;    void operator delete(void *ptr)    &#123;        std::cout &lt;&lt; &quot;overload operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Test *ptr &#x3D; new Test(10);    std::cout &lt;&lt; ptr-&gt;val_ &lt;&lt; std::endl;    delete ptr;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-14-3、重载placement-new、placement-delete"><a href="#1-14-3、重载placement-new、placement-delete" class="headerlink" title="1.14.3、重载placement new、placement delete"></a>1.14.3、重载placement new、placement delete</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Test&#123;public:    &#x2F;&#x2F;Test()&#123;&#125;    Test(int32_t val):val_(val)&#123;&#125;    int32_t val_;&#x2F;&#x2F;private:    void * operator new(size_t size)    &#123;        std::cout &lt;&lt; &quot;overload operator new&quot; &lt;&lt; std::endl;        return std::malloc(size);    &#125;;    void operator delete(void *ptr)    &#123;        std::cout &lt;&lt; &quot;overload operator delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;    &#x2F;&#x2F; placement new    &#x2F;&#x2F; 不申请内存，只是返回传入的堆空间ptr    void * operator new(size_t size, void *ptr)    &#123;        std::cout &lt;&lt; &quot;overload placement new&quot; &lt;&lt; std::endl;        return ptr;    &#125;;    &#x2F;&#x2F; placement delete    void operator delete(void *ptr, size_t num)    &#123;        std::cout &lt;&lt; &quot;overload placement delete&quot; &lt;&lt; std::endl;        std::free(ptr);    &#125;&#125;;int main()&#123;    Test *ptr &#x3D; new Test(10);    std::cout &lt;&lt;&quot;address: &quot; &lt;&lt; std::hex &lt;&lt; ptr;    std::cout &lt;&lt; std::dec &lt;&lt; &quot;    val &#x3D; &quot; &lt;&lt; ptr-&gt;val_ &lt;&lt; std::endl;    Test *ptr2 &#x3D; new(ptr) Test(20);    std::cout &lt;&lt;&quot;address: &quot; &lt;&lt; std::hex &lt;&lt; ptr2;    std::cout &lt;&lt; std::dec &lt;&lt; &quot;    val &#x3D; &quot; &lt;&lt; ptr2-&gt;val_ &lt;&lt; std::endl;        delete ptr;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">overload operator newaddress: 0x55b189e702c0    val &#x3D; 10overload placement newaddress: 0x55b189e702c0    val &#x3D; 20overload operator delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从运行结果来看，很好印证了new只是调用operator new分配内存空间，而内存空间的初始化是由构造函数完成<br><font color=red>PS：通常placement delete不会重载，因为对它的调用是非法的<code>delete(m) ptr</code></font></p><h1 id="2、预处理"><a href="#2、预处理" class="headerlink" title="2、预处理"></a>2、预处理</h1><p>预处理阶段主要工作</p><ul><li>宏定义展开；</li><li>文件包含；</li><li>条件编译；</li><li>布局控制；</li></ul><h2 id="2-1、宏展开"><a href="#2-1、宏展开" class="headerlink" title="2.1、宏展开"></a>2.1、宏展开</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#defined 宏名  字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>注意”字符串”中()的运用，避免展开后语法上的错误；</li><li>没有前缀的代码块’{}’会在预处理展开阶段被优化掉，需要注意语法错误，比如<br><font color=red>do…while(0)</font>的妙用</li></ul><h2 id="2-2、do…while-0-的妙用"><a href="#2-2、do…while-0-的妙用" class="headerlink" title="2.2、do…while(0)的妙用"></a>2.2、do…while(0)的妙用</h2><p>看下面的例子：  </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#define Foo(x) &#123;\cout &lt;&lt; x &lt;&lt; endl; \cout &lt;&lt; x + 1 &lt;&lt; endl;\&#125;int main()&#123;if (1)Foo(2);elsecout &lt;&lt; 1000 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当把Foo(2)展开后会出现如下错误：</p><pre class="line-numbers language-none"><code class="language-none">if (1)cout &lt;&lt; x &lt;&lt; endl;         cout &lt;&lt; x + 1 &lt;&lt; endl;elsecout &lt;&lt; 1000 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里在展开后，原先宏定义前后的{大括号就被略掉了，所以出现了if结构上的语法错误，此时应该使用do  wihle来解决这类符合语句的问题    </p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;#define Foo(x) do&#123;\cout &lt;&lt; x &lt;&lt; endl; \cout &lt;&lt; x + 1 &lt;&lt; endl;\&#125;whileint main()&#123;if (1)Foo(2);elsecout &lt;&lt; 1000 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3、文件包含"><a href="#2-3、文件包含" class="headerlink" title="2.3、文件包含"></a>2.3、文件包含</h2><p>将被include的头文件展开</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-4、条件编译"><a href="#2-4、条件编译" class="headerlink" title="2.4、条件编译"></a>2.4、条件编译</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;1#ifdef 标识符宏         程序段1；    #else          程序段2；   #endif&#x2F;&#x2F;2#if defined(标识符宏)         程序段1；    #else          程序段2；   #endif&#x2F;&#x2F;3#if 表达式         程序段1；    #else          程序段2；   #endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5、布局控制extern-“C”"><a href="#2-5、布局控制extern-“C”" class="headerlink" title="2.5、布局控制extern “C”"></a>2.5、布局控制extern “C”</h2><p>在C++环境下告诉编译器其下代码按照C标准编译：</p><pre class="line-numbers language-none"><code class="language-none">#ifdef __cplusplusextern &quot;C&quot;  &#123;#endif      ...程序段;      #ifdef __cplusplus&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>__cplusplus是C++的预编译宏</p><h2 id="2-6、-与-在define中的作用"><a href="#2-6、-与-在define中的作用" class="headerlink" title="2.6、#与##在define中的作用"></a>2.6、#与##在define中的作用</h2><p><strong>#把其后面的宏参数进行字符串替换</strong>，这一过程叫做字符串化：</p><pre class="line-numbers language-none"><code class="language-none">#define PRINTCUBE(x) cout&lt;&lt;&quot;cube(&quot;&lt;&lt;#x&lt;&lt;&quot;)&#x3D;&quot;&lt;&lt;(x)*(x)*(x)&lt;&lt;endl;int y &#x3D;5;PRINTCUBE(5;PRINTCUBE(y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是：</p><pre class="line-numbers language-none"><code class="language-none">cube(5)&#x3D;125;cube(y)&#x3D;125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出，#只是将其后的宏参数进行简单的字符串化。<br>##将其前后的宏参数进行字符串化的拼接</p><pre class="line-numbers language-none"><code class="language-none">#define LINK3(x,y,z) x##y##zLINK3(&quot;C&quot;,&quot;+&quot;,&quot;+&quot;);LINK3(3,5,0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">C++350<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以字符串形式输出</p>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-plus-壹</title>
      <link href="2021/07/10/C-plus-%E5%A3%B9/"/>
      <url>2021/07/10/C-plus-%E5%A3%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="3、模板编程"><a href="#3、模板编程" class="headerlink" title="3、模板编程"></a>3、模板编程</h1><p>C++语言 = C语言的超集 + 抽象机制 + 标准库   </p><p><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE4494d1a8eae1462fca4d359eba57a220/38285" alt="image01"></p><h2 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h2><p>作为C++语言重要组成部分之一的抽象机制(Abstraction mechanisms)主要有两种：</p><ul><li>面向对象编程Object-oriented programming；</li><li>模板编程generic programming；</li></ul><p>为了实现面向对象编程，C++提供了类。在模板编程方面，C++提供了模板(Template)，以一种直观的方式表示<strong>通用概念</strong>generic concept。   </p><p>模板编程的应用主要有两种：</p><ul><li>泛型编程generic programming；</li><li>元编程metaprogramming；</li></ul><p>前者注重于通用概念的抽象，用于设计<strong>通用的类型、算法</strong>；<br>后者注重于设计模板推导时的选择selection和迭代iteration；</p><h2 id="3-2、泛型编程"><a href="#3-2、泛型编程" class="headerlink" title="3.2、泛型编程"></a>3.2、泛型编程</h2><p>依赖于语言自身提供的模板机制   </p><p>狭义的泛型编程主要是两类：</p><ul><li>类模板class template；</li><li>函数模板function template；</li></ul><p>二者能够产生新的类型，属于<strong>类型构造器</strong>type constructor，分别用于定义具有相似功能的类和函数，是泛型中对类型和算法的抽象。   </p><p>无论是函数模板还是类模板，在实际代码中看起来都是”千变万化”的。这些”变化”，主要是因为类型被当做了参数，导致代码中可以变化的部分更多了。</p><p>归根结底，模板无外乎两点：</p><ul><li>函数或者类里面，有一些类型我们希望它能变化一下，我们用标识符来代替它，这就是”模板参数”；</li><li>在需要这些类型的地方，写上相对应的标识符（”模板参数”）。</li></ul><p>当然，这里的”可变”实际上在代码编译好后就固定下来了，也称之为编译期的可变性。</p><h3 id="3-2-1、类模板"><a href="#3-2-1、类模板" class="headerlink" title="3.2.1、类模板"></a>3.2.1、类模板</h3><p>类模板定义：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt; class CA&#123;    T member;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>template是C++关键字，意味着模板定义的开始。<br>与函数类似，模板也有一系列参数，这些参数被囊括在template之后的&lt;&gt;中，例如上文中的typename T，称之为模板参数。T是模板的精髓，可以通过指定模板实参，将T替换为所需要的实际类型，例如用CA<int>来实例化模板类CA，等价于以下的代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class CA&#123;    int member;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可以看出，用实际类型替换模板参数，可以获得很多形式相同的类型，有效的减少了代码量。这种用法，我们称之为”泛型”Generic Programming，它最常见的应用即是STL容器模板类。</strong></p><h3 id="3-2-2、类模板的使用"><a href="#3-2-2、类模板的使用" class="headerlink" title="3.2.2、类模板的使用"></a>3.2.2、类模板的使用</h3><p>对于C++来说，类型最重要的作用之一就是用它去产生一个变量。例如我们定义了一个动态数组的模板类vector，它对于任意的元素类型都具有push_back和clear的操作，我们便可以如下定义这个类：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt;class vector&#123;public:    void push_back(T const&amp;);    void clear();private:    T* elements;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时我们的程序需要一个整型和一个浮点型的vector，那么便可以通过以下代码获得两个变量：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">vector&lt;int&gt; intArray;vector&lt;float&gt; floatArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量定义的过程可以分成两步来看：第一步，vector<int>将int绑定到模板类vector上，获得了一个”普通的类vector<int>“；第二步通过”vector”定义了一个变量。   </p><p><strong>通过类型绑定将模板类变成”普通的类”的过程，称之为模板实例化(Template Instantiate)</strong></p><h3 id="3-2-3、类模板的成员函数定义"><a href="#3-2-3、类模板的成员函数定义" class="headerlink" title="3.2.3、类模板的成员函数定义"></a>3.2.3、类模板的成员函数定义</h3><p>如果成员函数定义放在模板类内，则实现方法与普通类的成员函数一致，如果在类外实现，语法上略显复杂：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt;class vector&#123;public:    void clear();  &#x2F;&#x2F; 注意这里只有声明private:    T* elements;&#125;;template &lt;typename T&gt;void vector&lt;T&gt;::clear()  &#x2F;&#x2F; 函数的实现放在这里&#123;    &#x2F;&#x2F; Function body&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-4、函数模板"><a href="#3-2-4、函数模板" class="headerlink" title="3.2.4、函数模板"></a>3.2.4、函数模板</h3><p>函数模板的语法及使用与类模板基本一致</p><h3 id="3-2-5、整形作为模板参数"><a href="#3-2-5、整形作为模板参数" class="headerlink" title="3.2.5、整形作为模板参数"></a>3.2.5、整形作为模板参数</h3><p>模板参数除了是待定类型typename T之外，也可以是一个确切的整型类型（Integral Number），这里的整型数比较宽泛，包括布尔型，有/无符号的整型，甚至包括指针：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T&gt; class TemplateWithType;  &#x2F;&#x2F; 普通模板参数template &lt;int      V&gt; class TemplateWithValue;  &#x2F;&#x2F; 整型模板参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>按照C++ Template最初的想法，模板不就是为了提供一个类型安全、易于调试的宏吗？有类型就够了，为什么要引入整型参数呢？考虑到宏除了代码替换功能外，还有一个作用是作为常数出现，所以整型模板参数最基本的用途就是定义一个常数。例如这段代码的作用：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template &lt;typename T, int Size&gt; struct Array&#123;    T data[Size];&#125;;Array&lt;int, 16&gt; arr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于模板的匹配是在编译时完成，所以实例化模板的时候所使用的整型参数也必须要在编译期就能确定，必须是编译期常量。</p><h3 id="3-2-6、模板别名与模板实例化别名"><a href="#3-2-6、模板别名与模板实例化别名" class="headerlink" title="3.2.6、模板别名与模板实例化别名"></a>3.2.6、模板别名与模板实例化别名</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;class AddMethod&#123;public:    AddMethod(T num)&#123;std::cout &lt;&lt; &quot;constructer: &quot; &lt;&lt; num &lt;&lt; std::endl;&#125;    ~AddMethod()&#123;std::cout &lt;&lt; &quot;destructer: &quot; &lt;&lt; std::endl;&#125;    T a_;    T b_;&#125;;&#x2F;&#x2F; 模板实例化别名typedef AddMethod&lt;int32_t&gt; AddMethodInt;typedef AddMethod&lt;float&gt; AddMethodFloat;&#x2F;&#x2F; 模板别名template&lt;typename T&gt;using mapstr &#x3D; std::map&lt;T, std::string&gt;;template&lt;typename T&gt;void swap(T a_, T b_)&#123;    std::cout &lt;&lt; &quot;swap&quot; &lt;&lt; a_ &lt;&lt; &quot;, &quot; &lt;&lt; b_ &lt;&lt; std::endl;&#125;&#x2F;&#x2F;typedef swap&lt;int32_t&gt; swap_int;  &#x2F;&#x2F; 报错，提示函数模板swap不是类型名，因为typedef是为类型设置别名，而函数并不是类型int main()&#123;    AddMethodInt add01(0);    AddMethodFloat add02(1);    mapstr&lt;int32_t&gt; map01;    map01[0] &#x3D; &quot;Lisa&quot;;    std::cout &lt;&lt; &quot;map[0] &#x3D; &quot; &lt;&lt; map01[0] &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>模板别名和模板实例化别名只适用于类模板，因为typedef、using是设置类型的别名，而函数并不属于类型；</li><li>mapstr定义了一类以string为value的map容器；</li></ul><h2 id="3-3、STL"><a href="#3-3、STL" class="headerlink" title="3.3、STL"></a>3.3、STL</h2><ul><li><strong>顺序容器</strong><br>顾名思义，就是以线性方式存储数据的容器，如数组、vector、列表、dequeue，顺序容器通常具有插入速度快（多是在首位的插入删除），但查找速度慢的特点。’顺序’并不是指内存空间的连续，而是在内存空间上具有线性关系；</li><li><strong>关联容器</strong><br>以特殊相关性存储数据的容器，这将降低插入速度，但是在查找速度方面有很大优势。’特定相关性’包括排序、hash_table、无序；</li></ul><h3 id="3-3-1、顺序容器"><a href="#3-3-1、顺序容器" class="headerlink" title="3.3.1、顺序容器"></a>3.3.1、顺序容器</h3><p>包括：<br>std::vector—–动态数组类，与操作数组一样，在最后插入数据<br>std::deque—-与std::vector类似，但允许在开头插入或删除数据<br>std::list—-链表类，操作与双向链表一样，可在任何位置添加或删除对象<br>std::forward_list—-与std::list类似，但是单向链表，只能沿一个方向遍历<br>std::vector是动态数组，可以根据需求动态调整长度，可能同时伴随内存空间的再分配，因此需要频繁调整长度的vector通常会降低程序性能；     </p><p><strong>容器的选择</strong>：<br>vector:<br>优点：在末尾插入数据，速度快且固定，可以像数组一样访问；<br>缺点：调整大小时将影响性能，查询时间与容器元素个数成正比，只能在末尾插入；   </p><p>list:<br>优点：可在任意位置插入、删除数据，所需时间固定；<br>缺点：不能像数组一样随机访问，查询速度比vector慢，因为不是存储在连续内存中，查询时间与容器元素个数成正比；    </p><h3 id="3-3-2、关联容器"><a href="#3-3-2、关联容器" class="headerlink" title="3.3.2、关联容器"></a>3.3.2、关联容器</h3><p>包括：<br>std::set—–集合类，存储不同的值，插入时进行排序，时间复杂度为对数<br>std::unordered_set—–存储不同的值，插入时不排序，时间复杂度为对数<br>std::map—–映射类，存储键值-对，并根据唯一的键排序，时间复杂度为对数<br>std::unordered_map—–存储键值-对，不排序，时间复杂度为对数<br>std::multiset—–与set类似，但允许重复值<br>std::unordered_multiset—–与unordered_set类似，但允许重复值<br>std::multimap—–与map类似，但允许重复值<br>std::unordered_multimap—–与unordered_map类似，但允许重复值   </p><p><strong>容器的选择</strong>：<br>set\map：<br>优点：查询时间与元素个数的对数成正比，查询速度快于顺序容器；<br>缺点：插入时进行排序，因此插入速度很慢，元素键值要唯一；   </p><p>unordered_set\unordered_map：<br>优点：查询、插入、删除速度不受元素个数影响；<br>缺点：不对元素进行排序，元素键值要唯一；   </p><p>multiset\multimap：<br>优点：存储非唯一键值，查询时间与元素个数的对数成正比，查询速度快于顺序容器；<br>缺点：插入时进行排序，因此插入速度很慢；   </p><p>unordered_multiset\unordered_multimap：<br>优点：存储非唯一键值，查询、插入、删除速度不受元素个数影响；<br>缺点：不对元素进行排序；  </p><p><strong>总结</strong>：<br>1、对于map和set容器而言，其查找速度确实比vector和list要快，但他们本身的时间复杂度为对数，即仍然会随着元素数的增加，查询速度会下降，比如元素数从10000减少到100时，速度提升一倍；<br>2、虽然对数时间复杂度已相当不错，但还有速度更好，且插入和查询时间固定的容器，即unordered类容器（散列容器）   </p><h3 id="3-3-3、capacity与size"><a href="#3-3-3、capacity与size" class="headerlink" title="3.3.3、capacity与size"></a>3.3.3、capacity与size</h3><ul><li>capacity容量，指为容器分配的内存空间；</li><li>size元素数量，指容器中已使用的内存空间；</li></ul><p><strong>引申</strong>：<br>vector访问元素范围越界问题指的是size越界，但越界并不一定会引起程序崩溃，因为：</p><ul><li>此时越界的size可能并未超过capcacity，size &lt; n &lt; capacity内存区间已分配，只是并未初始化而已，所以不会引起程序崩溃；</li><li>只有当超过capacity且是未分配的内存空间才会引起程序的不确定行为；</li></ul><h3 id="3-3-4、std-vector动态数组"><a href="#3-3-4、std-vector动态数组" class="headerlink" title="3.3.4、std::vector动态数组"></a>3.3.4、std::vector动态数组</h3><ul><li>在数组末尾插入、删除元素时间固定，与数组元素数量无关；    </li><li>在数组中间添加、删除元素所需时间与该元素后的元素数量成正比；</li><li>vector的元素在内存中连续存放；</li></ul><h4 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;int main ()&#123;  std::vector &lt;int&gt; vecIntegers;   &#x2F;&#x2F; Instantiate a vector with 10 elements (it can grow larger)   std::vector &lt;int&gt; vecWithTenElements (10);   &#x2F;&#x2F; Instantiate a vector with 10 elements, each initialized to 90   std::vector &lt;int&gt; vecWithTenInitializedElements (10, 90);   &#x2F;&#x2F; Instantiate one vector and initialize it to the contents of another   std::vector &lt;int&gt; vecArrayCopy (vecWithTenInitializedElements);   &#x2F;&#x2F; Use iterators and instantiate a vector to 5 elements taken from another   std::vector &lt;int&gt; vecSomeElementsCopied ( vecWithTenElements.cbegin ()                           , vecWithTenElements.cbegin () + 5 );   &#x2F;&#x2F; 数组初始化列表的方式   std::vector &lt;int&gt; vecArrayCopy &#x3D; &#123;10，20,3,30,50&#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h4><ul><li>push_back在末尾插入；</li><li>emplace_back在末尾插入，接收右值引用实参，可以避免不必要的内存操作；</li><li>insert在指定位置插入，但效率极低，通常不会使用；</li></ul><h4 id="3、访问"><a href="#3、访问" class="headerlink" title="3、访问"></a>3、访问</h4><ul><li>数组下标形式访问vector[i]；</li><li>at()函数访问vector.at(i)，会检查地址越界问题；</li><li>迭代器访问；</li></ul><h4 id="4、删除元素"><a href="#4、删除元素" class="headerlink" title="4、删除元素"></a>4、删除元素</h4><ul><li>pop_back末尾删除;</li><li>erase指定位置删除，iterator作为参数，但效率极低，通常不会使用；</li></ul><h4 id="5、插入与删除的迭代器失效问题"><a href="#5、插入与删除的迭代器失效问题" class="headerlink" title="5、插入与删除的迭代器失效问题"></a>5、插入与删除的迭代器失效问题</h4><p>vector删除元素时，被删除元素及之后的迭代器会失效，这是因为</p><ul><li>vector在内存中是连续存放的；</li><li>非末尾位置插入与删除操作都会引起当前位置及之后元素的移动，<br>甚至当插入操作超过capacity时更会引起vector的整体移动；</li><li>通过源码可以看出，当迭代器发生移动的时候，其内部的指针并没有更新，此时对该指针的相关操作就会出现内存访问异常的可能，此现象称作迭代器失效；</li></ul><h4 id="6、vector的扩容机制"><a href="#6、vector的扩容机制" class="headerlink" title="6、vector的扩容机制"></a>6、vector的扩容机制</h4><ul><li>vector默认初始化的size、capacity都为0；</li><li>插入时，若size = 0，扩容size为1；</li><li>插入时，若size != 0，则两倍 2 * size 扩容；</li></ul><h4 id="7、负载因子"><a href="#7、负载因子" class="headerlink" title="7、负载因子"></a>7、负载因子</h4><p><code>DEFAULT_LOAD_FACTOR</code> 负载因子：默认值为0.75。 当元素的总个数&gt;当前数组的容量 * 负载因子。数组会进行扩容，扩容为原来的两倍，扩容机制详见第</p><h4 id="8、clear、swap、resize、reserve、shrink-to-fit"><a href="#8、clear、swap、resize、reserve、shrink-to-fit" class="headerlink" title="8、clear、swap、resize、reserve、shrink_to_fit"></a>8、clear、swap、resize、reserve、shrink_to_fit</h4><ul><li>clear清空容器的size，相当于反初始化，对capacity没有影响，容器此时仍占有内存空间，并未释放；</li><li>swap，与另一个容器交换size和capacity，相当于指针交换，两个容器所在的内存空间并未变化；</li><li>resize调整容器的size，n为当前容器的size，m为目标size   <ul><li>当m &gt; n时，size扩容为m，同时可以指定扩容的部分初始值为t,   resize(m,t);</li><li>当m &lt; n时，size会缩减为m，被缩减的部分相当于反初始化；</li></ul></li><li>reserve调整容器容量，只有当目标容量大于当前容量操作才会生效,扩容操作通常会由编译器自动完成，规则由编译器决定，比如g++是2倍扩容规则；</li><li>shrink_to_fit裁剪容器，使size = capacity，结合clear可以释放容器；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;vector&gt;int main()&#123;    std::vector&lt;int&gt; vt01(10, 11);    std::vector&lt;int&gt; vt02(100, 22);    std::cout &lt;&lt; &quot;*****01*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;    for (int32_t i &#x3D; 0; i &lt; 100; ++i) &#123;        vt01.push_back(i);    &#125;    for (int32_t i &#x3D; 0; i &lt; 1000; ++i) &#123;        vt02.push_back(i);    &#125;         std::cout &lt;&lt; &quot;\n*****02*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;    &#x2F;&#x2F; reserve    vt01.reserve(200);    std::cout &lt;&lt; &quot;\n*****03*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;        vt01.reserve(20);    std::cout &lt;&lt; &quot;\n*****04*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;        &#x2F;&#x2F; resize    vt01.resize(200);    std::cout &lt;&lt; &quot;\n*****05*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    vt01.resize(20);    std::cout &lt;&lt; &quot;\n*****06*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    &#x2F;&#x2F; clear    std::cout &lt;&lt; &quot;\n*****07*****&quot; &lt;&lt; std::endl;    vt02.clear();    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;    &#x2F;&#x2F; swap    std::cout &lt;&lt; &quot;\n*****08*****&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;before&quot; &lt;&lt; std::endl;    vt01.resize(100, 11);    vt02.resize(1000, 22);        std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;after&quot; &lt;&lt; std::endl;    vt01.swap(vt02);    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;vt02 size &#x3D; &quot; &lt;&lt; vt02.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt02.capacity() &lt;&lt; std::endl;        &#x2F;&#x2F;std::vector&lt;int&gt;().swap(vt01);    &#x2F;&#x2F; shrink_to_fit    std::cout &lt;&lt; &quot;\n*****09*****&quot; &lt;&lt; std::endl;    vt01.shrink_to_fit();  &#x2F;&#x2F; 使size &#x3D; capacity, 释放未使用的内存空间    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;\n*****10*****&quot; &lt;&lt; std::endl;    &#x2F;&#x2F; 释放vector    vt01.clear();    vt01.shrink_to_fit();  &#x2F;&#x2F; 使size &#x3D; capacity, 释放未使用的内存空间    std::cout &lt;&lt; &quot;vt01 size &#x3D; &quot; &lt;&lt; vt01.size() &lt;&lt; &quot;    capacity &#x3D; &quot; &lt;&lt; vt01.capacity() &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">*****01*****vt01 size &#x3D; 10    capacity &#x3D; 10vt02 size &#x3D; 100    capacity &#x3D; 100*****02*****vt01 size &#x3D; 110    capacity &#x3D; 160vt02 size &#x3D; 1100    capacity &#x3D; 1600*****03*****vt01 size &#x3D; 110    capacity &#x3D; 200*****04*****vt01 size &#x3D; 110    capacity &#x3D; 200*****05*****vt01 size &#x3D; 200    capacity &#x3D; 200*****06*****vt01 size &#x3D; 20    capacity &#x3D; 200*****07*****vt02 size &#x3D; 0    capacity &#x3D; 1600*****08*****beforevt01 size &#x3D; 100    capacity &#x3D; 200vt02 size &#x3D; 1000    capacity &#x3D; 1600aftervt01 size &#x3D; 1000    capacity &#x3D; 1600vt02 size &#x3D; 100    capacity &#x3D; 200*****09*****vt01 size &#x3D; 1000    capacity &#x3D; 1000*****10*****vt01 size &#x3D; 0    capacity &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-5、std-list链表"><a href="#3-3-5、std-list链表" class="headerlink" title="3.3.5、std::list链表"></a>3.3.5、std::list链表</h3><p>list是双向链表，可双向遍历，插入、删除速度快，且时间固定。<br>forward_list是单向链表，只能沿一个方向遍历。   </p><h4 id="1、初始化-1"><a href="#1、初始化-1" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;list&gt;#include &lt;vector&gt;int main ()&#123;   using namespace std;   &#x2F;&#x2F; instantiate an empty list   list &lt;int&gt; listIntegers;   &#x2F;&#x2F; instantiate a list with 10 integers    list&lt;int&gt; listWith10Integers(10);   &#x2F;&#x2F; instantiate a list with 4 integers, each initialized to 99   list&lt;int&gt; listWith4IntegerEach99 (10, 99);   &#x2F;&#x2F; create an exact copy of an existing list   list&lt;int&gt; listCopyAnother(listWith4IntegerEach99);   &#x2F;&#x2F; a vector with 10 integers, each 2011   vector&lt;int&gt; vecIntegers(10, 2011);   &#x2F;&#x2F; instantiate a list using values from another container    list&lt;int&gt; listContainsCopyOfAnother(vecIntegers.cbegin(),                                        vecIntegers.cend());   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、插入-1"><a href="#2、插入-1" class="headerlink" title="2、插入"></a>2、插入</h4><p>在开头插入元素：push_front<br>在末尾插入元素：push_back<br>在中间插入元素：insert，且有很多重载版本      </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 版本一iterator insert(iterator pos, const T&amp; x)   pos: 插入位置；x：插入值；&#x2F;&#x2F; 版本二  void insert(iterator pos, size_type n,const T&amp; x)   pos：插入位置；n：插入元素个数;x：插入的值；&#x2F;&#x2F; 版本三   void insert(iterator pos, otherIterator begin, otherIterator end)   pos：插入位置；begin、end：插入起始范围<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents (const T&amp; Input)&#123;   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11       ; iElement !&#x3D; Input.cend()      ; ++ iElement )      cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;   cout &lt;&lt; endl;&#125;int main ()&#123;   list &lt;int&gt; listIntegers1;   &#x2F;&#x2F; Inserting elements at the beginning...   listIntegers1.insert (listIntegers1.begin (), 2);   listIntegers1.insert (listIntegers1.begin (), 1);   &#x2F;&#x2F; Inserting an element at the end...   listIntegers1.insert (listIntegers1.end (), 3);   cout &lt;&lt; &quot;The contents of list 1 after inserting elements:&quot; &lt;&lt; endl;   DisplayContents (listIntegers1);   list &lt;int&gt; listIntegers2;   &#x2F;&#x2F; Inserting 4 elements of the same value 0...   listIntegers2.insert (listIntegers2.begin (), 4, 0);   cout &lt;&lt; &quot;The contents of list 2 after inserting &#39;&quot;;   cout &lt;&lt; listIntegers2.size () &lt;&lt; &quot;&#39; elements of a value:&quot; &lt;&lt; endl;   DisplayContents (listIntegers2);   list &lt;int&gt; listIntegers3;   &#x2F;&#x2F; Inserting elements from another list at the beginning...   listIntegers3.insert (listIntegers3.begin (),                     listIntegers1.begin (), listIntegers1.end ());   cout &lt;&lt; &quot;The contents of list 3 after inserting the contents of &quot;;   cout &lt;&lt; &quot;list 1 at the beginning:&quot; &lt;&lt; endl;   DisplayContents (listIntegers3);   &#x2F;&#x2F; Inserting elements from another list at the end...    listIntegers3.insert (listIntegers3.end (),                   listIntegers2.begin (), listIntegers2.end ());   cout &lt;&lt; &quot;The contents of list 3 after inserting &quot;;   cout &lt;&lt; &quot;the contents of list 2 at the beginning:&quot; &lt;&lt; endl;   DisplayContents (listIntegers3);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h4><ul><li>erase指定位置删除，iterator作为参数；</li><li>remove指定值删除，自定义类型的list需要重载操作符==；</li></ul><h4 id="4、翻转"><a href="#4、翻转" class="headerlink" title="4、翻转"></a>4、翻转</h4><p>reverse函数</p><h4 id="5、sort排序"><a href="#5、sort排序" class="headerlink" title="5、sort排序"></a>5、sort排序</h4><p>参考：<br><a href="https://blog.csdn.net/li1615882553/article/details/83216113">STL中关于list容器的sort函数详解</a><br><a href="https://www.cnblogs.com/avota/archive/2016/04/13/5388865.html">STL库list::sort()实现深度解析</a>    </p><p>list有自己独立的排序函数sort，它与stl的sort类似（详见<strong>13.4.16节</strong>）    </p><p>为何list会有独立的sort实现？<br>从源码来看<br><code>STL sort</code>原型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class RandomAccessIterator&gt;inline void sort(RandomAccessIterator first, RandomAccessIterator last);template &lt;class RandomAccessIterator, class Compare&gt;inline void sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>list sort</code>原型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef bidirectional_iterator_tag iterator_category;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看出stl sort的迭代器是随机访问RandomAccessIterator，而list sort的迭代器是双向迭代器bidirectional，bidirectional是RandomAccessIterator子类，如果使用stl sort对list进行排序会因向上类型转换，而出现截断的问题</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct random_access_iterator_tag : public bidirectional_iterator_tag &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>list的sort有两个重载版本：</p><ul><li>默认版本没有参数，自定义类型需要重载运算符&lt;；</li><li>接受排序函数作为参数，可以自定义排序方法；</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;list&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents (const T&amp; Input)&#123;   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11      ; iElement !&#x3D; Input.cend()     ; ++ iElement )     cout &lt;&lt; *iElement &lt;&lt; endl;   cout &lt;&lt; endl;&#125;struct ContactItem&#123;   string strContactsName;   string strPhoneNumber;    string strDisplayRepresentation;   &#x2F;&#x2F; Constructor and destructor   ContactItem (const string&amp; strName, const string &amp; strNumber)   &#123;      strContactsName &#x3D; strName;      strPhoneNumber &#x3D; strNumber;      strDisplayRepresentation &#x3D; (strContactsName + &quot;: &quot; + strPhoneNumber);   &#125;   &#x2F;&#x2F; used by list::remove() given contact list item   bool operator &#x3D;&#x3D; (const ContactItem&amp; itemToCompare) const   &#123;      return (itemToCompare.strContactsName &#x3D;&#x3D; this-&gt;strContactsName);   &#125;   &#x2F;&#x2F; used by list::sort() without parameters   bool operator &lt; (const ContactItem&amp; itemToCompare) const   &#123;      return (this-&gt;strContactsName &lt; itemToCompare.strContactsName);   &#125;   &#x2F;&#x2F; Used in DisplayContents via cout   operator const char*() const   &#123;     return strDisplayRepresentation.c_str();   &#125;&#125;;bool SortOnPhoneNumber (const ContactItem&amp; item1,                            const ContactItem&amp; item2)&#123;   return (item1.strPhoneNumber &lt; item2.strPhoneNumber);&#125;int main ()&#123;   list &lt;ContactItem&gt; Contacts;   Contacts.push_back(ContactItem(&quot;Jack Welsch&quot;, &quot;+1 7889 879 879&quot;));   Contacts.push_back(ContactItem(&quot;Bill Gates&quot;, &quot;+1 97 7897 8799 8&quot;));   Contacts.push_back(ContactItem(&quot;Angela Merkel&quot;, &quot;+49 23456 5466&quot;));   Contacts.push_back(ContactItem(&quot;Vladimir Putin&quot;, &quot;+7 6645 4564 797&quot;));   Contacts.push_back(ContactItem(&quot;Manmohan Singh&quot;, &quot;+91 234 4564 789&quot;));   Contacts.push_back(ContactItem(&quot;Barack Obama&quot;, &quot;+1 745 641 314&quot;));   cout &lt;&lt; &quot;List in initial order: &quot; &lt;&lt; endl;   DisplayContents(Contacts);   Contacts.sort();   cout &lt;&lt; &quot;After sorting in alphabetical order via operator&lt;:&quot; &lt;&lt; endl;   DisplayContents(Contacts);   Contacts.sort(SortOnPhoneNumber);   cout &lt;&lt; &quot;After sorting in order of phone numbers via predicate:&quot; &lt;&lt; endl;   DisplayContents(Contacts);   cout &lt;&lt; &quot;After erasing Putin from the list: &quot;;   Contacts.remove(ContactItem(&quot;Vladimir Putin&quot;, &quot;&quot;));   DisplayContents(Contacts);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-6、deque双端队列"><a href="#3-3-6、deque双端队列" class="headerlink" title="3.3.6、deque双端队列"></a>3.3.6、deque双端队列</h3><p>双端队列（Double-ended queue，缩写为Deque，与list不同，它的底层实现不是链表，而是数组。</p><ul><li>可以高效的在头、尾两端插入、删除元素；</li><li>可以通过数组的方式访问元素；</li><li>deque 没有所谓的容量概念，因为它是动态地以分段连续空间组合而成随时可以增加一块新的空间并拼接起来。</li><li>虽然 deque 也提供 随机访问的迭代器，但它的迭代器与vectot、list都不一样，它的实现非常复杂和精妙；</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;deque&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;int main ()&#123;using namespace std;&#x2F;&#x2F; Define a deque of integersdeque &lt;int&gt; dqIntegers;&#x2F;&#x2F; Insert integers at the bottom of the arraydqIntegers.push_back (3);dqIntegers.push_back (4);dqIntegers.push_back (5);&#x2F;&#x2F; Insert integers at the top of the arraydqIntegers.push_front (2);dqIntegers.push_front (1);dqIntegers.push_front (0);cout &lt;&lt; &quot;The contents of the deque after inserting elements &quot;;cout &lt;&lt; &quot;at the top and bottom are:&quot; &lt;&lt; endl;&#x2F;&#x2F; Display contents on the screenfor ( size_t nCount &#x3D; 0; nCount &lt; dqIntegers.size (); ++ nCount )&#123;cout &lt;&lt; &quot;Element [&quot; &lt;&lt; nCount &lt;&lt; &quot;] &#x3D; &quot;;cout &lt;&lt; dqIntegers [nCount] &lt;&lt; endl;&#125;cout &lt;&lt; endl;&#x2F;&#x2F; Erase an element at the topdqIntegers.pop_front ();&#x2F;&#x2F; Erase an element at the bottomdqIntegers.pop_back ();cout &lt;&lt; &quot;The contents of the deque after erasing an element &quot;;cout &lt;&lt; &quot;from the top and bottom are:&quot; &lt;&lt; endl;&#x2F;&#x2F; Display contents again: this time using iterators&#x2F;&#x2F; deque &lt;int&gt;::iterator iElementLocator;  &#x2F;&#x2F; uncomment if using older compilers and remove auto belowfor (auto iElementLocator &#x3D; dqIntegers.begin (); iElementLocator !&#x3D; dqIntegers.end (); ++ iElementLocator )&#123;size_t Offset &#x3D; distance (dqIntegers.begin (), iElementLocator);cout &lt;&lt; &quot;Element [&quot; &lt;&lt; Offset &lt;&lt; &quot;] &#x3D; &quot; &lt;&lt; *iElementLocator &lt;&lt; endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、deque-的中控器"><a href="#1、deque-的中控器" class="headerlink" title="1、deque 的中控器"></a>1、deque 的中控器</h4><p>deque 在逻辑上看起来是连续空间，内部确实是由一段一段的定量连续空间构成。<br>一旦有必要在 deque的前端或尾端增加新空间，deque便会配置一段定量的连续空间，串接在整个 deque 的头部或尾部。<br>设计 deque 的大师们，想必设计的时候遇到的最大挑战就是如何在这些分段的定量连续空间上，还能维护其整体连续的假象，并提供其随机存取的接口，从而避开了像vector那样的”重新配置-复制-释放”开销三部曲。<br>这样一来，虽然开销降低，却提高了复杂的迭代器架构。因此 deque 数据结构的设计和迭代器前进或后退等操作都非常复杂。<br>deque 采用一块所谓的 map （注意不是 STL 里面的 map 容器）作为中控器，其实就是一小块连续空间，其中的每个元素都是指针，指向另外一段较大的连续线性空间，称之为缓冲区。在后面我们看到，缓冲区才是 deque 的储存空间主体</p><h3 id="3-3-7、std-set集合"><a href="#3-3-7、std-set集合" class="headerlink" title="3.3.7、std::set集合"></a>3.3.7、std::set集合</h3><p>set是集合类容器，一共四种</p><ul><li>std::set<T></li><li>std::multiset<T></li><li>std::unordered_set<T></li><li>std::unordered_multiset<T></li></ul><p>std::set<T>与std::multiset<T>内部结构是红黑二叉树：</p><ul><li>插入时排序，默认升序，也可指定排序方式；</li><li>自定义类型需要重载操作符&lt;;</li><li>插入、删除、查询时间复杂度为O(logN)；</li><li>std::set<T>元素必须唯一，std::multiset<T>元素可以重复；     </li></ul><p>std::unordered_set<T>与std::unordered_multiset<T>内部结构是hash_table：</p><ul><li>插入时不排序；</li><li>插入、删除、查询时间是具体情况而定，key不发生碰撞或极少的碰撞情况下时间复杂度O(1)，最坏的情况是O(n)，所有key都在同一个bucket内；</li><li>自定义类型需要实现hash函数和比较函数；</li></ul><h4 id="1、示例"><a href="#1、示例" class="headerlink" title="1、示例"></a>1、示例</h4><ul><li>*multiset中find查找后，返回第一个匹配的元素位置；</li><li>*multiset中count返回匹配的元素个数；</li><li>*multiset中erase删除所有匹配的元素；</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;string.h&gt;#include &lt;iterator&gt;using namespace std;struct LessOperator&#123;   &#x2F;&#x2F; 函数对象   bool operator() (const char *s1, const char *s2) const &#123;    return strcmp(s1, s2) &lt; 0;   &#125;&#125;;void printSet(set&lt;int&gt; s)&#123;set&lt;int&gt;::iterator iter;for (iter &#x3D; s.begin(); iter !&#x3D; s.end(); iter++) &#123;    cout&lt;&lt;*iter&lt;&lt;&quot;, &quot;;&#125;cout&lt;&lt;endl;&#125;int main()&#123;&#x2F;&#x2F;创建空的set对象，元素类型为intset&lt;int&gt; s1;&#x2F;&#x2F;创建空的set对象，元素类型char*，指定排序方式为 LessOperatorset&lt;const char*, LessOperator&gt; s2(LessOperator); set&lt;int&gt; s3(s1); &#x2F;&#x2F; 以指定范围的元素创建int iArray[] &#x3D; &#123;13, 32, 19&#125;;set&lt;int&gt; s4(iArray, iArray + 3);&#x2F;&#x2F; 以指定范围的元素创建，并指定排序方式const char* szArray[] &#x3D; &#123;&quot;hello&quot;, &quot;dog&quot;, &quot;bird&quot; &#125;;set&lt;const char*, LessOperator&gt; s5(szArray, szArray + 3, LessOperator);&#x2F;*元素插入：1,插入value，返回pair对象，可以根据second判断是否插入成功    pair&lt;iterator, bool&gt; insert(value)    2,在pos位置之前插入value，返回新元素位置，但不一定能插入成功    iterator insert(&amp;pos, value)    3,将指定范围的元素插入到set容器void insert[&amp;first, &amp;last);*&#x2F;cout&lt;&lt;&quot;s1.insert() : &quot;&lt;&lt;endl;for (int i &#x3D; 0; i &lt;5 ; i++)        s1.insert(i*10);    printSet(s1);cout&lt;&lt;&quot;s1.insert(20).second &#x3D; &quot;&lt;&lt;endl;if (s1.insert(20).second)        cout&lt;&lt;&quot;Insert OK!&quot;&lt;&lt;endl;else        cout&lt;&lt;&quot;Insert Failed!&quot;&lt;&lt;endl;   &#x2F;*元素删除    1,size_type erase(value) 删除元素值为value的所有元素，返回移除的元素个数    2,void erase(&amp;pos) 移除pos位置上的元素，无返回值    3,void erase(&amp;first, &amp;last) 移除迭代区间[&amp;first, &amp;last)内的元素，无返回值    4,void clear()， 移除set容器内所有元素*&#x2F;cout&lt;&lt;&quot;\ns1.erase(70) &#x3D; &quot;&lt;&lt;endl;s1.erase(70);printSet(s1);    cout&lt;&lt;&quot;set&lt;int&gt;::iterator iter &#x3D; s1.begin();\ns1.erase(iter) &#x3D; &quot;&lt;&lt;endl;    set&lt;int&gt;::iterator iter &#x3D; s1.begin();    s1.erase(iter);    printSet(s1);    &#x2F;*元素查找count(value)返回值为value的元素个数iterator find(value)返回value所在位置，找不到value将返回end()lower_bound(value),upper_bound(value), equal_range(value)*&#x2F;cout&lt;&lt;&quot;\ns1.count(10) &#x3D; &quot;&lt;&lt;s1.count(10)&lt;&lt;&quot;, s1.count(80) &#x3D; &quot;&lt;&lt;s1.count(80)&lt;&lt;endl;cout&lt;&lt;&quot;s1.find(10) : &quot;;if (s1.find(10) !&#x3D; s1.end()) cout&lt;&lt;&quot;OK!&quot;&lt;&lt;endl;elsecout&lt;&lt;&quot;not found!&quot;&lt;&lt;endl;&#x2F;*其它常用函数*&#x2F;cout&lt;&lt;&quot;\ns1.empty()&#x3D;&quot;&lt;&lt;s1.empty()&lt;&lt;&quot;, s1.size()&#x3D;&quot;&lt;&lt;s1.size()&lt;&lt;endl;set&lt;int&gt; s9;s9.insert(100);cout&lt;&lt;&quot;s1.swap(s9) :&quot;&lt;&lt;endl;s1.swap(s9);cout&lt;&lt;&quot;s1: &quot;&lt;&lt;endl;printSet(s1);cout&lt;&lt;&quot;s9: &quot;&lt;&lt;endl;printSet(s9);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-8、std-map映射"><a href="#3-3-8、std-map映射" class="headerlink" title="3.3.8、std::map映射"></a>3.3.8、std::map映射</h3><p>map是键-值对容器，一共那个：</p><ul><li>std::map&lt;key, value&gt;</li><li>std::multimap&lt;key, value&gt;</li><li>std::unordered_map&lt;key, value&gt;</li><li>std::unordered_multimap&lt;key, value&gt;</li></ul><p>std::map&lt;key, value&gt;与std::multimap&lt;key, value&gt;内部结构是红黑二叉树：</p><ul><li>插入时对ey排序，默认升序，也可指定排序方式；</li><li>自定义key类型需要重载运算符&lt;；</li><li>插入、删除、查询时间复杂度为O(logN)；</li><li>std::map&lt;key, value&gt;key必须唯一，std::multimap&lt;key, value&gt;key可以重复；</li></ul><p>std::unordered_map&lt;key, value&gt;与std::unordered_multimap&lt;key, value&gt;内部结构是hash_table：</p><ul><li>插入时不排序；</li><li>插入、删除、查询时间是具体情况而定，key不发生碰撞或极少的碰撞情况下时间复杂度O(1)，最坏的情况是O(n)，所有key都在同一个bucket内；</li><li>自定义key类型需要实现hash函数和比较函数；</li></ul><h4 id="1、初始化-2"><a href="#1、初始化-2" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">#include&lt;map&gt;#include&lt;string&gt;template&lt;typename KeyType&gt;struct SortDown  &#x2F;&#x2F; 降序&#123;   bool operator()(const KeyType&amp; key1, const KeyType&amp; key2)   &#123;      return (key1 &gt; key2);   &#125;&#125;;int main ()&#123;   using namespace std;   map&lt;int, string&gt; mapIntToString1;   &#x2F;&#x2F; map constructed as a copy of another   map&lt;int, string&gt; mapIntToString2(mapIntToString1);      &#x2F;&#x2F; map constructed given a part of another map or multimap   map&lt;int, string&gt; mapIntToString3(mapIntToString1.cbegin(),                                     mapIntToString1.cend());   &#x2F;&#x2F; map with a predicate that inverses sort order   map&lt;int, string, SortDown&lt;int&gt; &gt; mapIntToString4      (mapIntToString1.cbegin(), mapIntToString1.cend());   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2、插入-2"><a href="#2、插入-2" class="headerlink" title="2、插入"></a>2、插入</h4><p>插入方式：</p><ul><li>make_pair</li><li>pair</li><li>value_type</li><li>数组的方式</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; Type-define the map and multimap definition for easy readabilitytypedef map &lt;int, string&gt; MAP_INT_STRING;template &lt;typename T&gt;void DisplayContents (const T&amp; Input)&#123;   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11       ; iElement !&#x3D; Input.cend()      ; ++ iElement )      cout &lt;&lt; iElement-&gt;first &lt;&lt; &quot; -&gt; &quot; &lt;&lt; iElement-&gt;second &lt;&lt; endl;   cout &lt;&lt; endl;&#125;int main ()&#123;   MAP_INT_STRING mapIntToString;   &#x2F;&#x2F; Insert key-value pairs into the map using value_type   mapIntToString.insert (MAP_INT_STRING::value_type (3, &quot;Three&quot;));   &#x2F;&#x2F; Insert a pair using function make_pair   mapIntToString.insert (make_pair (-1, &quot;Minus One&quot;));   &#x2F;&#x2F; Insert a pair object directly   mapIntToString.insert (pair &lt;int, string&gt;(1000, &quot;One Thousand&quot;));   &#x2F;&#x2F; Insert using an array-like syntax for inserting key-value pairs   mapIntToString [1000000] &#x3D; &quot;One Million&quot;;   cout &lt;&lt; &quot;The map contains &quot; &lt;&lt; mapIntToString.size ();   cout &lt;&lt; &quot; key-value pairs. They are: &quot; &lt;&lt; endl;   DisplayContents(mapIntToString);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需要注意的是</strong>：<br>当使用数组方式插入时，如果map中已经存在key值，则会直接覆盖,存在误操作风险。   </p><p><strong>判断插入是否成功</strong><br>通过insert函数返回的pair类型可判断</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;    map&lt;int, string&gt; mapStudent;    pair&lt;map&lt;int, string&gt;::iterator, bool&gt; insert_pair;     insert_pair &#x3D; mapStudent.insert(pair&lt;int,string&gt;(1,&quot;student_one&quot;));    if(insert_pair.second &#x3D;&#x3D; true)&#123;        cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl;    &#125;    else&#123;        cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl;    &#125;         map&lt;int, string&gt;::iterator iter;     for(iter &#x3D; mapStudent.begin(); iter !&#x3D; mapStudent.end(); iter++)&#123;          cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;     &#125;     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、删除-1"><a href="#3、删除-1" class="headerlink" title="3、删除"></a>3、删除</h4><ul><li>erase(target)函数<br>当target为key时，返回删除的元素个数；<br>当target为迭代器时，删除的是target指向的value，返回void；     </li><li>erase(b,e)<br>表示删除迭代器b和e之间的元素</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;    map&lt;int, string&gt; mapStudent;mapStudent[1]&#x3D;&quot;student_one&quot;;mapStudent[2]&#x3D;&quot;student_two&quot;;mapStudent[3]&#x3D;&quot;student_three&quot;;mapStudent[4]&#x3D;&quot;student_four&quot;;    map&lt;int, string&gt;::iterator iter&#x3D;mapStudent.begin();    for(;iter!&#x3D;mapStudent.end();)&#123;    if((*iter).second&#x3D;&#x3D;&quot;student_one&quot;)&#123;        mapStudent.erase(iter++);    &#125;    else&#123;        ++iter;    &#125;&#125;    for(iter&#x3D;mapStudent.begin();iter!&#x3D;mapStudent.end();iter++)&#123;    cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、反向遍历"><a href="#4、反向遍历" class="headerlink" title="4、反向遍历"></a>4、反向遍历</h4><p>rbegin()、rend()函数</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;    map&lt;int,string&gt; mapStudent;    mapStudent[1] &#x3D;  &quot;student_one&quot;;     mapStudent[2] &#x3D;  &quot;student_two&quot;;     mapStudent[3] &#x3D;  &quot;student_three&quot;;     map&lt;int, string&gt;::reverse_iterator   iter;     for(iter &#x3D; mapStudent.rbegin(); iter !&#x3D; mapStudent.rend(); iter++)&#123;          cout&lt;&lt;iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;     &#125;     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-9、hastMap散列表的实现原理"><a href="#3-3-9、hastMap散列表的实现原理" class="headerlink" title="3.3.9、hastMap散列表的实现原理"></a>3.3.9、hastMap散列表的实现原理</h3><h4 id="1、发展背景"><a href="#1、发展背景" class="headerlink" title="1、发展背景"></a>1、发展背景</h4><p>最初的C++标准库之中并没有hashMap的实现，只是不同的实现者根据自己的需求提供了非标准的hashMap，由于这些实现不是遵循标准编写的，所以他们在功能和性能上表现不一。<br>从C++11开始，hashMap的实现被加入到标准库之中，为了防止与已开发的代码存在冲突，决定使用替代名称 unordered_map。这个名字其实更具描述性，因为它暗示了该类元素的无序性。</p><h4 id="2、hash"><a href="#2、hash" class="headerlink" title="2、hash"></a>2、hash</h4><p>hash 就是把任意长度的输入，通过hash函数变换成固定长度的输出（通常是整型），该输出就是哈希值。</p><p>这是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间。不同的输入可能会散列成相同的输出，因此不能从散列值来唯一地确定输入值。</p><h4 id="3、hash冲突"><a href="#3、hash冲突" class="headerlink" title="3、hash冲突"></a>3、hash冲突</h4><p>不同key关键字通过hash函数计算出相同的hashcode，该种现象称为hash冲突或hash碰撞。  </p><p><font color=red><strong>PS:<br>不论如何定义hash函数，当数据量达到一定范围时，必定会发生hash冲突，这是无法避免的，只能最大限度的减少hash冲突的情况</strong></font></p><h4 id="4、hash函数"><a href="#4、hash函数" class="headerlink" title="4、hash函数"></a>4、hash函数</h4><p>将key按照一定规则转换成hashcode的函数，hash函数为避免hash冲突需要遵循一定的规则：</p><ul><li>hash函数计算出来的hashcode能均匀分布在整个空间中（最大限度减少冲突）；</li></ul><h4 id="5、数据结构"><a href="#5、数据结构" class="headerlink" title="5、数据结构"></a>5、数据结构</h4><p>hashMap的数据结构采用的是<code>hashtable + bucket</code>，键-值对(key-value)存储于bucket之中，而bucket又存储于hashtable之中。   </p><ul><li>hashtable是一个数组，实际上就是动态数组vector；</li><li>bucket是一个链表；</li></ul><h4 id="6、hash策略"><a href="#6、hash策略" class="headerlink" title="6、hash策略"></a>6、hash策略</h4><p>hashMap采⽤bucket的形式存储key-value对，每⼀个key-value对组成的实体称作Entry。bucket实际上就是链表,Entry就是链表的组成节点。  </p><p><font color=purple>hashtable与bucket之间是如何映射的？<br>key与hashtable之间的映射关系？</font>   </p><p>hashMap对存放进来的key首先利用hash函数计算出hashcode，但是这个值很大，不可以直接作为hashtable下标，此时使用’按位’取余的方法生成下标：   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">key.hashcode % hashtable.length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于任意的一个key值，进行这样的操作以后，其值都落在 <code>0 - (hashtable.length - 1) </code>中，这里的’按位’取余的方法不同于直接取余操作’%’，因为直接取余操作’%’速度较慢，采用位运算的方式更加高效，具体的方法是：<br><code>将hashcode与hashtable的length - 1进行按位与操作</code>  </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">举个例子：hashtable的length为160001 0000    &#x2F;&#x2F; 16的二进制0000 1111    &#x2F;&#x2F; 15的二进制0000 1110    &#x2F;&#x2F; 14的二进制hashcode &#x3D; 01001011 01011001- hashcode与16按位与的结果始终是0,；- hashcode与14按位与，由于最后一位是0，按位与的结果最后一位也永远是0；类似以上两种情况，按位与取余的结果都不能使hashtable的数组空间得到充分利用，而目标值15就可以充分利用hashtable 0 - 15的空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>取余运算的结果即是其在hashtable之中的数组索引index，这也就解释了为何hashtable的vector数组长度以及扩容长度为<code>2的n次方</code></p><p>散列表将键-值对存储在桶中，每个桶都有索引，标识它在散列表中的相对位置，索引是使用散列函数根据键计算得到：<br>Index = HashFunc(key, tablesize);<br>如果HashFunc函数设计不佳，会出现索引重复，进而导致整体性能的下降。</p><h4 id="7、get-put过程"><a href="#7、get-put过程" class="headerlink" title="7、get\put过程"></a>7、get\put过程</h4><p>put过程：</p><ul><li>输入key；</li><li>通过 hash 函数得到 hashcode 值；</li><li>对hashcode取余获取其在hashtable内的位置索引index；</li><li>以key-value对作为entry存入bucket内（发生冲突，用比较函数解决）；</li></ul><p>get过程：</p><ul><li>输入 key</li><li>通过 hash 函数得到 hashcode 值；</li><li>对hashcode取余获取其在hashtable内的位置索引index；</li><li>比较桶的内部元素是否与 key 相等，若都不相等，则没有找到；</li><li>取出匹配的key-value对；</li></ul><h4 id="8、hashtable为何采用动态数组存储"><a href="#8、hashtable为何采用动态数组存储" class="headerlink" title="8、hashtable为何采用动态数组存储"></a>8、hashtable为何采用动态数组存储</h4><p>数组的访问与插入性能为O(1)，但其删除性能很差，那么hashtable为何会选择数组形式存储呢？<br>这里就需要正确理解hashtable之中的删除操作了，删除一个key-value对实际上是删除bucket的相应节点，而对于hashtable而言，并不会删除key对应的index位置，故不存在删除性能的问题。</p><h4 id="9、hash函数与比较函数的实现"><a href="#9、hash函数与比较函数的实现" class="headerlink" title="9、hash函数与比较函数的实现"></a>9、hash函数与比较函数的实现</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; *****示例一*****#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;struct Key&#123;std::string first;std::string second;&#x2F;&#x2F;hashstd::size_t operator()(const Key&amp; k) const&#123;return std::hash&lt;std::string&gt;()(k.first) ^(std::hash&lt;std::string&gt;()(k.second) &lt;&lt; 1);&#125;&#x2F;&#x2F;compaybool operator()(const Key&amp; lhs, const Key&amp; rhs) const&#123;return lhs.first &#x3D;&#x3D; rhs.first &amp;&amp; lhs.second &#x3D;&#x3D; rhs.second;&#125;&#125;;int main(void)&#123;std::unordered_map&lt;Key, std::string, Key, Key&gt; m6 &#x3D;&#123; &#123; &#123; &quot;John&quot;, &quot;Doe&quot; &#125;, &quot;example&quot; &#125;, &#123; &#123; &quot;Mary&quot;, &quot;Sue&quot; &#125;, &quot;another&quot; &#125; &#125;;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; *****示例二*****&#x2F;&#x2F; 类的总大小是32+32+4+4&#x3D;72字节，size_t是8字节，hash函数返回：每16字节的累计按位与值class SipCall_IP_Port&#123;public:char cSrcIP[32];char cDestIP[32];uint32_t nSrcPort;uint32_t nDestPort;size_t operator()(const SipCall_IP_Port&amp; s) const&#123;size_t hash &#x3D; 0;size_t *data &#x3D; (size_t*)&amp;s;for (size_t i &#x3D; 0; i &lt; 72 &#x2F; sizeof(size_t); ++i)hash ^&#x3D; data[i];return hash;&#125;bool operator()(const SipCall_IP_Port&amp; s1, const SipCall_IP_Port&amp; s2) const&#123;return memcmp(&amp;s1, &amp;s2, 72) &#x3D;&#x3D; 0;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-10、红黑树-Red-Black-Tree"><a href="#3-3-10、红黑树-Red-Black-Tree" class="headerlink" title="3.3.10、红黑树(Red-Black Tree)"></a>3.3.10、红黑树(Red-Black Tree)</h3><p><strong>定义</strong><br>R-B Tree全称是Red-Black Tree，又称为红黑树，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。    </p><p>红黑树的特性:</p><ul><li>1、每个节点或者是黑色，或者是红色</li><li>2、根节点是黑色</li><li>3、每个叶子节点（NIL）是黑色[注意：这里叶子节点是指为空(NIL或NULL)的叶子节点！]</li><li>4、如果一个节点是红色的，则它的子节点必须是黑色的</li><li>5、从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</li></ul><p><strong>注意</strong>：</p><ul><li>特性(3)中的叶子节点，是只为空(NIL或null)的节点</li><li>特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对接近平衡的二叉树</li></ul><p><strong>红黑树的应用</strong><br>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><p><strong>基本操作</strong><br>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而可能是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：<strong>左旋和右旋</strong>    </p><p><strong>1、左旋</strong><br><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/E46E373FB6044D2EB66A69A2B717E7BF/30950" alt="image"></p><p><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/C6831FBE58B34EB7B5F8F92FA837FD99/30960" alt="image"></p><p>对x进行左旋，意味着”将x变成一个左节点”<br>代码实现：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*  * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： *      px                              px *     &#x2F;                               &#x2F; *    x                               y                 *   &#x2F;  \      --(左旋)--&gt;           &#x2F; \                # *  lx   y                          x  ry      *     &#x2F;   \                       &#x2F;  \ *    ly   ry                     lx  ly   * * *&#x2F;template &lt;class T&gt;void RBTree&lt;T&gt;::leftRotate(RBTNode&lt;T&gt;* &amp;root, RBTNode&lt;T&gt;* x)&#123;    &#x2F;&#x2F; 设置x的右孩子为y    RBTNode&lt;T&gt; *y &#x3D; x-&gt;right;    &#x2F;&#x2F; 将 &quot;y的左孩子&quot; 设为 &quot;x的右孩子&quot;；    &#x2F;&#x2F; 如果y的左孩子非空，将 &quot;x&quot; 设为 &quot;y的左孩子的父亲&quot;    x-&gt;right &#x3D; y-&gt;left;    if (y-&gt;left !&#x3D; NULL)        y-&gt;left-&gt;parent &#x3D; x;    &#x2F;&#x2F; 将 &quot;x的父亲&quot; 设为 &quot;y的父亲&quot;    y-&gt;parent &#x3D; x-&gt;parent;    if (x-&gt;parent &#x3D;&#x3D; NULL)    &#123;        root &#x3D; y;            &#x2F;&#x2F; 如果 &quot;x的父亲&quot; 是空节点，则将y设为根节点    &#125;    else    &#123;        if (x-&gt;parent-&gt;left &#x3D;&#x3D; x)            x-&gt;parent-&gt;left &#x3D; y;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为&quot;x的父节点的左孩子&quot;        else            x-&gt;parent-&gt;right &#x3D; y;    &#x2F;&#x2F; 如果 x是它父节点的左孩子，则将y设为&quot;x的父节点的左孩子&quot;    &#125;        &#x2F;&#x2F; 将 &quot;x&quot; 设为 &quot;y的左孩子&quot;    y-&gt;left &#x3D; x;    &#x2F;&#x2F; 将 &quot;x的父节点&quot; 设为 &quot;y&quot;    x-&gt;parent &#x3D; y;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、右旋</strong></p><p><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/B097D20CA2144A61B456853240FFE9D0/30966" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/5cff5b733a84273e809bd757ecb6e02b/xmlnote/13E85D1483C14E4EA943CE986E777E53/30968" alt="image">  </p><p>对y进行右旋，意味着将y变成右节点<br>代码实现：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;*  * 对红黑树的节点(y)进行右旋转 * * 右旋示意图(对节点y进行左旋)： *            py                               py *           &#x2F;                                &#x2F; *          y                                x                   *         &#x2F;  \      --(右旋)--&gt;            &#x2F;  \                     # *        x   ry                           lx   y   *       &#x2F; \                                   &#x2F; \                   # *      lx  rx                                rx  ry *  *&#x2F;template &lt;class T&gt;void RBTree&lt;T&gt;::rightRotate(RBTNode&lt;T&gt;* &amp;root, RBTNode&lt;T&gt;* y)&#123;    &#x2F;&#x2F; 设置x是当前节点的左孩子。    RBTNode&lt;T&gt; *x &#x3D; y-&gt;left;    &#x2F;&#x2F; 将 &quot;x的右孩子&quot; 设为 &quot;y的左孩子&quot;；    &#x2F;&#x2F; 如果&quot;x的右孩子&quot;不为空的话，将 &quot;y&quot; 设为 &quot;x的右孩子的父亲&quot;    y-&gt;left &#x3D; x-&gt;right;    if (x-&gt;right !&#x3D; NULL)        x-&gt;right-&gt;parent &#x3D; y;    &#x2F;&#x2F; 将 &quot;y的父亲&quot; 设为 &quot;x的父亲&quot;    x-&gt;parent &#x3D; y-&gt;parent;    if (y-&gt;parent &#x3D;&#x3D; NULL)     &#123;        root &#x3D; x;            &#x2F;&#x2F; 如果 &quot;y的父亲&quot; 是空节点，则将x设为根节点    &#125;    else    &#123;        if (y &#x3D;&#x3D; y-&gt;parent-&gt;right)            y-&gt;parent-&gt;right &#x3D; x;    &#x2F;&#x2F; 如果 y是它父节点的右孩子，则将x设为&quot;y的父节点的右孩子&quot;        else            y-&gt;parent-&gt;left &#x3D; x;    &#x2F;&#x2F; (y是它父节点的左孩子) 将x设为&quot;x的父节点的左孩子&quot;    &#125;    &#x2F;&#x2F; 将 &quot;y&quot; 设为 &quot;x的右孩子&quot;    x-&gt;right &#x3D; y;    &#x2F;&#x2F; 将 &quot;y的父节点&quot; 设为 &quot;x&quot;    y-&gt;parent &#x3D; x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>红黑树的代码实现</strong>详见网址：<a href="https://www.cnblogs.com/skywang12345/p/3624291.html">https://www.cnblogs.com/skywang12345/p/3624291.html</a> </p><h3 id="3-3-11、std-map与std-unordered-map的比较"><a href="#3-3-11、std-map与std-unordered-map的比较" class="headerlink" title="3.3.11、std::map与std::unordered_map的比较"></a>3.3.11、std::map与std::unordered_map的比较</h3><p>std::map的内部结构是红黑树，std::unordered_map内部结构是hashtable + 链表</p><h4 id="1、插入-删除性能"><a href="#1、插入-删除性能" class="headerlink" title="1、插入\删除性能"></a>1、插入\删除性能</h4><p>红黑树的插入、删除、查找性能都是O(logN)，而hash表的插入、删除查找性能理论上是O(1)，在这个对比上来看，红黑树性能远没有hash表优秀。但是值得一提的是红黑树是相对稳定的数据结构，最差情况下也是高效的，而相对于hash表数据结构而言，它的插入、删除操作理论上时间复杂度是常数时间，但前提是不发生数据碰撞。在发生碰撞时，最坏的情况是插入、删除时间复杂度高达O(n)。<br>对于实际应用，当然一个相对稳定且快速的数据结构是比较理想的选择</p><h4 id="2、结构特性"><a href="#2、结构特性" class="headerlink" title="2、结构特性"></a>2、结构特性</h4><p>红黑树是基于平衡二叉树的结构，插入、删除操作很方便，并且它是一种自动有序的数据结构，插入、删除节点会进行自旋，可以保证在3次旋转之内使当前红黑树节点重新有序。</p><h3 id="3-3-12、栈与队列"><a href="#3-3-12、栈与队列" class="headerlink" title="3.3.12、栈与队列"></a>3.3.12、栈与队列</h3><ul><li>栈-stack：先入后出，只允许在栈顶添加和删除元素，称为出栈和入栈；</li><li>队列-queue：先入先出，在队首取元素，在队尾添加元素，称为出队和入队；</li></ul><p><img src="http://note.youdao.com/yws/public/resource/20a67e1bc7bb981e1990a97c7d7c3225/xmlnote/WEBRESOURCE7ce84b15d37bf5272d57551d7cbb9eb5/41260" alt="image01"></p><ul><li>常见栈的应用场景包括函数调用、递归实现、深度优先遍历 DFS 等；</li><li>常见的队列的应用场景包括消息缓冲队列的管理、广度优先遍历 BFS 等。<br>翻一下源码，就知道 stack 和 queue 的底层其实就是使用 deque，用 deque 为底层容器封装。</li></ul><h4 id="1、栈的top函数"><a href="#1、栈的top函数" class="headerlink" title="1、栈的top函数"></a>1、栈的top函数</h4><p>由于top函数返回的是栈顶元素的引用，所以当栈为空时，top返回的引用为空，如果返回用于表达式，则会报错<code>Segmentation fault</code>，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stack&gt;int main()&#123;    std::stack&lt;int32_t&gt; st;    if (st.top() &#x3D;&#x3D; 1) &#123;        std::cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; std::endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-13、-STL相关文章收录"><a href="#3-3-13、-STL相关文章收录" class="headerlink" title="3.3.13、 STL相关文章收录"></a>3.3.13、 STL相关文章收录</h3><ul><li><a href="https://mp.weixin.qq.com/s/zU9YuKWtGyXjBqBp5ihaNA">2万字 + 20张图带你手撕STL容器源码</a></li></ul><h2 id="3-4、STL常见算法"><a href="#3-4、STL常见算法" class="headerlink" title="3.4、STL常见算法"></a>3.4、STL常见算法</h2><h3 id="3-4-1、分类"><a href="#3-4-1、分类" class="headerlink" title="3.4.1、分类"></a>3.4.1、分类</h3><p>两大类：变序算法、非变序算法</p><h4 id="1、非变序算法"><a href="#1、非变序算法" class="headerlink" title="1、非变序算法"></a>1、非变序算法</h4><p>不改变容器中元素的顺序和内容</p><ul><li>统计计数<ul><li>count：指定范围内查找与目标值匹配的所有元素个数；</li><li>count_if：指定范围内查找满足条件的所有元素个数；</li></ul></li><li>查找算法<ul><li>search：指定范围内查找目标值或满足二元谓词算法的第一个元素，目标值也可以是个序列；</li><li>search_n：指定范围内查找目标值或满足二元谓词算法的前N个元素，目标值也可以是个序列；</li><li>find：指定范围内查找目标值的第一个元素；</li><li>find_if：指定范围内查找满足指定条件的第一个元素；</li><li>find_end：指定范围内查找满足指定条件的最后一个元素；</li></ul></li></ul><h4 id="2、变序算法"><a href="#2、变序算法" class="headerlink" title="2、变序算法"></a>2、变序算法</h4><p>可能会改变容器中元素的顺序或内容</p><ul><li>初始化算法<ul><li>fill：将指定值分配给指定范围中的每一个元素；</li><li>fill_n：将指定值分配给指定范围中的前n个元素；</li><li>generate：类似fill；</li><li>generate_n：类似fill_n；</li></ul></li><li>复制算法<ul><li>copy：将指定范围复制到目标范围；</li><li>copy_backward：将指定范围复制到目标范围，在目标范围内将顺序反转；</li></ul></li><li>删除算法<br>与erase函数的不同之处详见<strong>3.4.7</strong>节<ul><li>remove：删除所有目标值；</li><li>remove_if：删除满足一元谓词算法的所有目标值；</li><li>remove_copy：将源范围中除目标值外的所有元素复制到目标范围；</li><li>remove_copy_if：将源范围中除满足指定一元谓词算法外的所有元素复制到目标范围；</li><li>unique：比较指定范围内的相邻元素，并删除重复元素。该算法还有一个重载版本，使用二元谓词算法来判断需要删除的目标值 [ 需要结合erase最终删除 ]；</li><li>unique_copy：将源范围的所有元素复制到目标范围，但相邻的重复元素除外素[需要结合erase最终删除]；</li></ul></li><li>替换算法<ul><li>replace：用一个值替换指定范围中与目标值匹配的所有元素；</li><li>replace_if：用一个值替换指定范围中满足指定条件的所有元素；</li></ul></li><li>排序算法<ul><li>sort：使用指定的排序标准对指定范围的元素进行排序。排序标准由二元谓词决定，但可能改变相等元素的相对位置；</li><li>stable_sort：与sort功能类似，但不会改变相等元素的相对位置</li><li>partial_sort：将源范围内指定数量的元素进行排序；</li><li>partial_sort_copy：将源范围内的元素复制到目标范围，同时对它们进行排序；</li></ul></li><li>分区算法<ul><li>partition：在指定范围内，将元素分为两组：满足指定一元谓词的元素放在第一个组中，其他元素放在第二个组中。不一定会保持集合中元素的相对位置；</li><li>stable_partition：功能与partition类似，但会保持集合中元素的相对位置；</li></ul></li><li>适用于有序容器的算法<ul><li>binary_search：有序容器中查找目标值；</li><li>lower_bound：根据元素的值或二元谓词判断可能插入到排序集合中的第一个位置，并返回该位置的迭代器；</li><li>upper_bound：根据元素的值或二元谓词判断可能插入到排序集合中的最后一个位置，并返回该位置的迭代器；</li></ul></li></ul><h3 id="3-4-2、find、find-if查找"><a href="#3-4-2、find、find-if查找" class="headerlink" title="3.4.2、find、find_if查找"></a>3.4.2、find、find_if查找</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;int main()&#123;   using namespace std;   vector&lt;int&gt; vecIntegers;   &#x2F;&#x2F; Inserting sample values -9 to 9   for (int SampleValue &#x3D; -9; SampleValue &lt; 10; ++ SampleValue)       vecIntegers.push_back (SampleValue);   cout &lt;&lt; &quot;Enter number to find in collection: &quot;;   int NumToFind &#x3D; 0;   cin &gt;&gt; NumToFind;   auto iElementFound &#x3D; find ( vecIntegers.cbegin () &#x2F;&#x2F; Start of range                             , vecIntegers.cend ()   &#x2F;&#x2F; End of range                             , NumToFind );          &#x2F;&#x2F; Element to find   &#x2F;&#x2F; Check if find succeeded   if ( iElementFound !&#x3D; vecIntegers.cend ())      cout &lt;&lt; &quot;Result: Value &quot; &lt;&lt; *iElementFound &lt;&lt; &quot; found!&quot; &lt;&lt; endl;   else      cout &lt;&lt; &quot;Result: No element contains value &quot; &lt;&lt; NumToFind &lt;&lt; endl;   cout &lt;&lt; &quot;Finding the first even number using find_if: &quot; &lt;&lt; endl;   auto iEvenNumber &#x3D; find_if ( vecIntegers.cbegin () &#x2F;&#x2F; Start of range                              , vecIntegers.cend ()  &#x2F;&#x2F; End of range                 , [](int element) &#123; return (element % 2) &#x3D;&#x3D; 0; &#125; );   if (iEvenNumber !&#x3D; vecIntegers.cend ())   &#123;      cout &lt;&lt; &quot;Number &#39;&quot; &lt;&lt; *iEvenNumber &lt;&lt; &quot;&#39; found at position [&quot;;      cout &lt;&lt; distance (vecIntegers.cbegin (), iEvenNumber);      cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3、search、search-n查找"><a href="#3-4-3、search、search-n查找" class="headerlink" title="3.4.3、search、search_n查找"></a>3.4.3、search、search_n查找</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents (const T&amp; Input)&#123;   for(auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin and cend: c++11      ; iElement !&#x3D; Input.cend()     ; ++ iElement )     cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;   cout &lt;&lt; endl;&#125;int main ()&#123;   &#x2F;&#x2F; A sample container - vector of integers - containing -9 to 9   vector &lt;int&gt; vecIntegers;   for (int nNum &#x3D; -9; nNum &lt; 10; ++ nNum)      vecIntegers.push_back (nNum);   &#x2F;&#x2F; Insert some more sample values into the vector   vecIntegers.push_back (9);   vecIntegers.push_back (9);   &#x2F;&#x2F; Another sample container - a list of integers from -4 to 4   list &lt;int&gt; listIntegers;   for (int nNum &#x3D; -4; nNum &lt; 5; ++ nNum)      listIntegers.push_back (nNum);   cout &lt;&lt; &quot;The contents of the sample vector are: &quot; &lt;&lt; endl;   DisplayContents (vecIntegers);   cout &lt;&lt; &quot;The contents of the sample list are: &quot; &lt;&lt; endl;   DisplayContents (listIntegers);   cout &lt;&lt; &quot;search() for the contents of list in vector:&quot; &lt;&lt; endl;   auto iRange &#x3D; search ( vecIntegers.begin () &#x2F;&#x2F; Start of range              , vecIntegers.end ()     &#x2F;&#x2F; End of range to search in              , listIntegers.begin ()  &#x2F;&#x2F; Start of range to search for              , listIntegers.end () ); &#x2F;&#x2F; End of range to search for   &#x2F;&#x2F; Check if search found a match   if (iRange !&#x3D; vecIntegers.end ())   &#123;      cout &lt;&lt; &quot;Sequence in list found in vector at position: &quot;;      cout &lt;&lt; distance (vecIntegers.begin (), iRange) &lt;&lt; endl;   &#125;   cout &lt;&lt; &quot;Searching &#123;9, 9, 9&#125; in vector using search_n(): &quot; &lt;&lt; endl;   auto iPartialRange &#x3D; search_n ( vecIntegers.begin () &#x2F;&#x2F; Start range                     , vecIntegers.end ()   &#x2F;&#x2F; End range                     , 3      &#x2F;&#x2F; Count of item to be searched for                     , 9 );   &#x2F;&#x2F; Item to search for   if (iPartialRange !&#x3D; vecIntegers.end ())   &#123;      cout &lt;&lt; &quot;Sequence &#123;9, 9, 9&#125; found in vector at position: &quot;;      cout &lt;&lt; distance (vecIntegers.begin (), iPartialRange) &lt;&lt; endl;   &#125;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4、count、count-if统计计数"><a href="#3-4-4、count、count-if统计计数" class="headerlink" title="3.4.4、count、count_if统计计数"></a>3.4.4、count、count_if统计计数</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;&#x2F;&#x2F; A unary predicate for the *_if functionstemplate &lt;typename elementType&gt;bool IsEven (const elementType&amp; number)&#123;   return ((number % 2) &#x3D;&#x3D; 0); &#x2F;&#x2F; true, if even&#125;int main ()&#123;   using namespace std;   vector &lt;int&gt; vecIntegers;   cout &lt;&lt; &quot;Populating a vector&lt;int&gt; with values from -9 to 9&quot; &lt;&lt; endl;   for (int nNum &#x3D; -9; nNum &lt; 10; ++ nNum)       vecIntegers.push_back (nNum);   &#x2F;&#x2F; Use count to determine the number of &#39;0&#39;s in the vector   size_t nNumZeroes &#x3D; count (vecIntegers.begin (),vecIntegers.end (),0);   cout &lt;&lt; &quot;Number of instances of &#39;0&#39;: &quot; &lt;&lt; nNumZeroes &lt;&lt; endl &lt;&lt; endl;   &#x2F;&#x2F; Use the count_if algorithm with the unary predicate IsEven:   size_t nNumEvenElements &#x3D; count_if (vecIntegers.begin (),       vecIntegers.end (), IsEven &lt;int&gt; );   cout &lt;&lt; &quot;Number of even elements: &quot; &lt;&lt; nNumEvenElements &lt;&lt; endl;   cout &lt;&lt; &quot;Number of odd elements: &quot;;   cout &lt;&lt; vecIntegers.size () - nNumEvenElements &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-5、fill、fill-n以目标值进行初始化"><a href="#3-4-5、fill、fill-n以目标值进行初始化" class="headerlink" title="3.4.5、fill、fill_n以目标值进行初始化"></a>3.4.5、fill、fill_n以目标值进行初始化</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;int main ()&#123;   using namespace std;   &#x2F;&#x2F; Initialize a sample vector with 3 elements   vector &lt;int&gt; vecIntegers (3);   &#x2F;&#x2F; fill all elements in the container with value 9   fill (vecIntegers.begin (), vecIntegers.end (), 9);   &#x2F;&#x2F; Increase the size of the vector to hold 6 elements   vecIntegers.resize (6);   &#x2F;&#x2F; Fill the three elements starting at offset position 3 with value -9   fill_n (vecIntegers.begin () + 3, 3, -9);   cout &lt;&lt; &quot;Contents of the vector are: &quot; &lt;&lt; endl;   for (size_t nIndex &#x3D; 0; nIndex &lt; vecIntegers.size (); ++ nIndex)   &#123;      cout &lt;&lt; &quot;Element [&quot; &lt;&lt; nIndex &lt;&lt; &quot;] &#x3D; &quot;;      cout &lt;&lt; vecIntegers [nIndex] &lt;&lt; endl;    &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-6、copy、copy-if、copy-backward复制及安全复制"><a href="#3-4-6、copy、copy-if、copy-backward复制及安全复制" class="headerlink" title="3.4.6、copy、copy_if、copy_backward复制及安全复制"></a>3.4.6、copy、copy_if、copy_backward复制及安全复制</h3><p>copy、copy_if、copy_backward：返回值为目标容器的目标范围内最后一个元素位置之后的迭代器；<br><strong>此处需要特别注意</strong>：<br>目标容器的size必须要足够容纳被复制的元素数量，不足时会报错，需要resize，不仅仅是capacity</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents(const T&amp; Input)&#123;   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11         ; ++ iElement)       cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;&#125;int main ()&#123;   list &lt;int&gt; listIntegers;   for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)      listIntegers.push_back (nCount);   cout &lt;&lt; &quot;Source (list) contains:&quot; &lt;&lt; endl;   DisplayContents(listIntegers);   &#x2F;&#x2F; Initialize the vector to hold twice as many elements as the list   vector &lt;int&gt; vecIntegers (listIntegers.size () * 2);   auto iLastPos &#x3D; copy ( listIntegers.begin ()  &#x2F;&#x2F; start source range                        , listIntegers.end ()     &#x2F;&#x2F; end source range                        , vecIntegers.begin () );&#x2F;&#x2F; start dest range   &#x2F;&#x2F; copy odd numbers from list into vector   copy_if ( listIntegers.begin(), listIntegers.end()           , iLastPos            , [](int element)&#123;return ((element % 2) &#x3D;&#x3D; 1);&#125;);   cout &lt;&lt; &quot;Destination (vector) after copy and copy_if:&quot; &lt;&lt; endl;   DisplayContents(vecIntegers);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器中”对元素进行复制行为”的泛型算法，例如：copy、unique_copy等，都要确保目的容器的size足够大，否则会出现复制报错error，STL提供了三个现有的函数。    </p><p>以下三个函数需要包含头文件：#include <iterator>      </p><ul><li>back_inserter会以容器的push_back函数取代assigment运算符，传入back_inserter的参数就是目的容器本身。assigment运算符=vector的数组访问方式或at访问方式；</li></ul><pre class="line-numbers language-none"><code class="language-none">vect&lt;int&gt; dest_vec;unique_copy (ivec.begin(), ivec.end(), back_inserter(dest_vec));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>inserter函数会以容器的insert函数取代assignment运算符，inserter函数接受两个参数，一个是容器，另一个是iterator，指向容器内的插入操作起点；</li></ul><pre class="line-numbers language-none"><code class="language-none">vect&lt;int&gt; dest_vec;unique_copy (ivec.begin(), ivec.end(), inserter(dest_vec, dest_vec.begin()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>front_inserter会以容器的push_front函数取代assigment运算符，不过它只适用于list、deque；</li></ul><pre class="line-numbers language-none"><code class="language-none">list&lt;int&gt; dest_vec;unique_copy (ilist.begin(), ilist.end(), inserter(dest_list));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-4-7、remove、remove-if删除"><a href="#3-4-7、remove、remove-if删除" class="headerlink" title="3.4.7、remove、remove_if删除"></a>3.4.7、remove、remove_if删除</h3><p>remove、remove_if：返回一个指向容器最后一个元素(已初始化内存位置)位置之后的迭代器<br><strong>注意</strong>：<br>此时容器一直未调整size大小，size()返回值并未变化，删除动作会引起其他元素向前移动，但并未删除该元素的占位（虽然内存占位还在，但已被反向初始化，不能进行直接访问），此时需要调用erase删除该迭代器至容器尾部的无效元素，才能真正释放其内存占用</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents(const T&amp; Input)&#123;   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11         ; ++ iElement)       cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;&#125;int main ()&#123;   list &lt;int&gt; listIntegers;   for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)      listIntegers.push_back (nCount);   cout &lt;&lt; &quot;Source (list) contains:&quot; &lt;&lt; endl;   DisplayContents(listIntegers);   &#x2F;&#x2F; Initialize the vector to hold twice as many elements as the list   vector &lt;int&gt; vecIntegers (listIntegers.size () * 2);   &#x2F;&#x2F; Remove all instances of &#39;0&#39;, resize vector using erase()   auto iNewEnd &#x3D; remove (vecIntegers.begin (), vecIntegers.end (), 0);   vecIntegers.erase (iNewEnd, vecIntegers.end ());  &#x2F;&#x2F;remove   &#x2F;&#x2F; Remove all odd numbers from the vector using remove_if   iNewEnd &#x3D; remove_if (vecIntegers.begin (), vecIntegers.end (),              [](int element) &#123;return ((element % 2) &#x3D;&#x3D; 1);&#125; ); &#x2F;&#x2F;predicate   vecIntegers.erase (iNewEnd , vecIntegers.end ());  &#x2F;&#x2F; resizing   cout &lt;&lt; &quot;Destination (vector) after remove, remove_if, erase:&quot; &lt;&lt; endl;   DisplayContents(vecIntegers);      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-8、replace、replace-if替换"><a href="#3-4-8、replace、replace-if替换" class="headerlink" title="3.4.8、replace、replace_if替换"></a>3.4.8、replace、replace_if替换</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;void DisplayContents(const T&amp; Input)&#123;   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11         ; ++ iElement)       cout &lt;&lt; *iElement &lt;&lt; &#39; &#39;;   cout &lt;&lt; &quot;| Number of elements: &quot; &lt;&lt; Input.size() &lt;&lt; endl;&#125;int main ()&#123;   vector &lt;int&gt; vecIntegers (6);   &#x2F;&#x2F; fill first 3 elements with value 8, last 3 with 5   fill (vecIntegers.begin (), vecIntegers.begin () + 3, 8);   fill_n (vecIntegers.begin () + 3, 3, 5);   &#x2F;&#x2F; shuffle the container   random_shuffle (vecIntegers.begin (), vecIntegers.end ());      cout &lt;&lt; &quot;The initial contents of the vector are: &quot; &lt;&lt; endl;   DisplayContents(vecIntegers);   cout &lt;&lt; endl &lt;&lt; &quot;Using &#39;std::replace&#39; to replace value 5 by 8&quot; &lt;&lt; endl;   replace (vecIntegers.begin (), vecIntegers.end (), 5, 8);   cout &lt;&lt; &quot;Using &#39;std::replace_if&#39; to replace even values by -1&quot; &lt;&lt; endl;   replace_if (vecIntegers.begin (), vecIntegers.end ()   , [](int element) &#123;return ((element % 2) &#x3D;&#x3D; 0); &#125;, -1);   cout &lt;&lt; endl &lt;&lt; &quot;Contents of the vector after replacements:&quot; &lt;&lt; endl;   DisplayContents(vecIntegers);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-9、unique去除重复元素"><a href="#3-4-9、unique去除重复元素" class="headerlink" title="3.4.9、unique去除重复元素"></a>3.4.9、unique去除重复元素</h3><p>unique函数只去除相邻的重复值，所以对于非排序容器，最好先使用sort进行排序，然后再unique去除重复值，返回值是一个指向容器最后一个元素(已初始化的内存位置)位置之后的迭代器；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents(const T&amp; Input)&#123;   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11         ; ++ iElement)       cout &lt;&lt; *iElement &lt;&lt; endl;&#125;int main ()&#123;   vector&lt;string&gt; vecNames;   vecNames.push_back (&quot;John Doe&quot;);   vecNames.push_back (&quot;Jack Nicholson&quot;);   vecNames.push_back (&quot;Sean Penn&quot;);   vecNames.push_back (&quot;Anna Hoover&quot;);   &#x2F;&#x2F; insert a duplicate into the vector   vecNames.push_back (&quot;Jack Nicholson&quot;);   cout &lt;&lt; &quot;The initial contents of the vector are:&quot; &lt;&lt; endl;   DisplayContents(vecNames);   cout &lt;&lt; &quot;The sorted vector contains names in the order:&quot; &lt;&lt; endl;   sort (vecNames.begin (), vecNames.end ());   DisplayContents(vecNames);   &#x2F;&#x2F; Erase adjacent duplicates   auto iNewEnd &#x3D; unique (vecNames.begin (), vecNames.end ());   vecNames.erase (iNewEnd, vecNames.end ());   cout &lt;&lt; &quot;The contents of the vector after using &#39;unique&#39;:&quot; &lt;&lt; endl;   DisplayContents(vecNames);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-10、binary-search有序容器查找"><a href="#3-4-10、binary-search有序容器查找" class="headerlink" title="3.4.10、binary_search有序容器查找"></a>3.4.10、binary_search有序容器查找</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;void DisplayContents(const T&amp; Input)&#123;   for ( auto iElement &#x3D; Input.cbegin() &#x2F;&#x2F; auto, cbegin: c++11        ; iElement !&#x3D; Input.cend()  &#x2F;&#x2F; cend() is new in C++11         ; ++ iElement)       cout &lt;&lt; *iElement &lt;&lt; endl;&#125;int main ()&#123;   vector&lt;string&gt; vecNames;   vecNames.push_back (&quot;John Doe&quot;);   vecNames.push_back (&quot;Jack Nicholson&quot;);   vecNames.push_back (&quot;Sean Penn&quot;);   vecNames.push_back (&quot;Anna Hoover&quot;);   &#x2F;&#x2F; insert a duplicate into the vector   vecNames.push_back (&quot;Jack Nicholson&quot;);   cout &lt;&lt; &quot;The initial contents of the vector are:&quot; &lt;&lt; endl;   DisplayContents(vecNames);   cout &lt;&lt; &quot;The sorted vector contains names in the order:&quot; &lt;&lt; endl;   sort (vecNames.begin (), vecNames.end ());   DisplayContents(vecNames);   cout &lt;&lt; &quot;Searching for \&quot;John Doe\&quot; using &#39;binary_search&#39;:&quot; &lt;&lt; endl;   bool bElementFound &#x3D; binary_search (vecNames.begin (), vecNames.end (),                                       &quot;John Doe&quot;);   if (bElementFound)      cout &lt;&lt; &quot;Result: \&quot;John Doe\&quot; was found in the vector!&quot; &lt;&lt; endl;   else      cout &lt;&lt; &quot;Element not found &quot; &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-11、all-of、any-of、none-of范围真假遍历"><a href="#3-4-11、all-of、any-of、none-of范围真假遍历" class="headerlink" title="3.4.11、all_of、any_of、none_of范围真假遍历"></a>3.4.11、all_of、any_of、none_of范围真假遍历</h3><pre class="line-numbers language-none"><code class="language-none">template&lt; class InputIt, class UnaryPredicate &gt;bool all_of( InputIt first, InputIt last, UnaryPredicate p );template&lt; class InputIt, class UnaryPredicate &gt;bool any_of( InputIt first, InputIt last, UnaryPredicate p );template&lt; class InputIt, class UnaryPredicate &gt;bool none_of( InputIt first, InputIt last, UnaryPredicate p );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>all_of检查区间[first，last)中是否所有元素都满足一元判断式，满足返回true；<br>any_of检查区间[first，last)，只要有一个元素满足一元判断式，满足返回true；<br>none_of检查区间[first，last)中是否所有元素都不满足一元判断式，返回true；<br>示例：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;vector&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;iostream&gt;#include &lt;functional&gt;int main()&#123;    std::vector&lt;int&gt; v(10, 2);    std::partial_sum(v.cbegin(), v.cend(), v.begin());    std::cout &lt;&lt; &quot;Among the numbers: &quot;;    std::copy(v.cbegin(), v.cend(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));    std::cout &lt;&lt; &#39;\n&#39;;    if (std::all_of(v.cbegin(), v.cend(), [](int i)&#123; return i % 2 &#x3D;&#x3D; 0; &#125;)) &#123;        std::cout &lt;&lt; &quot;All numbers are even\n&quot;;    &#125;    if (std::none_of(v.cbegin(), v.cend(), std::bind(std::modulus&lt;int&gt;(),                                                      std::placeholders::_1, 2))) &#123;        std::cout &lt;&lt; &quot;None of them are odd\n&quot;;    &#125;    struct DivisibleBy    &#123;        const int d;        DivisibleBy(int n) : d(n) &#123;&#125;        bool operator()(int n) const &#123; return n % d &#x3D;&#x3D; 0; &#125;    &#125;;    if (std::any_of(v.cbegin(), v.cend(), DivisibleBy(7))) &#123;        std::cout &lt;&lt; &quot;At least one number is divisible by 7\n&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Among the numbers: 2 4 6 8 10 12 14 16 18 20 All numbers are evenNone of them are oddAt least one number is divisible by 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-12、std-iota生成有序整形序列"><a href="#3-4-12、std-iota生成有序整形序列" class="headerlink" title="3.4.12、std::iota生成有序整形序列"></a>3.4.12、std::iota生成有序整形序列</h3><pre class="line-numbers language-none"><code class="language-none">#include&lt;numeric&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt;  v(4);        std::iota(v.begin(), v.end(), 1);    for_each(v.begin(), v.end(), [](int c)&#123;cout&lt;&lt;c&lt;&lt;endl;&#125;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-13、max-element、min-element、minmax-element获取最大、最小值"><a href="#3-4-13、max-element、min-element、minmax-element获取最大、最小值" class="headerlink" title="3.4.13、max_element、min_element、minmax_element获取最大、最小值"></a>3.4.13、max_element、min_element、minmax_element获取最大、最小值</h3><pre class="line-numbers language-none"><code class="language-none">template&lt; class ForwardIt &gt; ForwardIt max_element( ForwardIt first, ForwardIt last );template&lt; class ForwardIt &gt; std::pair&lt;ForwardIt,ForwardIt&gt; minmax_element( ForwardIt first, ForwardIt last );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;static bool abs_compare(int a, int b)&#123;    return (std::abs(a) &lt; std::abs(b));&#125;int main()&#123;    std::vector&lt;int&gt; v&#123; 3, 1, -14, 1, 5, 9 &#125;;     std::vector&lt;int&gt;::iterator result;    result &#x3D; std::max_element(v.begin(), v.end());    std::cout &lt;&lt; &quot;max element at: &quot; &lt;&lt; std::distance(v.begin(), result) &lt;&lt; &#39;\n&#39;;    result &#x3D; std::max_element(v.begin(), v.end(), abs_compare);    std::cout &lt;&lt; &quot;max element (absolute) at: &quot; &lt;&lt; std::distance(v.begin(), result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">max element at: 5max element (absolute) at: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;int main()&#123;    std::vector&lt;int&gt; v &#x3D; &#123; 3, 9, 1, 4, 2, 5, 9 &#125;;    auto result &#x3D; std::minmax_element(v.begin(), v.end());    std::cout &lt;&lt; &quot;min element at: &quot; &lt;&lt; (result.first - v.begin()) &lt;&lt; &#39;\n&#39;;    std::cout &lt;&lt; &quot;max element at: &quot; &lt;&lt; (result.second - v.begin()) &lt;&lt; &#39;\n&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">min element at: 2max element at: 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-4-14、is-sorted、is-sorted-until判断容器是否有序"><a href="#3-4-14、is-sorted、is-sorted-until判断容器是否有序" class="headerlink" title="3.4.14、is_sorted、is_sorted_until判断容器是否有序"></a>3.4.14、is_sorted、is_sorted_until判断容器是否有序</h3><p>is_sorted判断某个序列是否有序<br>is_sorted_until返回前面已经排序好的序列</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vectot&lt;int&gt; v &#x3D; &#123;1,2,5,7,9,4&#125;;    auto pos &#x3D; is_sorted_until(v.begin(), v.end());        for(auto it &#x3D; v.begin(); it!&#x3D;pos;++it )    cout&lt;&lt;*it&lt;&lt;endl;        bool is_sort &#x3D; is_sorted(v.begin(), v.end());    cout&lt;&lt;is_sort&lt;&lt;endl;    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-15、for、for-each容器遍历"><a href="#3-4-15、for、for-each容器遍历" class="headerlink" title="3.4.15、for、for_each容器遍历"></a>3.4.15、for、for_each容器遍历</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vectot&lt;int&gt; vct01 &#x3D; &#123;1,2,5,7,9,4&#125;;    &#x2F;&#x2F; 常规遍历    for (const auto&amp; iter &#x3D; vct01.cbegin(); iter !&#x3D; vct01.cend(); ++iter) &#123;        std::cout &lt;&lt; *iter &lt;&lt; &quot;, &quot;;    &#125;        &#x2F;&#x2F; 简单遍历    &#x2F;*    n表示v中的一个元素，类型为int，冒号之后是需要遍历的目标容器;       n是只读的，如果需要在遍历的时候做修改，可以使用引用auto&amp;n；    可以用continue语句来跳过循环的本次迭代，用break语句来跳出整个循环；    *&#x2F;    for(auto n:vct01)    &#123;        cout&lt;&lt;n&lt;&lt;endl;    &#125;        &#x2F;&#x2F; for_each遍历    for_each(vct01.cbegin(), vct01.cend(), []());    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-16、STL的sort排序函数"><a href="#3-4-16、STL的sort排序函数" class="headerlink" title="3.4.16、STL的sort排序函数"></a>3.4.16、STL的sort排序函数</h3><p>参考:<a href="https://www.cnblogs.com/fengcc/p/5256337.html">STL sort 函数实现详解</a><br>函数原型：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;algorithm&gt; template&lt; class RandomIt &gt;void sort( RandomIt first, RandomIt last ); template&lt; class RandomIt, class Compare &gt;void sort( RandomIt first, RandomIt last, Compare comp );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class _RandomAccessIter&gt;inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) &#123;  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);  __STL_REQUIRES(typename iterator_traits&lt;_RandomAccessIter&gt;::value_type,                 _LessThanComparable);  if (__first !&#x3D; __last) &#123;    __introsort_loop(__first, __last,                     __VALUE_TYPE(__first),                     __lg(__last - __first) * 2);    __final_insertion_sort(__first, __last);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>有两个重载版本，一是两个参数的默认升序版本，二是三个参数的带自定义比较函数的版本；</li><li>前两个参数均是表示范围的迭代器，且只支持进行随机访问的容器的迭代器，如vector、string、dequeue、基础类型的数组；</li></ul><p><code>STL</code>提供的比较函数：</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>less</td><td>小于，升序</td></tr><tr><td>greater</td><td>大于，降序</td></tr><tr><td>equal_to</td><td>等于</td></tr><tr><td>not_equal_to</td><td>不等于</td></tr><tr><td>less_equal</td><td>小于等于</td></tr><tr><td>greater_equal</td><td>大于等于</td></tr></tbody></table><h4 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h4><p>STL中的sort并非只是普通的快速排序，除了对普通的快速排序进行优化外，它还结合了插入排序和堆排序，根据不同的数量级别以及不同情况，能自动选用合适的排序方法：</p><ul><li>使用introsort内省式排序防止快速排序的恶化情况，达到优化快速排序的目的，详见下方说明：</li><li>当数据量较大时采用快速排序，分段递归，若序列数据里较小则直接采用插入排序；</li><li>一旦分段后的数据量小于某个阀值<code>__stl_threshold</code>，为避免递归调用带来过大的额外负荷，便会改用插入排序；</li><li>如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序；</li></ul><h4 id="2、快速排序原理"><a href="#2、快速排序原理" class="headerlink" title="2、快速排序原理"></a>2、快速排序原理</h4><p>普通快速排序算法可以叙述如下，假设S代表需要被排序的数据序列：</p><ul><li>如果<code>S</code>中的元素只有0个或1个，结束;</li><li>取<code>S</code>中的任何一个元素作为枢轴<code>pivot</code>;</li><li>将<code>S</code>分割为<code>L、R</code>两端，使L内的元素都小于等于<code>pivot</code>，<code>R</code>内的元素都大于等于<code>pivot</code>;</li><li>对<code>L、R</code>递归执行上述过程;</li></ul><p>快速排序最关键的地方在于枢轴的选择，最坏的情况发生在分割时产生了一个空的区间，这样就完全没有达到分割的效果。STL采用的做法称<code>为median-of-three</code>，即取整个序列的首、尾、中央三个地方的元素，以其中值作为枢轴。</p><p>分割的方法通常采用两个迭代器<code>head</code>和<code>tail</code>，<code>head</code>从头端往尾端移动，<code>tail</code>从尾端往头端移动，当<code>head</code>遇到大于等于<code>pivot</code>的元素就停下来，<code>tail</code>遇到小于等于<code>pivot</code>的元素也停下来，若<code>head</code>迭代器仍然小于<code>tail</code>迭代器，即两者没有交叉，则互换元素，然后继续进行相同的动作，向中间逼近，直到两个迭代器交叉，结束一次分割。</p><h4 id="3、Introsort-内省式排序"><a href="#3、Introsort-内省式排序" class="headerlink" title="3、Introsort 内省式排序"></a>3、Introsort 内省式排序</h4><p>不当的枢轴选择，导致不当的分割，会使快速排序恶化为 <code>O(n2)</code>。为避免此种情况出现，stl使用了内省式排序，其行为大部分与上面所说的<code>median-of-three Quick Sort</code>完全相同，是当分割行为有恶化为<code>O(n2)</code>的倾向时，能够自我侦测，转而改用堆排序，使效率维持在堆排序的 <code>O(nlgn)</code>，又比一开始就使用堆排序来得好。</p><p>如函数源码，其中，<code>__introsort\_loop</code>便是内省式排序，第三个参数所调用的函数<code>__lg()</code>便是用来判断分割恶化情况，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template &lt;class Size&gt;inline Size __lg(Size n) &#123;Size k;for (k &#x3D; 0; n &gt; 1; n &gt;&gt;&#x3D; 1) ++k;return k;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即求<code>lg(n)</code>（取下整），意味着快速排序的递归调用最多 <code>2*lg(n)</code> 层。</p><h4 id="4、stable-sort稳定排序"><a href="#4、stable-sort稳定排序" class="headerlink" title="4、stable_sort稳定排序"></a>4、stable_sort稳定排序</h4><p>对于相等元素，在排序后保证相对位置不变</p><h2 id="3-5、元编程"><a href="#3-5、元编程" class="headerlink" title="3.5、元编程"></a>3.5、元编程</h2><p>依赖于语言自身提供的模板机制</p><h2 id="3-6、模板类型推导"><a href="#3-6、模板类型推导" class="headerlink" title="3.6、模板类型推导"></a>3.6、模板类型推导</h2><p>详见第<strong>10</strong>章节</p><h2 id="3-7、std-function-amp-amp-std-bind函数封装器"><a href="#3-7、std-function-amp-amp-std-bind函数封装器" class="headerlink" title="3.7、std::function&amp;&amp;std::bind函数封装器"></a>3.7、std::function&amp;&amp;std::bind函数封装器</h2><p>std::function也称作仿函数，属于C++的一种模板类，是一种通用、多态的函数封装器，对可调用实体进行统一封装，封装后的std::function实例可以进行存储、复制和调用，且是一种类型安全的包裹。  </p><p>可调用对象包括：</p><ul><li>普通函数指针;</li><li>lambda表达式</li><li>函数对象(重载operator()符);</li><li>类成员函数指针；</li></ul><pre class="line-numbers language-none"><code class="language-none">#include &lt;functional&gt;#include &lt;iostream&gt;using namespace std;std::function&lt; int(int)&gt; Functional;&#x2F;&#x2F; 普通函数int TestFunc(int a)&#123;    return a;&#125;&#x2F;&#x2F; Lambda表达式auto lambda &#x3D; [](int a)-&gt;int&#123; return a; &#125;;&#x2F;&#x2F; 函数对象class Functor&#123;public:    int operator()(int a)    &#123;        return a;    &#125;&#125;;&#x2F;&#x2F; 1.类成员函数&#x2F;&#x2F; 2.类静态函数class TestClass&#123;public:    int ClassMember(int a) &#123; return a; &#125;    static int StaticMember(int a) &#123; return a; &#125;&#125;;int main()&#123;    &#x2F;&#x2F; 普通函数    Functional &#x3D; TestFunc;    int result &#x3D; Functional(10);    cout &lt;&lt; &quot;普通函数：&quot;&lt;&lt; result &lt;&lt; endl;    &#x2F;&#x2F; Lambda表达式    Functional &#x3D; lambda;    result &#x3D; Functional(20);    cout &lt;&lt; &quot;Lambda表达式：&quot;&lt;&lt; result &lt;&lt; endl;    &#x2F;&#x2F; 类对象    Functor testFunctor;    Functional &#x3D; testFunctor;    result &#x3D; Functional(30);    cout &lt;&lt; &quot;仿函数：&quot;&lt;&lt; result &lt;&lt; endl;    &#x2F;&#x2F; 类成员函数    TestClass testObj;    Functional &#x3D; std::bind(&amp;TestClass::ClassMember, testObj, std::placeholders::_1);    result &#x3D; Functional(40);    cout &lt;&lt; &quot;类成员函数：&quot;&lt;&lt; result &lt;&lt; endl;    &#x2F;&#x2F; 类静态函数    Functional &#x3D; TestClass::StaticMember;    result &#x3D; Functional(50);    cout &lt;&lt; &quot;类静态函数：&quot;&lt;&lt; result &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>std::bind</strong><br>用来将可调用对象与其参数一起绑定，，绑定后的结果可以使用function进行保存。<br>基本用法：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;functional&gt;void call_when_even(int x, const std::function&lt;void(int)&gt;&amp; f)&#123;if (!(x &amp; 1))  &#x2F;&#x2F;x % 2 &#x3D;&#x3D; 0&#123;f(x);&#125;&#125;void output(int x)&#123;std::cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;void output_add_2(int x)&#123;std::cout &lt;&lt; x + 2 &lt;&lt; &quot; &quot;;&#125;int main(void)&#123;&#123;auto fr &#x3D; std::bind(output, std::placeholders::_1);for (int i &#x3D; 0; i &lt; 10; ++i)&#123;call_when_even(i, fr);&#125;std::cout &lt;&lt; std::endl;&#125;&#123;auto fr &#x3D; std::bind(output_add_2, std::placeholders::_1);for (int i &#x3D; 0; i &lt; 10; ++i)&#123;call_when_even(i, fr);&#125;std::cout &lt;&lt; std::endl;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::placeholders::_1是占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;functional&gt;void output(int x, int y)&#123;std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;&#125;int main(void)&#123;std::bind(output, 1, 2)();  &#x2F;&#x2F;输出1 2std::bind(output, std::placeholders::_1, 2)(1);&#x2F;&#x2F;输出1 2std::bind(output, 2, std::placeholders::_1)(1);&#x2F;&#x2F;输出2 1std::bind(output, 2, std::placeholders::_2)(1);  &#x2F;&#x2F;error:调用时没有第二个参数std::bind(output, 2, std::placeholders::_2)(1, 2);  &#x2F;&#x2F;输出 2 2   调用时第一个参数被吞掉了std::bind(output, std::placeholders::_1, std::placeholders::_2)(1, 2);  &#x2F;&#x2F;输出 1 2std::bind(output, std::placeholders::_2, std::placeholders::_1)(1, 2);  &#x2F;&#x2F;输出 2 1system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bind和function配合使用</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;functional&gt;class A&#123;public:int i_ &#x3D; 0;void output(int x, int y)&#123;std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;&#125;&#125;;int main(void)&#123;A a;std::function&lt;void(int, int)&gt; fr &#x3D;std::bind(&amp;A::output, &amp;a, std::placeholders::_1, std::placeholders::_2);fr(1, 2);  &#x2F;&#x2F;输出 1 2std::function&lt;int&amp;(void)&gt; fr_i &#x3D; std::bind(&amp;A::i_, &amp;a);  &#x2F;&#x2F;vs13的bug，绑定成员变量要报错fr_i() &#x3D; 123;std::cout &lt;&lt; a.i_ &lt;&lt; std::endl;  &#x2F;&#x2F;输出 123system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fr表示将A的成员函数output的指针和对象a绑定</p><h2 id="3-8、std-tuple"><a href="#3-8、std-tuple" class="headerlink" title="3.8、std::tuple"></a>3.8、std::tuple</h2><p>是一个模板类，用于构造成员量较少的轻量临时结构体struct</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct B&#123;int a;int b;&#125;;int main()&#123;tuple&lt;int, string,double&gt; bb &#x3D; make_tuple(24, &quot;Hello&quot;, 1.265);cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;0&gt;(bb) &lt;&lt; endl;cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;1&gt;(bb) &lt;&lt; endl;cout &lt;&lt; &quot;*****&quot; &lt;&lt; get&lt;2&gt;(bb) &lt;&lt; endl;B bt;bt.a &#x3D; 2;bt.b &#x3D; 3;tuple&lt;int, B&gt; aa &#x3D; make_tuple(12,bt);cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; get&lt;0&gt;(aa) &lt;&lt; endl;cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; (get&lt;1&gt;(aa)).a &lt;&lt; endl;cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; (get&lt;1&gt;(aa)).b &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4、面向对象编程"><a href="#4、面向对象编程" class="headerlink" title="4、面向对象编程"></a>4、面向对象编程</h1><ul><li><strong>类与对象</strong><br>类是对象的模板，一个类可以创建多个相同的对象；对象是类的实例，是按照类的规则创建的。   </li><li><strong>封装</strong><br>封装指的是将数据以及使用它们的方法进行逻辑编组，简单的说就是：<font color=red>数据隐藏和提供访问接口</font>。为实现类的封装性，类的类型定义提供了三种访问权限：公有，私有，受保护</li></ul><p><strong>面向对象的基本特征</strong></p><ul><li><p><strong>1、抽象</strong><br>抽象就是找出对象的共性，然后将这些对象抽象成类。因此，类是对象的抽象，对象是类的具体表现形式。寻找共性，提出特性。    </p></li><li><p><strong>2、封装</strong><br>封装是指把类的属性和方法隐藏在内部，对外只提供访问数据的接口。这样使用者只需关心对象对外提供的接口，无需了解具体的实现形式。</p></li><li><p><strong>3、继承</strong><br>继承可以使一个类拥有其他类的功能，在无需重复实现同样功能的前提下扩展自身的新增功能。</p></li><li><p><strong>4、多态</strong><br>多态是指不同对象对同样的消息作出的不同响应，比如发出吃饭的指令，中国人用筷子，美国人用刀叉。通过运行时绑定绑定实现多态，在将子类对象的地址赋给父类，在调用方法时，根据具体的对象类型执行相应子类的方法。</p></li></ul><h2 id="4-1、继承与派生"><a href="#4-1、继承与派生" class="headerlink" title="4.1、继承与派生"></a>4.1、继承与派生</h2><p>从同一个基类派生出类似的类，在基类中实现通用功能，并在派生类中实现特有功能，以实现每个类的独一无二；<br>派生类中包含两大部分内容：从基类继承而来的和派生类新增的。</p><h3 id="4-1-1、继承的类型"><a href="#4-1-1、继承的类型" class="headerlink" title="4.1.1、继承的类型"></a>4.1.1、继承的类型</h3><p>在访问属性中，不仅要考虑基类成员所声明的访问属性，还要考虑派生类所声明的对基类的继承方式，根据这两个因素共同决定基类成员在派生类中的访问属性：</p><ul><li>公有继承：基类的公有成员和保护成员在派生类中保持原有访问属性，私有成员仍为基类私有；    </li><li>私有继承：基类的公有成员和保护成员在派生类中成了私有成员，私有成员仍为基类私有；     </li><li>保护继承：基类的公有成员和保护成员在派生类中成了保护成员，私有成员仍为基类私有。保护成员的意思是：不能被类外部使用(<strong>类外</strong>)，但能够被派生类继承；    </li></ul><p>总的来说：    </p><ul><li>私有成员只能被基类访问，不能被派生类继承；    </li><li>保护成员不能被类外访问，但可以被继承；    </li><li>基类与派生类之间是is-a的关系，比如黑色的马是马的一种；</li></ul><p><strong>需要注意的是</strong>：<br>在继承时如果不显示指明public、private、protected，<strong>class默认是private继承，而struct默认是public继承</strong>。</p><h3 id="4-1-2、构造函数、析构函数"><a href="#4-1-2、构造函数、析构函数" class="headerlink" title="4.1.2、构造函数、析构函数"></a>4.1.2、构造函数、析构函数</h3><p><font color=green><strong>默认构造函数</strong></font>   </p><ul><li>当用户未显式定义构造函数时，编译器会为其生成默认构造函数，默认构造函数是无参数类型；   </li><li>当用户定义了构造函数时，编译器不会为其生成默认构造函数；   <h4 id="1、执行顺序"><a href="#1、执行顺序" class="headerlink" title="1、执行顺序"></a>1、执行顺序</h4>只讨论构造函数，不涉及非类类型成员     </li></ul><p><font color=purple>构造函数执行顺序</font><br>按照先后顺序主要有三大部分：</p><ul><li>派生类自身的static静态成员部分；</li><li>继承部分；</li><li>派生类自身的类类型对象成员部分，不包括static类对象成员，但包括const类类型对象成员；</li><li>派生类自身剩余部分；</li></ul><p><font color=red><strong>细节展开如下:</strong></font></p><ul><li>静态类类型成员构造函数，如果有多个，则按照声明顺序；</li><li>虚继承基类的构造函数，如果有多个，则按照继承顺序；</li><li>抽象基类的构造函数，如果有多个，则按照继承顺序；</li><li>普通基类的构造函数，如果有多个，则按照继承顺序；</li><li>普通类类型成员的构造函数(包括const类类型成员)，如果有多个，则按照声明顺序；</li><li>派生类自己的构造函数；</li></ul><p>示例：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;抽象类Aclass A&#123;public:A()&#123;cout&lt;&lt;&quot;抽象类A的构造函数&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;纯虚函数funvirtual void fun1() &#x3D; 0;&#125;; &#x2F;&#x2F;抽象类Bclass B&#123;public:B()&#123;cout&lt;&lt;&quot;抽象类B的构造函数&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;纯虚函数funvirtual void fun2() &#x3D; 0;&#125;; &#x2F;&#x2F;普通类Cclass C&#123;public:C()&#123;cout&lt;&lt;&quot;类C的构造函数&quot;&lt;&lt;endl;&#125;&#125;; &#x2F;&#x2F;普通类Dclass D&#123;public:D()&#123;cout&lt;&lt;&quot;类D的构造函数&quot;&lt;&lt;endl;&#125;&#125;; &#x2F;&#x2F;普通类Eclass E&#123;public:E()&#123;cout&lt;&lt;&quot;类E的构造函数&quot;&lt;&lt;endl;&#125;&#125;; &#x2F;&#x2F;普通类Fclass F&#123;public:F()&#123;cout&lt;&lt;&quot;类F的构造函数&quot;&lt;&lt;endl;&#125;&#125;; &#x2F;&#x2F;普通类Gclass G&#123;public:G()&#123;cout&lt;&lt;&quot;类G的构造函数&quot;&lt;&lt;endl;&#125;&#125;; &#x2F;&#x2F;普通类Hclass H&#123;public:H()&#123;cout&lt;&lt;&quot;类H的构造函数&quot;&lt;&lt;endl;&#125;&#125;;&#x2F;&#x2F;普通类Mclass M&#123;public:M()&#123;cout&lt;&lt;&quot;类M的构造函数&quot;&lt;&lt;endl;&#125;&#125;; class Test: public A,public B,virtual public C,virtual public D,public E,public F&#123;public:Test():B(),A(),D(),C(),F(),E(),m(M())&#123;cout&lt;&lt;&quot;类Test的构造函数&quot;&lt;&lt;endl;&#125;void fun1()&#123;&#125;void fun2()&#123;&#125;private:G g;static H h;const M m;&#125;;H Test::h;int main()&#123;    Test test;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">类H的构造函数类C的构造函数类D的构造函数抽象类A的构造函数抽象类B的构造函数类E的构造函数类F的构造函数类G的构造函数类M的构造函数类Test的构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=liceblue>析构函数的执行顺序与构造函数相反</font></p><h4 id="2、抛出异常"><a href="#2、抛出异常" class="headerlink" title="2、抛出异常"></a>2、抛出异常</h4><p>可以抛出异常，但不建议使用，会造成内存资源泄漏</p><ul><li>构造函数<br>对象只有在构造函数执行完毕之后才算是完全构造妥当，如果在构造函数内抛出异常，控制权就会被转移出构造函数之外，由于对象没有被正常构造完毕，之后的析构函数便不会被调用，进而造成内存泄漏。</li><li>析构函数<br>如果析构函数内抛出异常，而且没有被自身捕捉的话，那么它的执行是不完整的，没有完成它应该执行的每一步事情，会导致不可预期的错误</li></ul><h3 id="4-1-3、拷贝构造函数"><a href="#4-1-3、拷贝构造函数" class="headerlink" title="4.1.3、拷贝构造函数"></a>4.1.3、拷贝构造函数</h3><ul><li>普通拷贝构造函数；</li><li>移动拷贝构造函数；</li></ul><h4 id="1、普通拷贝构造函数"><a href="#1、普通拷贝构造函数" class="headerlink" title="1、普通拷贝构造函数"></a>1、普通拷贝构造函数</h4><p>对于用户自定义类且没有显式实现普通拷贝构造函数时，编译器会生成默认拷贝构造函数，默认拷贝构造函数是浅拷贝操作。C++内置类通常会根据实际场景实现拷贝构造函数，比如std::string类，它的普通拷贝构造函数就不是浅拷贝，而是深拷贝</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A&#123;public:    A():ptr_m_(new int(10 + construct_count))&#123;        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;    &#125;    static int construct_count;    int *ptr_m_;    ~A()    &#123;        delete ptr_m_;        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    A a01;    A a02 &#x3D; a01;  &#x2F;&#x2F; 调用拷贝构造函数    std::cout &lt;&lt; *(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; std::endl;    std::string str01 &#x3D; &quot;hello&quot;;    std::string str02 &#x3D; str01;    std::cout &lt;&lt; str01 &lt;&lt; &quot; &quot; &lt;&lt; str02 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 110 10hello hellodestructor*** Error in &#96;.&#x2F;main&#39;: double free or corruption (fasttop): 0x0000000001b5cc20 ***&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7f75f5d297e5]&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7f75f5d3237a]&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(cfree+0x4c)[0x7f75f5d3653c]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类A是用户自定义类，编译器生成默认拷贝构造函数，由于是浅拷贝，a01与a02中的成员指针ptr_m_均指向同一块堆空间，会被析构两次，error。<br>而C++内置类型string的拷贝构造函数实现了深拷贝，故str01与str02中的成员char数组是两块不相干的堆空间，只是存放的内容一样而已</p><h4 id="2、移动拷贝构造函数"><a href="#2、移动拷贝构造函数" class="headerlink" title="2、移动拷贝构造函数"></a>2、移动拷贝构造函数</h4><p>详见<strong>第5、引用</strong></p><h3 id="4-1-4、继承构造函数"><a href="#4-1-4、继承构造函数" class="headerlink" title="4.1.4、继承构造函数"></a>4.1.4、继承构造函数</h3><p>如果基类中存在多个构造函数，通常需要在继承类中声明相同数量的构造函数，以便在构造函数的初始化列表中完成基类的实例化，例如：   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Human&#123;public:    Human(int32_t age):age_(age)&#123;&#125;    Human(std::string name):name_(name)&#123;&#125;        int32_t getAge()    &#123;        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;    &#125;    int32_t getName()    &#123;        std::cout &lt;&lt; &quot;My name is: &quot; &lt;&lt; name_ &lt;&lt; std::endl;    &#125;protected:    int32_t age_;    std::string name_;&#125;;class Children : public Human&#123;public:    Children(int32_t age):Human(age)&#123;&#125;    Children(std::string name):Human(name)&#123;&#125;&#125;;int main()&#123;    Children child01(10);    child01.getAge();    Children child02(&quot;Jack&quot;);    child02.getName();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">I am 10 years oldMy name is: Jack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样的实现会很繁琐，C++11之后可以使用继承构造函数解决这一问题，关键字using</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Human&#123;public:    Human(int32_t age):age_(age)&#123;&#125;    Human(std::string name):name_(name)&#123;&#125;        int32_t getAge()    &#123;        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;    &#125;    int32_t getName()    &#123;        std::cout &lt;&lt; &quot;My name is: &quot; &lt;&lt; name_ &lt;&lt; std::endl;    &#125;protected:    int32_t age_;    std::string name_;&#125;;class Children : public Human&#123;public:    using Human::Human;&#125;;int main()&#123;    Children child01(10);    child01.getAge();    Children child02(&quot;Jack&quot;);    child02.getName();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=darkred><strong>注意</strong></font></p><ul><li>因为调用的是基类的构造函数，对于派生类中的成员，如果需要初始化，就需要自行解决；</li><li>继承构造函数是隐式声明的，即如果一个基类的构造函数不被使用，编译器是不会为其生成真实代码的；</li><li>对于多个基类的情况，需要注意继承构造函数冲突的问题，类似下面例1；</li><li>如果基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数；</li><li>一旦使用了继承构造函数， 编译器就不会再为派生类生成默认构造函数了；</li></ul><p>例1：</p><pre class="line-numbers language-none"><code class="language-none">struct A&#123;A(int)&#123;&#125;&#125;;struct B&#123;B(int)&#123;&#125;&#125;;struct C:A,B&#123;using A::A;using B::B;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法是，显示定义继承类的冲突构造函数</p><pre class="line-numbers language-none"><code class="language-none">struct C:A,B&#123;using A::A;using B::B;C(int)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-1-5、虚继承"><a href="#4-1-5、虚继承" class="headerlink" title="4.1.5、虚继承"></a>4.1.5、虚继承</h3><p>虚继承用于解决菱形继承中的二义性问题，比如：<br>B、C分别继承自A，而D又同时继承自B和C，那么当通过D访问A中的成员时，就无法确定是通过B继承自A的成员，还是通过C继承自A的成员。    </p><p>此时就需要让B和C虚继承A，这样D中就只有一份A。   </p><p>虚继承中的父类称作<font color=darkred>虚基类(注意区别于概念：抽象类)</font></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A &#123;    public:    char c1;    A()    &#123;        c1 &#x3D; &#39;A&#39;;        std::cout &lt;&lt; &quot;A default constructor&quot; &lt;&lt; std::endl;    &#125;    A(char c1)    &#123;        this-&gt;c1 &#x3D; c1;        std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl;    &#125;&#125;;class B:public virtual A&#123;    public:    char c2;    B()    &#123;        c2 &#x3D; &#39;B&#39;;        std::cout &lt;&lt; &quot;B default constructor&quot; &lt;&lt; std::endl;    &#125;    B(char c1, char c2):A(c1)    &#123;        this-&gt;c2 &#x3D; c2;        std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl;    &#125;&#125;;class C:public virtual A&#123;    public:    char c3;    C()    &#123;        c3 &#x3D; &#39;C&#39;;        std::cout &lt;&lt; &quot;C default constructor&quot; &lt;&lt; std::endl;    &#125;    C(char c1, char c3):A(c1)    &#123;        this-&gt;c3 &#x3D; c3;        std::cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; std::endl;    &#125;&#125;;class D:public B, public C&#123;    public:    char c4;    D()    &#123;        c4 &#x3D; &#39;D&#39;;        std::cout &lt;&lt; &quot;D default constructor&quot; &lt;&lt; std::endl;    &#125;    D(char c1, char c2,char c3, char c4):B(c1,c2), C(c3,c3)    &#123;        this-&gt;c4 &#x3D; c4;        std::cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    D obj(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;);    std::cout &lt;&lt; &quot;\nresult:\n&quot; &lt;&lt; obj.c1 &lt;&lt; obj.c2 &lt;&lt; obj.c3 &lt;&lt; obj.c4 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">A default constructorB constructorC constructorD constructorresult:Abcd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、虚继承的本质"><a href="#1、虚继承的本质" class="headerlink" title="1、虚继承的本质"></a>1、虚继承的本质</h4><p>虚继承的本质类似于虚函数的原理，通过虚表指针 + 虚基类表实现。<br>编译器在编译阶段会为虚继承关系的派生类生成虚表指针 + 虚基类表，在运行阶段使虚表指针指向虚基类表。<br>虚基类表存放的是虚表指针到共有基类内存地址的偏移量，详见下方<strong>第2节的内存布局分析</strong></p><h4 id="2、虚继承关系中对象的内存布局"><a href="#2、虚继承关系中对象的内存布局" class="headerlink" title="2、虚继承关系中对象的内存布局"></a>2、虚继承关系中对象的内存布局</h4><p><code>环境：ubuntu 64bit + gdb</code><br>gdb查看内存布局方法参考：<a href="https://blog.csdn.net/weixin_43374723/article/details/107128204">Linux 下利用 gdb 查看 C++ 对象内存分布</a>   </p><ul><li><p>先查看菱形继承时对象内存布局情况:   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;class A&#123;public:    int32_t data_a_;&#125;;  &#x2F;&#x2F; sizeof(A) &#x3D; 4class B : public A&#123;public:    int32_t data_b_;&#125;;  &#x2F;&#x2F; sizeof(B) &#x3D; 4 + 4class C : public A&#123;public:    int32_t data_c_;&#125;;  &#x2F;&#x2F; sizeof(C &#x3D; 4 + 4class D : public B, public C&#123;public:    int32_t data_d_;&#125;;  &#x2F;&#x2F; sizeof(D) &#x3D;  (4 + 4) + (4 + 4) + 4int main()&#123;    std::cout &lt;&lt; &quot;sizeof(A) &#x3D; &quot; &lt;&lt; sizeof(A)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(B) &#x3D; &quot; &lt;&lt; sizeof(B)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(C) &#x3D; &quot; &lt;&lt; sizeof(C)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(D) &#x3D; &quot; &lt;&lt; sizeof(D)&lt;&lt; std::endl;    A a;    B b;    C c;    D d;    &#x2F;&#x2F;d.data_a_ &#x3D; 10;    d.data_b_ &#x3D; 20;    d.data_c_ &#x3D; 30;    d.data_d_ &#x3D; 40;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sizeof(A) &#x3D; 4sizeof(B) &#x3D; 8sizeof(C) &#x3D; 8sizeof(D) &#x3D; 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用gdb查看内存布局</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(gdb) p d$1 &#x3D; &#123;  &lt;B&gt; &#x3D; &#123;    &lt;A&gt; &#x3D; &#123;      data_a_ &#x3D; 0    &#125;,    members of B:    data_b_ &#x3D; 20  &#125;,  &lt;C&gt; &#x3D; &#123;    &lt;A&gt; &#x3D; &#123;      data_a_ &#x3D; 1431654656    &#125;,    members of C:    data_c_ &#x3D; 30  &#125;,  members of D:  data_d_ &#x3D; 40&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到对象的d中有两份class A</p></li><li><p>再来对比虚继承关系中的内存布局：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;class A&#123;public:    int32_t data_a_;&#125;;  &#x2F;&#x2F; sizeof(A) &#x3D; 4class B : virtual public A&#123;public:    int32_t data_b_;&#125;;  &#x2F;&#x2F; sizeof(B) &#x3D; 8 + 4 + 4class C : virtual public A&#123;public:    int32_t data_c_;&#125;;  &#x2F;&#x2F; sizeof(C &#x3D; 8 + 4 + 4class D : public B, public C&#123;public:    int32_t data_d_;&#125;;  &#x2F;&#x2F; sizeof(D) &#x3D; （8 + 4） + （8 + 4） + 4 + 4int main()&#123;    std::cout &lt;&lt; &quot;sizeof(A) &#x3D; &quot; &lt;&lt; sizeof(A)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(B) &#x3D; &quot; &lt;&lt; sizeof(B)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(C) &#x3D; &quot; &lt;&lt; sizeof(C)&lt;&lt; std::endl;    std::cout &lt;&lt; &quot;sizeof(D) &#x3D; &quot; &lt;&lt; sizeof(D)&lt;&lt; std::endl;    A a;    B b;    C c;    D d;    d.data_a_ &#x3D; 10;    d.data_b_ &#x3D; 20;    d.data_c_ &#x3D; 30;    d.data_d_ &#x3D; 40;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sizeof(A) &#x3D; 4sizeof(B) &#x3D; 16sizeof(C) &#x3D; 16sizeof(D) &#x3D; 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里注意到一点，sizeof(D)的结果为40，这是由编译器的内存对齐原则引起的，如果设置为4byte对齐规则的话，sizeof(D)的结果就与预期的32一致。<br>通过gdb查看对象d的内存布局如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(gdb) p d$1 &#x3D; &#123;  &lt;B&gt; &#x3D; &#123;    &lt;A&gt; &#x3D; &#123;      data_a_ &#x3D; 10    &#125;,    members of B:    _vptr.B &#x3D; 0x555555557c40 &lt;vtable for D+24&gt;,    data_b_ &#x3D; 20  &#125;,  &lt;C&gt; &#x3D; &#123;    members of C:    _vptr.C &#x3D; 0x555555557c58 &lt;VTT for D&gt;,    data_c_ &#x3D; 30  &#125;,  members of D:  data_d_ &#x3D; 21845&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到对象d内只有一份class A，基类B、C中各有一个虚表指针指向各自的虚基类表，而各自的虚基类表之中存放的是各自虚表指针到共有基类A的内存偏移量。<br>虚基类表的内容看参考：<a href="https://blog.csdn.net/xiejingfa/article/details/48028491">【C++拾遗】 从内存布局看C++虚继承的实现原理</a><br>文章基于VS编译，可以直观的看到虚基类表存放的内容。<br><font color=red>PS：至于虚基类在内存中的布局，由编译器决定，比如g++编译器，虚基类的内存位置于首先声明的子类B之中，而VS编译器则位于子类B、C的后面，单独存放。</font></p><h3 id="4-1-6、默认函数"><a href="#4-1-6、默认函数" class="headerlink" title="4.1.6、默认函数"></a>4.1.6、默认函数</h3><p>类提供的默认函数：</p></li><li><p>构造函数</p></li><li><p>拷贝构造函数</p></li><li><p>赋值运算符（operator=）</p></li><li><p>移动构造函数</p></li><li><p>移动拷贝函数</p></li><li><p>移动赋值运算符</p></li><li><p>析构函数</p></li></ul><p>默认操作符函数：</p><ul><li>operator ,</li><li>operator ＆</li><li>operator ＆＆</li><li>operator *</li><li>operator -＞</li><li>operator -＞*</li><li>operator new</li><li>operator delete </li></ul><p>其中默认构造函数、析构函数、拷贝构造函数、赋值操作符均是public且inline；</p><h4 id="1、默认函数的添加与删除"><a href="#1、默认函数的添加与删除" class="headerlink" title="1、默认函数的添加与删除"></a>1、默认函数的添加与删除</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Car&#123;public:    Car() &#x3D; default;  &#x2F;&#x2F; 在用户自定义构造函数的情况下，再要求编译器提供默认版本    Car(int32_t color);    Car(const Car&amp;) &#x3D; delete;  &#x2F;&#x2F; 删除拷贝构造函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2、多态"><a href="#4-2、多态" class="headerlink" title="4.2、多态"></a>4.2、多态</h2><h3 id="4-2-1、概念"><a href="#4-2-1、概念" class="headerlink" title="4.2.1、概念"></a>4.2.1、概念</h3><p>多态分为两种：</p><ul><li>编译时多态：函数的重载、模板的实现，静态绑定；</li><li>运行时多态：虚函数机制，动态绑定；</li></ul><p>多态，顾名思义就是一个事物有多种形态。在C++程序设计中，多态是指在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</p><p>多态可以简单概括为”一个接口，多种实现”。向不同的对象发送同一个消息会产生不同的行为。也就是说，每个对象可以用自己的方式去响应共同的消息，这体现了面向对象编程的抽象机制。    </p><ul><li>virtual声明的函数叫做虚函数；</li><li>存在虚函数的类都有一个一维的虚函数表称作虚表，该类的每一个对象都包含一个指向虚表的虚指针；</li><li>虚函数表对应类，虚函数指针对应类的对象；</li><li>类的多态是基于虚函数的动态绑定机制；</li><li>类的多态性只发生在对象的指针或引用操作中，因为普通对象在传递时会发生截断现象；</li></ul><h3 id="4-2-2、原理"><a href="#4-2-2、原理" class="headerlink" title="4.2.2、原理"></a>4.2.2、原理</h3><p><strong>先看一下普通例子：</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C"> 1 #include &quot;stdafx.h&quot; 2 #include &lt;iostream&gt;  3 #include &lt;stdlib.h&gt; 4 using namespace std;  5  6 class Father 7 &#123; 8 public: 9     void Face()10     &#123;11         cout &lt;&lt; &quot;Father&#39;s face&quot; &lt;&lt; endl;12     &#125;13 14     void Say()15     &#123;16         cout &lt;&lt; &quot;Father say hello&quot; &lt;&lt; endl;17     &#125;18 &#125;;19 20 21 class Son:public Father22 &#123;23 public:     24     void Say()25     &#123;26         cout &lt;&lt; &quot;Son say hello&quot; &lt;&lt; endl;27     &#125;28 &#125;;29 30 void main()31 &#123;32     Son son;33     Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换34     pFather-&gt;Say();35 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：<br>Father say hello   </p><p><strong>从编译角度而言：</strong><br>在编译阶段要确定每个对象调用函数（非虚函数）的地址，称作静态绑定，当我们将Son类的对象son的地址赋给pFather时，编译器进行了类型转换，此时编译器认为变量pFather指向的就是Father类对象，当发生pFather-&gt;Say()调用时,调用的自然是Father对象的Say函数。  </p><p><strong>从内存角度：</strong><br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE935ccb384dcbed26f643dbac8a50cf8c/38320" alt="image02"></p><p>将Son类对象转换为Father类型时，该对象就被认为是原对象整个内存模型的上半部分，也就是上图中”Father类对象内存空间”，当发生pFather-&gt;Say()调用时,调用的自然是Father对象的Say函数。</p><p><strong>多态例子：</strong>   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;class Father&#123;public:    void Face()    &#123;        cout &lt;&lt; &quot;Father&#39;s face&quot; &lt;&lt; endl;    &#125;    virtual void Say()    &#123;        cout &lt;&lt; &quot;Father say hello&quot; &lt;&lt; endl;    &#125;&#125;;class Son:public Father&#123;public:    void Say()    &#123;        cout &lt;&lt; &quot;Son say hello&quot; &lt;&lt; endl;    &#125;&#125;;void main()&#123;    Son son;    Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换    pFather-&gt;Say();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为：<br>Son say hello    </p><p>编译阶段编译器会为Father类和Son类各自生成一张虚函数表，用于存放各自虚函数Say的地址<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCEf70f5819e509a0107c4092904c1359eb/39917" alt="image03"></p><p>如何定位虚函数表？<br>编译阶段编译器会为类对象生成一个虚指针vptr(尚未初始化)，该指针用于指向对象所属类的虚函数表。   </p><p>虚表指针何时指向虚函数表？<br>对象构造时虚表指针完成初始化，指向虚函数表内存地址</p><p><font color=red><strong>编译期行为</strong></font>   </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void main()&#123;    Son son;    Father *pFather&#x3D;&amp;son; &#x2F;&#x2F; 隐式类型转换    pFather-&gt;Say();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管pFather是基类类型的指针，但编译阶段编译器会判断Say函数是否是虚函数，如果不是，则在编译期就能确定Say的调用地址；如果是，则编译器会为其指定虚表指针vptr，运行阶段通过虚函数表查找并调用真实的Say函数</p><ul><li> <font color=red>虚表可以继承：如果子类没有实现虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数；</font></li><li>派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同；</li></ul><h3 id="4-2-3、虚函数的继承原则"><a href="#4-2-3、虚函数的继承原则" class="headerlink" title="4.2.3、虚函数的继承原则"></a>4.2.3、虚函数的继承原则</h3><p>派生类中虚函数的实现四原则：函数名、参数列表、返回类型、常量性const与基类的完全一致。     </p><p>**==四原则有一个例外就是返回类型==**，当基类的返回类型是基类的指针或引用时，派生类中的返回类型可以是派生类的指针或引用；<br>**==另一个例外就是==**：虚析构函数，基类与派生类的析构函数名字就不一样；</p><h3 id="4-2-4、纯虚函数与抽象类"><a href="#4-2-4、纯虚函数与抽象类" class="headerlink" title="4.2.4、纯虚函数与抽象类"></a>4.2.4、纯虚函数与抽象类</h3><p>在虚函数后添加关键字”= 0”声明纯虚函数：</p><ul><li>纯虚函数通常不需要定义，只要声明即可；   </li></ul><p><font color=red><strong>ps：纯虚函数是可以有定义的</strong></font></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 纯虚函数可以有定义体class Animal&#123;public:    Animal()&#123;std::cout &lt;&lt; &quot;animal constructer&quot; &lt;&lt; std::endl;&#125;    ~Animal()&#123;&#125;;    virtual void Breather() &#x3D; 0;&#125;;void Animal::Breather()&#123;    std::cout &lt;&lt; &quot;animal can breather&quot; &lt;&lt; std::endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>基类中即使实现了纯虚函数的定义，该基类依然是抽象类；</li><li>包含纯虚函数的类称作抽象类；</li><li>抽象类不能实例化对象，ps：准确的说是不能直接实例化，在继承关系中，抽象基类的构造函数会在派生类中执行；</li><li>抽象类不能实例化是指不能通过静态或动态的方式直接构建类的对象，但可以定义抽象类的指针，因为指针并不是类的对象，而是指向类对象的地址；</li><li>纯虚函数多用在基类中声明一个接口，在派生类中做具体实现，所以抽象类要求其派生类必须实现纯虚函数；</li><li>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象；</li></ul><p>例如Animal类定义纯虚函数breather，在派生类Dog、Fish、Bird中实现具体的呼吸方式</p><p><strong>==纯虚函数存在的意义==</strong><br>定义纯虚函数的真正目的是为了定义抽象类，而并不是函数本身。与之相比，在Java中，定义抽象类的语法是 abstract class，也就是在类的一级直接指定（当然虚函数前也还是要加上abstract关键字），这样似乎更合理一些。</p><p><strong>==抽象类存在的意义==</strong><br>抽象类在继承关系中提供统一的接口，而在派生类中根据需要完成接口的具体实现<br>比如基类Animal、派生类Dog，Dog可以实例化为各种对象，比如big dog、small dog等等，这是合理的，但对于Animal实例化一个对象就没有什么实际意义，于是干脆就拒绝此类实例化对象。避免基类实例化就是抽象类存在的实际意义。</p><h3 id="4-2-5、正确理解：抽象类不能实例化对象"><a href="#4-2-5、正确理解：抽象类不能实例化对象" class="headerlink" title="4.2.5、正确理解：抽象类不能实例化对象"></a>4.2.5、正确理解：抽象类不能实例化对象</h3><p>“抽象类不能实例化对象”这句话并不是十分正确，应该说是不能直接实例化对象，在继承关系中，抽象基类的构造函数会在派生类的构造函数之中执行，例如</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Animal&#123;public:    Animal()&#123;std::cout &lt;&lt; &quot;animal constructer&quot; &lt;&lt; std::endl;&#125;    ~Animal()&#123;&#125;    virtual void Breather() &#x3D; 0;&#125;;class Dog : public Animal&#123;public:    Dog()&#123;std::cout &lt;&lt; &quot;dog constructer&quot; &lt;&lt; std::endl;&#125;    ~Dog()&#123;&#125;    void Breather()    &#123;        std::cout &lt;&lt; &quot;dog can breather&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Animal a;  &#x2F;&#x2F; error    Animal *pAnimal &#x3D; new Dog;    pAnimal-&gt;Breather();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main函数中对象a的构造会导致编译报错，因为抽象类Animal不能够实例化对象a；<br>关闭<code>Animal a</code>后代码运行结果是：    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">animal constructerdog constructerdog can breather<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明在派生类Dog构造时链式调用了抽象基类的构造函数，为基类申请了运行时空间。</p><h3 id="4-2-6、虚函数与构造函数、析构函数"><a href="#4-2-6、虚函数与构造函数、析构函数" class="headerlink" title="4.2.6、虚函数与构造函数、析构函数"></a>4.2.6、虚函数与构造函数、析构函数</h3><ul><li><p>==构造函数==<br>构造函数不能为virtual，因为</p><ul><li>多态性是基于对象的指针或引用的类型来调用正确的重载函数，而构造函数执行时，该对象还未构造完成，内存空间尚未申请完毕，自然无从知晓其类型是什么；    </li><li>对象中指向vtable的虚指针vptr是存在于对象的内存空间之中的，此时对象尚未构造完成，vptr是无法指向vtable；</li></ul></li><li><p>==析构函数==<br>普通析构函数在继承关系中可能存在内存泄漏的问题，示例：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Fish&#123;public:~ Fish()&#123;&#125;&#125;class Carp : public Fish&#123;public:~ Carp()&#123;&#125;&#125;void DeleteMem(Fish *input)&#123;delete input;&#125;Carp *myDinner &#x3D; new Carp;DeleteMem(myDinner);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DeleteMem调用时，派生类对象指针myDinner会隐式转换为基类Fish，当delete操作时调用的是基类的析构函数，派生类的析构函数并未调用，出现内存泄漏。   </p></li><li><p><em>==基类的析构函数建议声明为virtual==</em>*</p></li><li><p>==析构函数可以为纯虚函数==<br>纯虚析构函数必须实现其定义，否则会在继承关系的链接时报错：undefined reference to ****，这是因为例如构造函数、析构函数等，不同于其他成员函数，在编译时会生成一个调用链，当需要生成基类析构函数调用链时发现并未定义此析构函数，就会报错。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base&#123;public:   Base()   &#123;   &#125;   virtual ~Base() &#x3D; 0; &#x2F;&#x2F;pure virtual&#125;;Base::~Base()&#x2F;&#x2F;function body&#123;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>==构造函数、析构函数内是否可以调用继承关系里的虚函数？==<br>可以调用，但不建议如此编程，即使调用虚函数，动态绑定也不会生效，因为</p><ul><li>在继承关系中，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，由于此时子类还没有构造，所以此时的对象还是父类的，不会触发多态，调用的是父类相关函数；</li><li>析构函数也是一样，子类先进行析构，如果有虚函数的话，由于子类对象已经被析构了，此时执行的是父类的相关函数函数；</li></ul></li></ul><p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是该构造函数或析构函数自身类型定义的版本。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Car&#123;public:    Car(int32_t num):wheel_num_(num)    &#123;        show();    &#125;    ~Car()    &#123;        show();    &#125;    virtual void show()     &#123;        printf(&quot;Car has %d wheels\n&quot;, wheel_num_);    &#125;    int32_t wheel_num_;&#125;;class BigCar : public Car&#123;public:    BigCar(int32_t num): window_num_(num), Car(num)    &#123;        show();    &#125;    ~BigCar()    &#123;        show();    &#125;    void show()    &#123;        printf(&quot;BigCar has %d windows\n&quot;, window_num_);    &#125;    int32_t window_num_;&#125;;int main()&#123;    std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl;    BigCar *ptr_big &#x3D; new BigCar(4);    std::cout &lt;&lt; &quot;\ndestruct&quot; &lt;&lt; std::endl;    delete ptr_big;    &#x2F;&#x2F;Car *ptr &#x3D; ptr_big;    &#x2F;&#x2F;ptr-&gt;show();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">constructCar has 4 wheelsBigCar has 4 windowsdestructBigCar has 4 windowsCar has 4 wheels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-7、虚函数与inline"><a href="#4-2-7、虚函数与inline" class="headerlink" title="4.2.7、虚函数与inline"></a>4.2.7、虚函数与inline</h3><p>==<strong>虚函数是否可以声明为inline？</strong>==   </p><p>首先要明白virtual与inline的作用是什么：   </p><ul><li>虚函数用于实现运行时的多态，或称作动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，在调用内联函数的地方就地代码展开，不生成独立汇编代码，避免频繁调用的开销；</li><li>虚函数在运行期动态绑定，而内联函数在编译期进行代码展开；   </li></ul><p>==结论：==<br>虚函数可以申明为inline，但要具体到编译期的实际情况：</p><ul><li>如果编译器在编译的时候就可以确定该虚函数的决议，则编译器以inline方式静态决议该虚函数；</li><li>如果编译器在编译的时候不能决定，则必须在运行时决议虚函数，此时虚函数不能以inline函数的方式调用；</li></ul><h2 id="4-3、友元"><a href="#4-3、友元" class="headerlink" title="4.3、友元"></a>4.3、友元</h2><h3 id="4-3-1、友元函数"><a href="#4-3-1、友元函数" class="headerlink" title="4.3.1、友元函数"></a>4.3.1、友元函数</h3><p>在类外定义、不属于当前类的函数且可以访问当前类的所有成员，包括 public、protected、private，称作友元函数。<br>友元函数并不是类的成员函数，所以不可以在类内定义，仅声明即可。    </p><p><strong>==一个函数可以是多个类的友元函数==</strong></p><p>友元函数可以是：</p><ul><li>普通全局函数，非类的成员函数；</li><li>其他类的成员函数</li></ul><h4 id="1、非类的成员函数作为友元函数"><a href="#1、非类的成员函数作为友元函数" class="headerlink" title="1、非类的成员函数作为友元函数"></a>1、非类的成员函数作为友元函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;using namespace std;class Student&#123;public:    Student(char *name, int age, float score);public:    friend void show(Student *pstu);  &#x2F;&#x2F;将show()声明为友元函数private:    char *m_name;    int m_age;    float m_score;&#125;;Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;&#x2F;&#x2F;非成员函数void show(Student *pstu)&#123;    cout&lt;&lt;pstu-&gt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;pstu-&gt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;pstu-&gt;m_score&lt;&lt;endl;&#125;int main()&#123;    Student stu(&quot;小明&quot;, 15, 90.6);    show(&amp;stu);  &#x2F;&#x2F;调用友元函数    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);    show(pstu);  &#x2F;&#x2F;调用友元函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>show是一个全局范围内的非成员函数，声明为friend之后，可以访问类的所有成员。<br>但show仍不同与成员函数，它并不能直接访问类的成员，需要借助类的对象进行访问</p><h4 id="2、其他类的成员函数声明为友元函数"><a href="#2、其他类的成员函数声明为友元函数" class="headerlink" title="2、其他类的成员函数声明为友元函数"></a>2、其他类的成员函数声明为友元函数</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;using namespace std;class Address;  &#x2F;&#x2F;提前声明Address类&#x2F;&#x2F;声明Student类class Student&#123;public:    Student(char *name, int age, float score);public:    void show(Address *addr);private:    char *m_name;    int m_age;    float m_score;&#125;;&#x2F;&#x2F;声明Address类class Address&#123;private:    char *m_province;  &#x2F;&#x2F;省份    char *m_city;  &#x2F;&#x2F;城市    char *m_district;  &#x2F;&#x2F;区（市区）public:    Address(char *province, char *city, char *district);    &#x2F;&#x2F;将Student类中的成员函数show()声明为友元函数    friend void Student::show(Address *addr);&#125;;&#x2F;&#x2F;实现Student类Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;void Student::show(Address *addr)&#123;    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;实现Address类Address::Address(char *province, char *city, char *district)&#123;    m_province &#x3D; province;    m_city &#x3D; city;    m_district &#x3D; district;&#125;int main()&#123;    Student stu(&quot;小明&quot;, 16, 95.5f);    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);    stu.show(&amp;addr);       Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);    pstu -&gt; show(paddr);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-2、友元类"><a href="#4-3-2、友元类" class="headerlink" title="4.3.2、友元类"></a>4.3.2、友元类</h3><p>友元类中的所有成员函数都是另外一个类的友元函数。</p><p>例如将类 B 声明为类 A的友元类，那么类B中的所有成员函数都是类A的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;using namespace std;class Address;  &#x2F;&#x2F;提前声明Address类&#x2F;&#x2F;声明Student类class Student&#123;public:    Student(char *name, int age, float score);public:    void show(Address *addr);private:    char *m_name;    int m_age;    float m_score;&#125;;&#x2F;&#x2F;声明Address类class Address&#123;public:    Address(char *province, char *city, char *district);public:    &#x2F;&#x2F;将Student类声明为Address类的友元类    friend class Student;private:    char *m_province;  &#x2F;&#x2F;省份    char *m_city;  &#x2F;&#x2F;城市    char *m_district;  &#x2F;&#x2F;区（市区）&#125;;&#x2F;&#x2F;实现Student类Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;void Student::show(Address *addr)&#123;    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;&#125;&#x2F;&#x2F;实现Address类Address::Address(char *province, char *city, char *district)&#123;    m_province &#x3D; province;    m_city &#x3D; city;    m_district &#x3D; district;&#125;int main()&#123;    Student stu(&quot;小明&quot;, 16, 95.5f);    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);    stu.show(&amp;addr);       Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);    pstu -&gt; show(paddr);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4、函数重载"><a href="#4-4、函数重载" class="headerlink" title="4.4、函数重载"></a>4.4、函数重载</h2><ul><li>函数重载是指同一个作用域内，一组具有不同参数列表的同名函数；</li><li>函数重载有效的解决了由于参数类型不同而造成的函数名的数量膨胀问题；</li></ul><p><font color=red><strong>函数的返回值类型与函数重载没有关系</strong></font>     </p><h3 id="4-4-1、C-语言不支持函数重载的原因"><a href="#4-4-1、C-语言不支持函数重载的原因" class="headerlink" title="4.4.1、C 语言不支持函数重载的原因"></a>4.4.1、C 语言不支持函数重载的原因</h3><p>C++在编译时会对函数进行重命名，而C语言则保留原始函数名。<br>C++函数重命名的规则是：**(返回值类型+)作用域 + 原始函数名 + 参数列表**     </p><ul><li><strong>作用域</strong>包括函数的命名空间和所属类；    </li><li><strong>返回值类型</strong>根据编译器的不同可加可不加；   </li></ul><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">using namespace test&#123;    int Calc::add(int a,int b); &#x3D;&gt; int_test_Calc_add_int_int&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>PS：函数重命名虽然可能带上返回值类型，但C++语法上并不会将返回值类型当做重载条件，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class B&#123;public:    int32_t data_b_;    void compare()    &#123;        std::cout &lt;&lt; &quot;from inherit class B call&quot; &lt;&lt; std::endl;    &#125;    int32_t compare()    &#123;        std::cout &lt;&lt; &quot;from inherit class B call&quot; &lt;&lt; std::endl;        return 0;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>compare重载就会报错</p><h3 id="4-4-2、const与函数重载"><a href="#4-4-2、const与函数重载" class="headerlink" title="4.4.2、const与函数重载"></a>4.4.2、const与函数重载</h3><p>判断B，C，D是否是函数重载？</p><pre class="line-numbers language-none"><code class="language-none">B:  int calcA(int a, int b);    int calcA(const int a, const int b);    C:  int calcA(int *a, int *b);    int calcA(int * const a, int * const b);  D:  int calcA(int *a, int *b);    int calcA(const int *a, const int * b);      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>函数重载时，是不会考虑参数本身的const修饰符</strong></font><br>比如B和C中cosnt都是修饰参数a，b本身的，所以不属于函数重载，而D中cosnt 是修饰int*，是函数重载。<br>B与C项中的形参本质上是按值传递，在函数体内形参只是实参的一个副本，做任何修改对实参都没有影响。</p><h3 id="4-4-3、overload、override、overwrite"><a href="#4-4-3、overload、override、overwrite" class="headerlink" title="4.4.3、overload、override、overwrite"></a>4.4.3、overload、override、overwrite</h3><p><font color=green><strong>overload重载</strong></font></p><ul><li>相同的范围（在同一个类中或同一个作用域中）；</li><li>函数名字相同；</li><li>参数不同；</li></ul><p><font color=green><strong>override覆盖</strong></font><br>是指派生类函数覆盖基类函数，特征是：</p><ul><li>不同的范围（分别位于派生类与基类）；</li><li>函数名字相同；</li><li>参数相同；</li><li>基类函数必须有virtual 关键字；</li></ul><p><font color=green><strong>overwrite重写/隐藏</strong></font><br>是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</p><ul><li>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏；</li><li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆)；</li></ul><h2 id="4-5、运算符重载"><a href="#4-5、运算符重载" class="headerlink" title="4.5、运算符重载"></a>4.5、运算符重载</h2><p>运算符重载的方式有两种：</p><ul><li>类成员函数方式；</li><li>友元函数方式；</li></ul><pre class="line-numbers language-none"><code class="language-none">class Step&#123;    private:    int num;    public:    Step(int num)&#123;this-&gt;num &#x3D; num;&#125;    Step&amp; operator ++();  &#x2F;&#x2F; 前自增    friend Step operator+(const Step &amp;p1, const Step &amp;p2);&#125;;Step&amp; Step::operator ++()&#123;    num++;    return *this;&#125;Step operator+(const Step &amp;p1, const Step &amp;p2)&#123;    return Step(p1.num + p2.num);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通常，单目运算符重载使用类成员函数形式，双目运算符重载使用友元函数形式；</li><li>但是()和[]必须使用类成员函数，&lt;&lt;和&gt;&gt;必须使用友元方式；</li><li>重载后的运算符不能改变操作数的个数和运算符优先级，所以运算符的参数类别不能有默认值；</li><li>不是所有运算符都能重载，详见<strong>C++零的1.11节</strong>；</li></ul><p><font color=purple>‘.*‘指向类成员的指针操作符,详见<strong>4.9.10</strong>节</font></p><h3 id="4-5-1、前自增和后自增运算符"><a href="#4-5-1、前自增和后自增运算符" class="headerlink" title="4.5.1、前自增和后自增运算符"></a>4.5.1、前自增和后自增运算符</h3><pre class="line-numbers language-none"><code class="language-none">class Step&#123;    private:    int num;    public:    Step(int num)&#123;this-&gt;num &#x3D; num;&#125;    Step&amp; operator ++();  &#x2F;&#x2F;前自增    Step operator ++(int);  &#x2F;&#x2F;后自增&#125;;Step&amp; Step::operator ++()&#123;    num++;    return *this;&#125;Step Step::operator ++(int)&#123;    Step temp &#x3D; *this;    ++*this;    return temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果只重载了前自增运算符，那么后自增操作会与前自增操作绑定，使两者的行为相同；</li><li>为了区分前自增和后自增运算符重载函数，后自增重载函数的参数列表需要增加一个int以示区别，在使用中完全可以忽略这个参数，编译器会对其进行特殊处理；</li></ul><h3 id="4-5-2、函数对象"><a href="#4-5-2、函数对象" class="headerlink" title="4.5.2、函数对象"></a>4.5.2、函数对象</h3><p>可以通过重载函数调用符operator()实现函数对象，详见<strong>4.9.7</strong>节</p><h3 id="4-5-3、operator-赋值运算符重载"><a href="#4-5-3、operator-赋值运算符重载" class="headerlink" title="4.5.3、operator=赋值运算符重载"></a>4.5.3、operator=赋值运算符重载</h3><ul><li><font color=red><strong>operator=返回reference to *this</strong></font>   </li></ul><p>对于赋值操作，通常需要支持链式操作：</p><pre class="line-numbers language-none"><code class="language-none">int x,y,z;x&#x3D;y&#x3D;z&#x3D;15;x&#x3D;(y&#x3D;(z&#x3D;15));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里15首先被赋值给z，然后将其结果再赋值给y，为了实现”链式赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参，这是class实现赋值操作符应该遵守的协议：</p><pre class="line-numbers language-none"><code class="language-none">class Wideget&#123;    public;    ......        Wideget&amp; operator&#x3D;(const Widget &amp;rhs)    &#123;        ......        return *this;    &#125;        Wideget&amp; operator+&#x3D;(const Widget &amp;rhs)    &#123;        ......        return *this;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个规则，对于内置类型和标准容器string、vector等都是默认支持的。   </p><p><font color=red><strong>“自我赋值”和”异常安全”</strong></font><br>在赋值操作时可能会出现自己赋值给自己的情况，比如：</p><pre class="line-numbers language-none"><code class="language-none">class Bitmap &#123;    ......&#125;class Widget&#123;    ......    private:    Bitmap *pb;   &#x2F;&#x2F;动态内存&#125;&#x2F;&#x2F; 一份不安全的operator&#x3D;实现Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)&#123;    delete pb;    pb &#x3D; new Bitmap(*rhs.bp);    return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当出现自我赋值时，*this与rhs是同一个对象，operator=中delete pb的操作使得pb变成一个指向被删除的Bitmap的指针，第二步的new操作时，rhs.pb已经是一个不确定的指针了，这样是危险的。改进方法如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 不具备&quot;异常安全&quot;的operator&#x3D;实现Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)&#123;    if(this &#x3D;&#x3D; &amp;rhs) return *this;    delete pb;    pb &#x3D; new Bitmap(*rhs.bp);    return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一步虽然进行了自我检查，但仍然存在问题，因为，在delete pb之后，new操作可能出现异常（内存不足或Bitmap构造异常），最终会导致pb变成一个不确定的指针<br><font color=green>在C语言中使用 malloc/calloc 等分配内存的函数时，可以通过检查其返回值判断内存申请是否成，但C++ 里，如果 new 分配内存失败，默认是抛出异常的，会自动跳过后面的代码。</font>   </p><p>改进方式如下：</p><pre class="line-numbers language-none"><code class="language-none">Widget &amp; Widget::operator&#x3D;(const Widget &amp;rhs)&#123;    if(this &#x3D;&#x3D; &amp;rhs) return *this;    Bitmap *temp &#x3D;pb;    pb &#x3D; new Bitmap(*rhs.bp);    delete temp;    return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一步是自我检查，第二步是备份一个this的pb，即使第三步的new异常，this中的pb仍然保持不变，是安全的的</p><h2 id="4-9、其他"><a href="#4-9、其他" class="headerlink" title="4.9、其他"></a>4.9、其他</h2><h3 id="4-9-1、is-a和has-a"><a href="#4-9-1、is-a和has-a" class="headerlink" title="4.9.1、is-a和has-a"></a>4.9.1、is-a和has-a</h3><ul><li><p>继承类与派生类之间是is-a关系，比如黑色的马是马的一种；</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Horse&#123;    ......&#125;;class WitheHorse : public Horse&#123;    ......&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>汽车与轮胎之间是has-a关系</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Tyre&#123;    ......&#125;;class Car&#123;    class Tyre;    ......&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>友元的关系是单向的，如果声明了类 B 是类 A 的友元类，不等于类 A是类B的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员；</p></li><li><p>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类；</p></li><li><p>友元关系不能继承，基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类，PS：   </p><ul><li>不能继承是指派生类自身的成员函数不能继承友元权限；</li><li>但派生类可以通过基类的接口间接访问友元关系，比如派生类继承的基类成员函数<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt; using namespace   std; class B; class A &#123; int a; public: A(int x&#x3D;0) &#123; a&#x3D;x; &#125; friend class B; &#125;; class B &#123; int b; public: void fun(A&amp; ob)&#123; cout &lt;&lt; ob.a &lt;&lt; endl;&#125; &#125;;  class C:public B&#123; public: &#x2F;&#x2F;void fun2(A&amp; ob)&#123; cout &lt;&lt;ob.a &lt;&lt;endl;&#125;   &#x2F;&#x2F;派生类新加的函数却不能访问A，此句会报错&#125;;  void   main() &#123; A a(55); C c; c.fun(a); &#x2F;&#x2F;C是B的派生类   通过基类B的函数fun仍然可以访问 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="4-9-2、const之于函数重载"><a href="#4-9-2、const之于函数重载" class="headerlink" title="4.9.2、const之于函数重载"></a>4.9.2、const之于函数重载</h3><ul><li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参，则这个时候无论加不加const对实参不会产生任何影响；</li><li>但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。所以，引用、指针传递具备const重载性，而值传递的const不具备重载性；</li></ul><h3 id="4-9-3、类成员初始化"><a href="#4-9-3、类成员初始化" class="headerlink" title="4.9.3、类成员初始化"></a>4.9.3、类成员初始化</h3><p>1、类成员初始化主要有两种方式：   </p><ul><li>默认初始化：在构造函数中，未进入构造函数代码块之前，会对类成员进行默认初始化（编译器会在编译期生成相应代码，在运行期执行）</li><li>列表初始化：在构造函数中，未进入构造函数代码块之前，为类成员分配内存空间之时，且在冒号后面存在类成员的赋值表达式；</li></ul><p><strong>==2、列表初始化顺序==</strong><br>第一顺序是类类型成员，然后是普通类型成员，然后由各自的声明顺序决定，并不是冒号后的初始化列表中的顺序。</p><p><strong>==3、必须使用列表初始化的情况==</strong></p><ul><li>初始化引用成员；</li><li>初始化常量成员；</li><li>当发生基类构造函数调用时，且其拥有一组参数；</li><li>当发生类成员构造函数调用时，且其拥有一组参数；</li></ul><h3 id="4-9-5、只能动态创建或只能静态创建类对象"><a href="#4-9-5、只能动态创建或只能静态创建类对象" class="headerlink" title="4.9.5、只能动态创建或只能静态创建类对象"></a>4.9.5、只能动态创建或只能静态创建类对象</h3><p>类对象的创建方式有两种：</p><ul><li>静态创建，例如ClassA a<br>静态创建一个对象就是由编译器在栈空间上分配内存，直接调用构造函数</li><li>动态创建，例如ClassA *pa = new ClassA()<br>动态创建就是由new操作符在堆空间上分配内存，分为两步：<ul><li>operator new()在堆上搜索并申请一块空间；</li><li>在申请的这块堆上调用构造函数创建类对象</li></ul></li></ul><h4 id="1、只静态创建"><a href="#1、只静态创建" class="headerlink" title="1、只静态创建"></a>1、只静态创建</h4><p>就是关闭动态创建类对象的途径，只需将new、delete操作符声明为private即可</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A  &#123;  private:       void* operator new(size_t t)&#123;&#125;          &#x2F;&#x2F;注意函数的第一个参数和返回值都是固定的       void operator delete(void* ptr)&#123;&#125;       &#x2F;&#x2F;重载了new就需要重载delete  public:       A()&#123;&#125;       ~A()&#123;&#125;  &#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>且其派生类也无法动态创建对象</p><h4 id="2、只动态创建"><a href="#2、只动态创建" class="headerlink" title="2、只动态创建"></a>2、只动态创建</h4><p>不能静态分配，即不能直接调用类的构造函数。   </p><p>怎样才能实现类的构造函数不能被直接调用呢？首先想到的就是将类的构造函数设为private，这样就无法在类外部调用构造函数来构造对象了，只能使用new运算符动态创建。但是，这种做法行不通。因为new运算符过程分为两步，C++提供new运算符的重载，其实只允许重载operator new()函数，而operator new()函数用于内存分配，无法提供构造函数功能。因此，将构造函数设为private不可行。    </p><p>从另外一个角度分析，对象静态分配时，是由编译器调用构造函数在栈空间中构造对象。当对象使用完毕，编译器又会调用析构函数来释放栈空间中的类对象。如果编译器无法调用类的析构函数，会怎样呢？其实，编译器在为类对象分配栈空间时，同时也会检查类的析构函数的访问性（其实不光是析构函数，只要是非静态的函数，编译器都会进行检查）。如果类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存。    </p><p>因此，可以将析构函数设为private，这样就无法在栈上建立类对象了。实现如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A  &#123;  public:       A()&#123;&#125;       void destory()&#123;delete this;&#125;  private:       ~A()&#123;&#125;  &#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法虽然能实现只能动态建立对象，但是有一个缺点：无法实现继承。因为如果A作为基类的话，则析构函数通常要设为virtual，然后在子类中被重写，以实现多态。因此析构函数不能设为private。    </p><p>将析构函数设为protected即可，这样类外无法访问protected成员，同时也可解决继承问题</p><h3 id="4-9-6、对象调用成员变量、成员函数的原理"><a href="#4-9-6、对象调用成员变量、成员函数的原理" class="headerlink" title="4.9.6、对象调用成员变量、成员函数的原理"></a>4.9.6、对象调用成员变量、成员函数的原理</h3><p>先看一个例子：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base&#123;public:    void print()&#123;std::cout &lt;&lt; m &lt;&lt; std::endl;&#125;    void show()&#123;std::cout &lt;&lt; &quot;Base class&quot; &lt;&lt; std::endl;&#125;    int m;&#125;;int main()&#123;    Base *pBase &#x3D; nullptr;    pBase-&gt;print();    pBase-&gt;show();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果会怎样？  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">pBase-&gt;print();  &#x2F;&#x2F; 报错pBase-&gt;show();  &#x2F;&#x2F; 正常执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>指针pBase为nullptr，在没有构造Base对象的情况下它是如何调用show函数、print函数又为何会报错？这就要看一看在编译期类发生了什么：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 伪代码class Base&#123;    int m;&#125;；void _Base_print(Base *this)&#123;    ......    this-&gt;m;    ......&#125;void _Base_show(Base *this)&#123;    ......    ......    ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在编译期，除了虚函数，其他的成员方法都被静态编译了，函数地址已经确定；  </li><li>对非虚函数的成员函数调用，并不需要this指针，与对象是否构造自然就无关联了；   </li><li>只有在访问对象的非静态成员时才会检查this指针，如果为null则报错：<ul><li>这就引出另一个问题，如果上述例子中pBase未初始化，pBase-&gt;print()调用不会报错，只是此时对象的成员m是个不确定值；</li></ul></li><li>虚函数的调用是通过虚表指针vptr指向虚表vtable进而动态绑定，而vptr是在构造函数执行期间进行的初始化，故虚函数的动态绑定依赖于对象的构造；</li></ul><h3 id="4-9-7、函数对象"><a href="#4-9-7、函数对象" class="headerlink" title="4.9.7、函数对象"></a>4.9.7、函数对象</h3><p>从概念上来说，函数对象是可以如函数一样使用的对象；从实现上来说，函数对象是重载了函数调用符operator()的类对象</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;&#x2F;&#x2F; struct that behaves as a unary functiontemplate &lt;typename elementType&gt;struct DisplayElement&#123;    void operator () (const elementType&amp; element) const    &#123;        cout &lt;&lt; element &lt;&lt; &#39; &#39;;    &#125;&#125;;int main ()&#123;    vector &lt;int&gt; vecIntegers;    for (int nCount &#x3D; 0; nCount &lt; 10; ++ nCount)        vecIntegers.push_back (nCount);    list &lt;char&gt; listChars;    for (char nChar &#x3D; &#39;a&#39;; nChar &lt; &#39;k&#39;; ++nChar)        listChars.push_back (nChar);    cout &lt;&lt; &quot;Displaying the vector of integers: &quot; &lt;&lt; endl;    &#x2F;&#x2F; Display the array of integers    for_each ( vecIntegers.begin ()    &#x2F;&#x2F; Start of range          , vecIntegers.end ()        &#x2F;&#x2F; End of range          , DisplayElement &lt;int&gt; () ); &#x2F;&#x2F; Unary function object    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; &quot;Displaying the list of characters: &quot; &lt;&lt; endl;    &#x2F;&#x2F; Display the list of characters    for_each ( listChars.begin ()        &#x2F;&#x2F; Start of range          , listChars.end ()        &#x2F;&#x2F; End of range          , DisplayElement &lt;char&gt; () );&#x2F;&#x2F; Unary function object    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、优势"><a href="#1、优势" class="headerlink" title="1、优势"></a>1、优势</h4><ul><li>对象可以在内部修改而不用改动外部接口，因此设计更灵活，更富有弹性；</li><li>函数对象具备存储先前调用结果的优势，利用类的成员实现存储；</li><li>函数对象会被编译器以内联形式实现，从而更进一步增强了性能；</li></ul><h3 id="4-9-8、static静态成员变量与函数"><a href="#4-9-8、static静态成员变量与函数" class="headerlink" title="4.9.8、static静态成员变量与函数"></a>4.9.8、static静态成员变量与函数</h3><ul><li>static成员变量只属于类，不属于任何对象，故static成员变量不占据对象内存空间；</li><li>对于类成员而言，static关键字只需在声明处添加，定义处不用添加；</li><li>static成员函数只能访问static成员变量；</li><li>详见<strong>7.1</strong>节；</li></ul><h3 id="4-9-9、类的内存空间占用"><a href="#4-9-9、类的内存空间占用" class="headerlink" title="4.9.9、类的内存空间占用"></a>4.9.9、类的内存空间占用</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#pragma pack(1)class Empty  &#x2F;&#x2F; 只占1byte，用于占位符&#123;&#125;;class Human  &#x2F;&#x2F; members &#x3D; int32_t&#123;public:    Human(int32_t age):age_(age)&#123;&#125;        int32_t getAge()    &#123;        std::cout &lt;&lt; &quot;I am &quot; &lt;&lt; age_  &lt;&lt; &quot; years old&quot; &lt;&lt; std::endl;    &#125;protected:    int32_t age_;&#125;;class Children : public Human &#x2F;&#x2F; members &#x3D; int32_t + int32_t&#123;public:   Children(int32_t age):Human(age)&#123;&#125;   int32_t scores_;&#125;;class Student : public virtual Human  &#x2F;&#x2F; members &#x3D; int32_t + int32_t + int64_t(point is 64bit)&#123;public:   Student(int32_t age):Human(age)&#123;&#125;   int32_t class_no_;&#125;;class Expressor : public Human  &#x2F;&#x2F; members &#x3D; int32_t + int64_t(point is 64bit)&#123;public:    Expressor(int32_t age):Human(age)&#123;&#125;    virtual void who()    &#123;        std::cout &lt;&lt; &quot;I am is an expresser&quot; &lt;&lt; std::endl;    &#125;&#125;;class Worker : public Human  &#x2F;&#x2F; members &#x3D; int32_t&#123;public:    Worker(int32_t age):Human(age)&#123;&#125;    static int32_t company_no_;&#125;;int32_t Worker::company_no_ &#x3D; 0;int main()&#123;    int32_t *ptr;    std::cout &lt;&lt; &quot;point size is: &quot; &lt;&lt;  sizeof(ptr) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;empty class size is: &quot; &lt;&lt; sizeof(Empty) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;human class size is: &quot; &lt;&lt; sizeof(Human) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;derived children class size is: &quot; &lt;&lt; sizeof(Children) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;derived and virtual inheried Student class size is: &quot; &lt;&lt; sizeof(Student) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;derived and virtual function Expressor class size is: &quot; &lt;&lt; sizeof(Expressor) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;derived and static member Worker class size is: &quot; &lt;&lt; sizeof(Worker) &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">point size is: 8empty class size is: 1human class size is: 4derived children class size is: 8derived and virtual inheried Student class size is: 16derived and virtual function Expressor class size is: 12derived and static member Worker class size is: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-9-10、’-’指向类成员的指针运算符"><a href="#4-9-10、’-’指向类成员的指针运算符" class="headerlink" title="4.9.10、’.*’指向类成员的指针运算符"></a>4.9.10、’.*’指向类成员的指针运算符</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std; class Testpm &#123;public:   void _func1() &#123; cout &lt;&lt; &quot;_func1\n&quot;; &#125;   int _num;&#125;; &#x2F;&#x2F; 定义指针pmfunc and pmdate，分别指向成员函数_func1()以及成员变量_num。void (Testpm::*pmfunc)() &#x3D; &amp;Testpm::_func1;int Testpm::*pmdata &#x3D; &amp;Testpm::_num; int main() &#123;   Testpm aTestpm;   Testpm *pTestpm &#x3D; new Testpm;     &#x2F;&#x2F; 访问成员函数   (aTestpm.*pmfunc)();   (pTestpm-&gt;*pmfunc)();      &#x2F;&#x2F; 访问成员数据   aTestpm.*pmdata &#x3D; 1;   pTestpm-&gt;*pmdata &#x3D; 2;    cout  &lt;&lt; aTestpm.*pmdata &lt;&lt; endl         &lt;&lt; pTestpm-&gt;*pmdta &lt;&lt; endl;   delete pTestpm;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：  </p><pre class="line-numbers language-none"><code class="language-none">_func1_func112<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-9-11、对象构造时的线程安全"><a href="#4-9-11、对象构造时的线程安全" class="headerlink" title="4.9.11、对象构造时的线程安全"></a>4.9.11、对象构造时的线程安全</h3><p>构造期间不要泄漏this指针：</p><ul><li>不要在构造函数中注册任何回调函数；</li><li>不要在构造函数中将this指针传递给其他对象(子对象除外)，更不能传递给跨线程的对象；</li></ul><p>这是因为构造函数执行期间对象尚未初始化完成，此时别的对象可能访问一个半成品，导致难以预料的行为。</p><h3 id="4-9-12、对象销毁时的线程安全问题"><a href="#4-9-12、对象销毁时的线程安全问题" class="headerlink" title="4.9.12、对象销毁时的线程安全问题"></a>4.9.12、对象销毁时的线程安全问题</h3><p>如果互斥器作为成员，它可以起到保护函数临界区的作用，但是析构函数却破坏了这一规则，因为它会把互斥器析构掉：</p><pre class="line-numbers language-none"><code class="language-none">Foo:~FOO()&#123;    MutexLockGuard(mutex_)    &#x2F;&#x2F; delete,free etc  (1)&#125;FOO::update()&#123;    MutexLockGuard(mutex_)  &#x2F;&#x2F; (2)    &#x2F;&#x2F; make use  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假如线程A、B都能看到Foo对象x</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; thread Adelete x;x&#x3D;NULL;&#x2F;&#x2F; thread Bif(x)&#123;    x.update();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程A执行到了析构函数的(1)处，已经持有了互斥锁，而B已经通过了if(x)检查，阻塞在了(2)处。<br>当B重新获得mutex_时mutex_已经被析构释放了，就会发生不确定行为，这个例子同时也说明了:  </p><ul><li>delete后将指针置为NULL并不能防止二次释放;</li><li>类成员mutex不能保护对象的析构；</li></ul><h1 id="5、引用"><a href="#5、引用" class="headerlink" title="5、引用"></a>5、引用</h1><p>引用就是某一目标的别名，这个目标可以是左值，对应的就是左值引用，若目标是右值，对应的就是右值引用</p><h2 id="5-1、左值与右值"><a href="#5-1、左值与右值" class="headerlink" title="5.1、左值与右值"></a>5.1、左值与右值</h2><ul><li>C++11中所有的值必属于左值、右值两者之一；</li><li>C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值<br>,举个例子:<ul><li>int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作也是不允许的；</li></ul></li><li>C++11对C++98中的右值进行了扩充,C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）:<ul><li>纯右值，指的是临时变量包括表达式的值、函数返回值、原始字面量、lambda表达式等；</li><li>将亡值则是C++11新增的与右值引用相关，通常是将要被移动的对象，比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值</li></ul></li></ul><h2 id="5-2、引用的特点"><a href="#5-2、引用的特点" class="headerlink" title="5.2、引用的特点"></a>5.2、引用的特点</h2><ul><li>引用只是一个目标的别名，不分配内存空间；</li><li>引用不能为空，必须要初始化；</li><li>引用只能初始化一次，且初始化之后不能再成为其他目标的别名；</li><li>右值引用不接受左值，左值引用通常不能接受右值，但常量左值引用是个例外，它是万能引用，可以接受常量左值，非常量左值、右值；</li><li><strong>==具名右值引用视作左值==</strong><pre class="line-numbers language-C" data-language="C"><code class="language-C">void PrintValue(int&amp; i)&#123;    cout&lt;&lt;&quot;left&quot;&lt;&lt;endl;&#125;void PrintValue(int&amp;&amp; i)&#123;    cout&lt;&lt;&quot;right&quot;&lt;&lt;endl;&#125;void Forward(int&amp;&amp; i)&#123;    PrintValue(i);&#125;&#x2F;&#x2F; 当调用Forward(2)时，调用的是PrintValue(int&amp; i)，因为此时原始字面量2变成了具名变量i，即左值引用，输出结果便是&quot;left&quot;。int &amp;&amp;var01 &#x3D; 20;  &#x2F;&#x2F; OK，右值引用int &amp;&amp;var02 &#x3D; var01;  &#x2F;&#x2F; error，var01虽然是字面常量20的右值引用，但在当前表达式中它是具名变量，就变成了左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="5-3、左值引用"><a href="#5-3、左值引用" class="headerlink" title="5.3、左值引用"></a>5.3、左值引用</h2><h2 id="5-4、右值引用"><a href="#5-4、右值引用" class="headerlink" title="5.4、右值引用"></a>5.4、右值引用</h2><p>**==对右值引用的理解==**：<br>右值引用本身只是一种类型而已，它真正的作用是在与右值引用相关的操作，例如移动构造函数、移动赋值运算符等。对占用内存较大的类对象，比如内含指向较大内存空间的成员指针、容器等，当它们作为临时值时，离开表达式之会便会被销毁，右值引用可以延长它们的生命周期、避免内存的拷贝(需要根据场景用户自行管理内存)：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A&#123;public:    A():ptr_m_(new int(10 + construct_count))&#123;        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;    &#125;    static int construct_count;    int *ptr_m_;    ~A()    &#123;        delete ptr_m_;        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;A get()&#123;    A a;    return a; &#125;int main()&#123;    A &amp;&amp;a01 &#x3D; get();  &#x2F;&#x2F; a01作为右值引用延长了get返回的类A临时对象的生命周期，避免了一次类A对象的构造过程    A a02 &#x3D; get();  &#x2F;&#x2F; 调用类A的移动构造函数，但成员指针ptr_m_默认是浅拷贝，用户需要根据实际场景决定ptr_m_指向的内存空间在两个对象之间是浅拷贝还是深拷贝，通常的做法是用户在移动构造函数内部自行实现设置原始对象ptr_m_&#x3D;nullptr&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5、std-move及移动拷贝构造函数"><a href="#5-5、std-move及移动拷贝构造函数" class="headerlink" title="5.5、std::move及移动拷贝构造函数"></a>5.5、std::move及移动拷贝构造函数</h2><ul><li>std::move的作用是将左值转化为右值（严格意义上来说并不是转化，而是左值作为std::move的参数，然后返回其右值形式），用于实现目标对象右值引用的相关操作，比如移动拷贝构造函数的调用、右值引用的重载函数等，对左值本身并无任何实质性操作；  </li><li>std::move只是将原始对象左值转化为目的对象右值，至于原始对象与目标对象之间存在何种关联，由移动拷贝构造函数、右值引用的重载函数等的具体实现而定；</li><li>std::move的操作不会发生内存的搬迁或者内存拷贝。<br>示例：<pre class="line-numbers language-C" data-language="C"><code class="language-C">class A&#123;public:    A():ptr_m_(new int(10 + construct_count))&#123;        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;    &#125;    static int construct_count;    int *ptr_m_;    ~A()    &#123;        delete ptr_m_;        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    A a01;    A &amp;&amp;a02 &#x3D; std::move(a01);    A a03 &#x3D; std::move(a01);    std::cout &lt;&lt; &quot;before: &quot; &lt;&lt;*(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a03.ptr_m_) &lt;&lt; std::endl;    *(a01.ptr_m_) &#x3D; 20;    std::cout &lt;&lt; &quot;now: &quot; &lt;&lt;*(a01.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a02.ptr_m_) &lt;&lt; &quot; &quot; &lt;&lt; *(a03.ptr_m_) &lt;&lt; std::endl;        std::string str01 &#x3D; &quot;hello&quot;;    std::vector&lt;std::string&gt; vec01;    vec01.push_back(str01);    vec01.push_back(std::move(str01));    std::cout &lt;&lt; &quot;class string before: &quot;;    for(auto &amp;iter : vec01)    &#123;        std::cout &lt;&lt; iter &lt;&lt; &quot; &quot;;    &#125;    str01 &#x3D; &quot;hello_world&quot;;    std::cout &lt;&lt; std::endl &lt;&lt; &quot;now: &quot;;    for(auto &amp;iter : vec01)    &#123;        std::cout &lt;&lt; iter &lt;&lt; &quot; &quot;;    &#125;        std::cout &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>运行结果：<pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 1before: 10 10 10now: 20 20 20class string before: hello hello now: hello hello destructor*** Error in &#96;.&#x2F;main&#39;: double free or corruption (fasttop): 0x0000000001288c20 ***&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7fe157eee7e5]&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7fe157ef737a]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>class A：<br>对于a03，std::move仅仅是返回a01的右值形式，进而调用class A的移动拷贝构造函数。由于class A使用的是默认移动拷贝构造函数，对于成员变量ptr_m_是直接浅拷贝，故会a01、a03会重复delete，error。    </li></ul><p>std::string:<br>第一个push_back调用的是std::string类的普通拷贝构造函数<br>第二个push_back调用的是std::string类的移动拷贝构造函数，其中实现了成员char数组的深拷贝操作，所以不会出现重复delete的错误，而且之后修改str01也并不会影响vector内的元素</p><h3 id="5-5-1、移动拷贝构造函数"><a href="#5-5-1、移动拷贝构造函数" class="headerlink" title="5.5.1、移动拷贝构造函数"></a>5.5.1、移动拷贝构造函数</h3><h4 id="1、设计初衷"><a href="#1、设计初衷" class="headerlink" title="1、设计初衷"></a>1、设计初衷</h4><p>在用对象a初始化对象b时存在这样的场景：初始化表达式结束之后对象a就不再被使用。但是对象a在被析构之前仍然存在，既然构造函数就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了构造函数引起的新的空间分配操作，大大降低了构造的成本与效率，移动拷贝构造函数就此应运而生。   std::move可以为移动拷贝构造函数提供某些实际场景的使用。</p><h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><ul><li>普通拷贝构造函数中，对于指针，一定要采用深层复制，否则会出现重复delete的问题。而移动构造函数中，对于指针采用浅复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要在移动构造函数的实现中将其中一个指针置为NULL即可；</li><li>移动构造函数的参数和普通拷贝构造函数不同，普通拷贝构造函数的参数是左值引用，而移动构造函数是右值引用。意味着，向移动构造函数传递的实参是一个纯右值或者将亡值。也就是说，只有右值实参才会触发移动构造函数的调用；</li></ul><h2 id="5-6、右值引用与类型推导：引用折叠、未决议引用universal-reference"><a href="#5-6、右值引用与类型推导：引用折叠、未决议引用universal-reference" class="headerlink" title="5.6、右值引用与类型推导：引用折叠、未决议引用universal reference"></a>5.6、右值引用与类型推导：引用折叠、未决议引用universal reference</h2><p>引用折叠与未决议引用是同一概念，发生在类型推导场合：<br>模板参数类型推导、auto自动类型推导，且声明形式仅为T&amp;&amp;，不加任何类型修饰语</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; **********************模板参数template&lt;typename T&gt;void func02(T&amp;&amp; param);  &#x2F;&#x2F; 未决议引用func02(10);  &#x2F;&#x2F;param是右值int x &#x3D; 10;func02(x);  &#x2F;&#x2F;param是左值template&lt;typename T&gt;void func03(const T&amp;&amp; param);  &#x2F;&#x2F; 形参包含额外修饰语，故是右值引用，不是未决议引用func03(10);  &#x2F;&#x2F;param是右值int var01 &#x3D; 10;func03(var01);  &#x2F;&#x2F; 报错，左值var01不能绑在右值引用param上template&lt;typename T&gt;void func03(std::vector&lt;T&gt;&amp;&amp; param);  &#x2F;&#x2F; 形参包含额外修饰语，故是右值引用，不是未决议引用&#x2F;&#x2F; **********************auto类型推导int var02 &#x3D; 10;auto &amp;&amp;var03 &#x3D; 30;  &#x2F;&#x2F; var03为右值引用，未决议引用auto &amp;&amp;var04 &#x3D; var02;  &#x2F;&#x2F; var04为左值引用，未决议引用const auto &amp;&amp;var05 &#x3D; var02;  &#x2F;&#x2F; 报错，包含额外修饰符，var05是右值引用，不能绑定左值var02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用折叠规则：</p><table><thead><tr><th>实参</th><th>形参</th><th>result</th></tr></thead><tbody><tr><td>&amp;</td><td>&amp;</td><td>&amp;</td></tr><tr><td>&amp;</td><td>&amp;&amp;</td><td>&amp;</td></tr><tr><td>&amp;&amp;</td><td>&amp;</td><td>&amp; // 错误，非常量左值不能接收右值</td></tr><tr><td>&amp;&amp;</td><td>&amp;&amp;</td><td>&amp;&amp;</td></tr></tbody></table><p>可以看出任意一个引用为左值引用时结果均为左值，只有在两个引用均为右值引用时才是右值引用。</p><h2 id="5-7、std-forward完美转发"><a href="#5-7、std-forward完美转发" class="headerlink" title="5.7、std::forward完美转发"></a>5.7、std::forward完美转发</h2><p>右值引用类型在发生自动类型推导时的不确定性，可以通过std::forward解决。<br>首先要明白std::forward完美转发的对象实际上是实参的类型</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;void PrintT(int&amp; t)&#123;std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;&#125;template &lt;typename T&gt;void PrintT(T&amp;&amp; t)&#123;std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;&#125;template &lt;typename T&gt;void TestForward(T&amp;&amp; v)&#123;PrintT(v);PrintT(std::forward&lt;T&gt;(v));PrintT(std::move(v));&#125;void Test()&#123;TestForward(1);int x &#x3D; 1;TestForward(x);TestForward(std::forward&lt;int&gt;(x));&#125;int main(void)&#123;Test();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lvaluervaluervaluelvaluelvaluervaluelvaluervaluervalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TestForward的前两次调用很容易理解，对于第三次调用std::forward<int>(x)就很好的阐释了完美转发的对象实际上是实参，局部变量x在std::forward语句中扮演的是形参的角色，转发的是字面量’1’的类型。     </p><p><font color=red><strong>疑问</strong></font><br>修改后的代码运行结果为何是下面这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;void PrintT(int&amp; t)&#123;std::cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; std::endl;&#125;template &lt;typename T&gt;void PrintT(T&amp;&amp; t)&#123;std::cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; std::endl;&#125;template &lt;typename T&gt;void TestForward(T&amp;&amp; v)&#123;PrintT(v);PrintT(std::forward&lt;T&gt;(v));PrintT(std::move(v));&#125;void Test()&#123;int x &#x3D; 1;int y &#x3D; x;TestForward(std::forward&lt;int&gt;(y));&#125;int main(void)&#123;Test();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lvaluervaluervalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>std::forward<int>(y)中的y作为形参的话，它的实参x是个左值，为何std::forward<int>(y)转发结果确实右值？</p><h2 id="5-8、万能引用：右值引用与常量左值引用"><a href="#5-8、万能引用：右值引用与常量左值引用" class="headerlink" title="5.8、万能引用：右值引用与常量左值引用"></a>5.8、万能引用：右值引用与常量左值引用</h2><p>万能引用通常是指右值引用在发生类型推导时的使用场景：模板类型推导、auto自动类型推导。<br>且声明形式仅为T&amp;&amp;，不带任何修饰符</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;void func01(T&amp;&amp; num)&#123;    std::cout &lt;&lt; num &lt;&lt; std::endl;&#125;int main()&#123;    int32_t i &#x3D; 10;    func01(i);  &#x2F;&#x2F; OK，接收左值i    func01(20);  &#x2F;&#x2F; OK，接收右值20    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板函数func01在是实例化时即可接收左值也可接收右值，称作万能引用。<br>若T&amp;&amp;改成const T&amp;&amp;则不是万能引用，只能接收右值</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;void func01(const T&amp;&amp; num)&#123;    std::cout &lt;&lt; num &lt;&lt; std::endl;&#125;int main()&#123;    int32_t i &#x3D; 10;    func01(i);  &#x2F;&#x2F; error，不接收左值i    func01(20);  &#x2F;&#x2F; OK，接收右值20    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>引申</strong><br>若按照是否能同时接收左值、右值到规则，那么常量左值引用也可称作万能引用</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">template&lt;typename T&gt;void func01(const T&amp; num)&#123;    std::cout &lt;&lt; num &lt;&lt; std::endl;&#125;int main()&#123;    int32_t i &#x3D; 10;    func01(i);  &#x2F;&#x2F; OK，接收左值i    func01(20);  &#x2F;&#x2F; OK，接收右值20    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-9、引用作为函数返回值"><a href="#5-9、引用作为函数返回值" class="headerlink" title="5.9、引用作为函数返回值"></a>5.9、引用作为函数返回值</h2><ul><li>引用作为函数返回值时，需要在函数定义和声明处添加&amp;；</li><li>引用作为函数返回值的最大好处是可以避免返回值的临时变量生成</li></ul><p>普通函数调用时返回值的内存走向：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int func()&#123;    int local_a;    return lcoal_a;&#125;int obj_a &#x3D; func();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE7391efdff74cc063e907f9705fdfef84/38326" alt="image05"></p><ul><li><p>避免返回临时变量的引用<br>语法上可以返回临时变量的引用，但这样的操作很危险，因为在离开函数作用域之后函数体内的临时变量就会消亡，此时它的引用就是一块未定义内存空间，会引发不可预知行为。通常情况下编译器会抛出warning：返回临时变量的引用不被允许</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A&#123;public:    A():value_(10)&#123;        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;    &#125;    static int construct_count;    &#x2F;&#x2F;int *ptr_m_;    int value_;    ~A()    &#123;        &#x2F;&#x2F;delete ptr_m_;        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;A global_a;int A::construct_count &#x3D; 0;A&amp; getLeftLocal()&#123;     A local_a;    return local_a;&#125;A&amp;&amp; getRightLocal()&#123;     A local_a;    return std::move(local_a);&#125;int main()&#123;    A a02 &#x3D; getLeftLocal();    A a04 &#x3D; getRightLocal();    eturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译期间就会报错：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">move_cpye.cpp: In function &#39;A&amp; getLeftLocal()&#39;:move_cpye.cpp:15:8: warning: reference to local variable &#39;local_a&#39; returned [-Wreturn-local-addr]      A local_a;        ^move_cpye.cpp: In function &#39;A&amp;&amp; getRightLocal()&#39;:move_cpye.cpp:27:29: warning: function may return address of local variable [-Wreturn-local-addr]     return std::move(local_a);                             ^move_cpye.cpp:26:8: note: declared here      A local_a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回全局变量、局部静态变量的引用</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class A&#123;public:    A():value_(10)&#123;        std::cout &lt;&lt; &quot;construct count: &quot; &lt;&lt; ++A::construct_count &lt;&lt; std::endl;    &#125;    static int construct_count;    &#x2F;&#x2F;int *ptr_m_;    int value_;    ~A()    &#123;        &#x2F;&#x2F;delete ptr_m_;        std::cout &lt;&lt; &quot;destructor&quot; &lt;&lt; std::endl;    &#125;&#125;;A global_a;int A::construct_count &#x3D; 0;A&amp; getLeftGlobal()&#123;    return global_a;&#125;A&amp;&amp; getRightGlobal()&#123;    return std::move(global_a);&#125;int main()&#123;    A a01 &#x3D; getLeftGlobal();  &#x2F;&#x2F; 调用普通拷贝构造函数    A &amp;a02 &#x3D; getLeftGlobal();  &#x2F;&#x2F; 不调用构造函数    A a03 &#x3D; getRightGlobal();  &#x2F;&#x2F; 调用移动拷贝构造函数    A &amp;&amp;a04 &#x3D; getRightGlobal();  &#x2F;&#x2F; 不调用构造函数    std::cout &lt;&lt; &quot;a01 &#x3D; &quot; &lt;&lt; a01.value_ &lt;&lt; &quot;\na02 &#x3D; &quot; &lt;&lt; a02.value_ &lt;&lt; &quot;\na03 &#x3D; &quot; &lt;&lt; a03.value_ &lt;&lt; &quot;\na04 &#x3D; &quot; &lt;&lt; a04.value_ &lt;&lt; std::endl;        global_a.value_ &#x3D; 33;    std::cout &lt;&lt; &quot;after update:&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;a01 &#x3D; &quot; &lt;&lt; a01.value_ &lt;&lt; &quot;\na02 &#x3D; &quot; &lt;&lt; a02.value_ &lt;&lt; &quot;\na03 &#x3D; &quot; &lt;&lt; a03.value_ &lt;&lt; &quot;\na04 &#x3D; &quot; &lt;&lt; a04.value_ &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">construct count: 1a01 &#x3D; 10a02 &#x3D; 10a03 &#x3D; 10a04 &#x3D; 10after update:a01 &#x3D; 10a02 &#x3D; 33a03 &#x3D; 10a04 &#x3D; 33destructordestructordestructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>a01和a03均调用了类A的构造函数，且拷贝过程中并未有临时类对象的生成，a01是用global_a的左值引用作为参数进而调用普通拷贝构造函数，a03是用global_a的右值引用作为参数进而调用移动拷贝构造函数，从结果来看构造函数调用了一次(global_a的构造函数)，a01和a03调用的是拷贝构造函数，所以一共有三次析构函数。<br>通过修改global_a.value_的值也能看出a01和a03发生了拷贝构造。</p></li><li><p>避免返回new分配的堆空间引用<br>堆空间虽然可以避免如局部变量离开作用域之后就释放的问题，但如果返回的引用未被其他变量接收，就无法释放，引起内存泄漏，或者返回的引用被继续用于链式调用，也无法释放。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int *&amp;ptr getAdd(int add)&#123;    int *ptr &#x3D; new int(add);    return ptr;&#125;int main()&#123;    getAdd(10);  &#x2F;&#x2F; 函数返回值未被其他变量接收    int result &#x3D; (*(getAdd(10))) * (*(getAdd(20)));  &#x2F;&#x2F; 函数返回值被链式调用用于乘法运算    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="5-10、引用占用内存空间"><a href="#5-10、引用占用内存空间" class="headerlink" title="5.10、引用占用内存空间"></a>5.10、引用占用内存空间</h2><p>引用是变量的别名，通常给人的错觉是引用不占用内存空间，就像零长度数组，仅仅只是一个占位符而已，实际则并不是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma pack(1)class Car&#123;public:   Car(int32_t wheels, int32_t temp, char c_temp):wheels_(wheels), temp_(temp), c_temp_(c_temp)&#123;&#125;   int32_t wheels_;   int32_t &amp;temp_;   char &amp;c_temp_;   void print()   &#123;       std::cout &lt;&lt; &quot;I have 4 wheeves&quot; &lt;&lt; std::endl;   &#125;&#125;;&#x2F;&#x2F;int32_t Car::temp &#x3D; 0;int main()&#123;    Car my_car(4, 10, &#39;f&#39;);    char c &#x3D; &#39;a&#39;;    char &amp;r_c &#x3D; c;    std::cout &lt;&lt; sizeof(Car) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(my_car) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(r_c) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">20    20    1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类Car的sizeof结果为20Byte = 4 + 8 + 8(CPU是64bit)，说明左值引用是占据内存空间的，而且与指针类型占用内存大小相同。但局部变量r_c的sizeof却是1，这是怎么回事？<br><font color=red>C++编译器在编译的过程中使用常量指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。此规则只在引用作为成员时才会生效，包括class、struct的成员，如果仅仅只是局部引用变量，引用仍是常规所理解的别名，不占据内存空间，这是编译器在编译时的隐藏规则体现</font></p><h2 id="5-11、引用的本质"><a href="#5-11、引用的本质" class="headerlink" title="5.11、引用的本质"></a>5.11、引用的本质</h2><p>引用的本质就是指针，而且是一个指针常量，占据内存的大小=指针内存大小，详见<a href="https://mp.weixin.qq.com/s/CKEdPD0tmaPxb8QxqqU_lw">引用的本质</a></p><h1 id="6、指针"><a href="#6、指针" class="headerlink" title="6、指针"></a>6、指针</h1><p>指针本身是一种类型，用于指向某一块内存区域，指针的值便是所指内存区域的起始地址，不管指针指向何种数据类型，指针变量自身所占的内存大小是固定的，由CPU的位宽决定，32bit CPU指针占4Byte = 32bit，64bit CPU指针占8Byte = 64bit，这是因为指针变量存放的值是地址，该值的范围要足以访问整个内存空间，而内存空间的大小是由CPU的寻址能力决定的，即CPU的位宽决定CPU的寻址能力。</p><h2 id="6-1、一级指针与二级指针理解"><a href="#6-1、一级指针与二级指针理解" class="headerlink" title="6.1、一级指针与二级指针理解"></a>6.1、一级指针与二级指针理解</h2><p>指针和二级指针理解<br>指针本身也是个变量，其值是一个地址，也就是其指向的地址。假如通过一个函数改变指针指向的值，函数外部指针p1，参数p2，当函数调用时，p1传递给函数的依然是一个指针副本：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;一级指针p1指针本身地址0x10，存放的地址0x20,0x20地址存放的实际值是1,；p1作为实参传递给函数形参p2，p2指针本身地址0x11，存放的地址0x20，与p1存放的地址一样；    假如函数内部有一个指针p3，本身地址0x12，存放的地址0x21,0x21存放的实际值是5，如果执行p2&#x3D;p3，只是将p2存放的地址由0x20改成0x21，并不会影响函数外部p1指向的值；    此时需要执行*p2&#x3D;*p3，这样就将地址0x20存放的值改为0x21的值5，便可达到修改p1指针指向的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;二级指针p1指针本身地址0x10，存放的地址0x20,0x20地址存放的实际值是1,；p1取地址，转换为二级指针pp1，本身地址0x40，存放一级指针p1地址0x10，然后作为实参传递给函数形参二级指针p2，p2指针本身地址0x41，存放的地址0x10，与pp1存放的地址一样；    假如函数内部有一个一级指针p3，本身地址0x12，存放的地址0x21,0x21存放的实际值是5，如果执行p2&#x3D;p3，发生错误，因为p2是二级指针，p3却是一级指针，此时执行*p2&#x3D;p3,是将p2转换为一级指针*p2,这样发生的变化就是p2存放的地址0x10指向了p3存放的地址0x21，亦即p1指针由指向0x20改为指向0x21，达到了修改p1指针指向值的目的；    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include &lt;stdint.h&gt;using namespace std;void test(int **p2)&#123;cout &lt;&lt; &quot;2、**********&quot; &lt;&lt; endl;cout &lt;&lt; &quot;p2自身地址:&quot; &lt;&lt; &amp;p2 &lt;&lt; endl;cout &lt;&lt; &quot;p2指向的地址:&quot; &lt;&lt; p2 &lt;&lt; endl;cout &lt;&lt; &quot;*p2指向的地址:&quot; &lt;&lt; *p2 &lt;&lt; endl;cout &lt;&lt; &quot;*p2自身的地址:&quot; &lt;&lt; &amp;(*p2) &lt;&lt; endl;cout &lt;&lt; &quot;**p2指向的值:&quot; &lt;&lt; **p2 &lt;&lt; endl;int bb &#x3D; 10;int *p3 &#x3D; &amp;bb;&#x2F;&#x2F;*p2 &#x3D; p3;**p2 &#x3D; *p3;&#125;int main()&#123;int aa &#x3D; 9;int *p1 &#x3D; &amp;aa;cout &lt;&lt; &quot;1、**********&quot; &lt;&lt; endl;cout &lt;&lt; &quot;p1自身地址:&quot; &lt;&lt; &amp;p1 &lt;&lt; endl;cout &lt;&lt; &quot;p1指向的地址:&quot; &lt;&lt; p1 &lt;&lt; endl;cout &lt;&lt; &quot;p1指向的值:&quot; &lt;&lt; *p1 &lt;&lt; endl;test(&amp;p1);cout &lt;&lt; &quot;3、**********&quot; &lt;&lt; endl;cout &lt;&lt; &quot;02:&quot; &lt;&lt; *p1 &lt;&lt; endl;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：   </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1、**********p1自身地址:0x7ffe11911080p1指向的地址:0x7ffe1191107cp1指向的值:92、**********p2自身地址:0x7ffe11911048p2指向的地址:0x7ffe11911080*p2指向的地址:0x7ffe1191107c*p2自身的地址:0x7ffe11911080**p2指向的值:93、**********02:10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个疑问：当把test函数中*p2 = p3放开，*p1的结果就不正确，为何？   </p><ul><li>这是因为test的函数里*p2改变的是p1指针指向的内存位置，即*p2=p3操作之后，p1就指向了test函数中变量bb的内存位置,此时p1的值就是bb的内存地址。当出了test函数后再对p1解引用(*p1)时，取出的就是原先bb内存地址现在的值，而bb又是test内的临时变量，所以此时该内存地址处存放的就是个不确定值；</li><li>为何关闭*p2 = p3，开启**p2=*p3时,又正确了？首先需要注意的就是**p2=*p3并不会像*p2 = p3那样会修改p1指向的内存地址，而是直接修改p1指向内存位置所存放的值，变为*p3，即此时p1指向内存位置的值为bb的值10；</li><li>为何同时开启*p2 = p3，**p2=*p3时，就不正确了？结合前两点分析来看，*p2 = p3操作先是修改了p1指向的内存位置（bb的内存地址），然后**p2=*p3操作修改的是此时p1指向的内存位置的值（如果是**p2=20，那么此时的bb值就会变成20），出了test函数之后，实际上p1指向的内存位置变成了bb，而bb又是个临时变量，此时已经被销毁，所以*p1的结果就是个不确定值；</li></ul><h2 id="6-2、指针与数组"><a href="#6-2、指针与数组" class="headerlink" title="6.2、指针与数组"></a>6.2、指针与数组</h2><p>关于指针与数组的关系最常见的一种说法便是：   </p><p>数组名在作为函数参数进行参数传递时，会发生退化，相当于是一个指针。     </p><p><font color=red><strong>其实这种说法是不恰当地</strong><br>数组名在作为函数参数传递时，确实传递的是一个地址，但数组名绝不是指针，两者不是同一个东西。数组名用来表征一块连续内存存储空间的地址，编译器并不会为它分配内存，它只是一个占位符，sizeof的结果取决于其表述的是多大一块连续内存空间；而指针是一个变量，编译器要给它单独分配内存空间，用来存放它指向的变量的地址。<br>数组名传递给指针时发生的退化现象，应该理解成以数组所在的连续内存的起始地址对指针进行赋值，并不代表数组名与指针是一回事</font>   </p><p>关于数组名是否占用内存空间，零长度数组可以很好的阐明：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例一#pragma pack(1)&#x2F;&#x2F; 零长度数组在C语言中通常用来实现变长数组，结合struct使用struct ZeroAarray01&#123;    int32_t value_;    char c_array_[0];&#125;;struct ZeroAarray02&#123;    int32_t value_;    char *ptr;  &#x2F;&#x2F; 64bit CPU, pointer length &#x3D; 64bit&#125;;int main()&#123;        std::cout &lt;&lt; &quot;ZeroAarray01 length &#x3D; &quot; &lt;&lt; sizeof(ZeroAarray01) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;ZeroAarray02 length &#x3D; &quot; &lt;&lt; sizeof(ZeroAarray02) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ZeroAarray01 length &#x3D; 4ZeroAarray02 length &#x3D; 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>包含零长度数组的结构体ZeroAarray01的长度为4Byte，说明编译器并不为数组名分配内存，它只是个占位符，所以可以通过ZeroAarray01.c_array_进行访问。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例二int main()&#123;        char c_value &#x3D; &#39;a&#39;;    char c_array[2] &#x3D; &#123;&#39;b&#39;, &#39;c&#39;&#125;;    char *c_ptr &#x3D; &amp;c_value;    std::cout &lt;&lt; &quot;c_array length &#x3D; &quot; &lt;&lt; sizeof(c_array) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;c_ptr length &#x3D; &quot; &lt;&lt; sizeof(c_ptr) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c_array length &#x3D; 2c_ptr length &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>c_array数组名描述的是2个char型元素的连续内存空间的首地址，所以length为2</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 实例三char str1[15] &#x3D; &quot;Hello&quot;;char str2[15] &#x3D; &quot;Hello&quot;;char *str3 &#x3D; &quot;Hello&quot;;char *str4 &#x3D; &quot;Hello&quot;;printf(&quot;%d\n&quot;, str1&#x3D;&#x3D;str2);  &#x2F;&#x2F;0printf(&quot;%d\n&quot;, str3&#x3D;&#x3D;str4);  &#x2F;&#x2F;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>str1和str2都是存放内容为”Hello”的数组，字符串字面常量”Hello”虽然是存储在.rodata区，但str1和str2却是将”Hello”复制到各自的内存区域上，已脱离了”Hello”静态区域的关联，所以str1和str2是两个完全独立的值，二者所表述的地址自然也不相同<br>而str3和str4是两个指针，均指向.rodata区上的”Hello”字符串字面常量，所以str3和str4的值是相同的。PS：知识点，编译阶段编译器会将全局字面常量去重，只保留一份；   </p><p><font color=purple>所以数组名只是一段连续内存的地址表述，与指针不是同一种东西，</font><font color=red><strong>数据名不能进行自增、自减操作，但可以进行加减操作；</strong></font>  </p><h3 id="6-2-1、数组名、数组地址和数组首元素地址的理解"><a href="#6-2-1、数组名、数组地址和数组首元素地址的理解" class="headerlink" title="6.2.1、数组名、数组地址和数组首元素地址的理解"></a>6.2.1、数组名、数组地址和数组首元素地址的理解</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;    char c_array[2] &#x3D; &#123;&#39;b&#39;, &#39;c&#39;&#125;;    char *c_ptr_array_name &#x3D; c_array;  &#x2F;&#x2F; OK, c_array is char *    char *c_ptr_array_address &#x3D; &amp;c_array;  &#x2F;&#x2F; error, &amp;c_array is char (*p)[2]    char *c_ptr_first_element_address &#x3D; &amp;(c_array[0]);  &#x2F;&#x2F; OK, &amp;(c_array[0]) is char *    char (*p)[2] &#x3D; &amp;c_array;  &#x2F;&#x2F; OK, &amp;c_array is char (*p)[2]    p &#x3D; c_array; &#x2F;&#x2F; error, c_array is char *    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数组名c_array的类型可以理解成char *(实际其与指针char *并不是同一种东西)，故可将其传递给参数类型为char *的函数；</li><li> 数组地址&amp;c_array的类型是char (*p)[2]；</li><li> 数组首元素的地址&amp;(c_array[0])是char *</li></ul><p><font color=purple>对数组名类型的进一步理解</font></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;    int32_t i_array_01[2] &#x3D; &#123;1, 2&#125;;    int32_t *ptr_01 &#x3D; i_array_01;    int32_t i_array_02[2][3] &#x3D; &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;    int32_t (*ptr_02)[3] &#x3D; i_array_02;  &#x2F;&#x2F; ptr_02是二级指针        char *c_array[2] &#x3D; &#123;&quot;hello&quot;, &quot;world&quot;&#125;;    char **ptr_03 &#x3D; c_array;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>i_array_01会退化成int32_t *；</li><li>i_array_02会退化成int32_t (*)[3]；</li><li>而c_array却退化成了char **，因为数组名退化成的指针存放的是数组首元素的地址，c_array数组首元素是一个char *指针，那么指向它的指针自然就是一个二级指针；<h3 id="6-2-2、指针与二维数组"><a href="#6-2-2、指针与二维数组" class="headerlink" title="6.2.2、指针与二维数组"></a>6.2.2、指针与二维数组</h3>套用指针与一维数组的规则来理解二维数组与指针间的关系。<br>二维数组int aa[n][m]可以理解成n个包含元素数m的一维数组</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">using namespace std;int main()&#123;int32_t aa[2][3] &#x3D; &#123; &#123;1, 2, 3&#125;, &#123;4, 5,6&#125; &#125;;int32_t(*p)[3] &#x3D; aa;    cout &lt;&lt; &quot;aa length &#x3D; &quot; &lt;&lt; sizeof(aa) &lt;&lt; endl;  &#x2F;&#x2F; 数组所在连续内存空间的大小    cout &lt;&lt; &quot;01:\t&quot; &lt;&lt; aa &lt;&lt; endl;  &#x2F;&#x2F; 数组名aa作为参数传递时可以退化为指针，故aa的类型是int32_t(*p)[3]    cout &lt;&lt; &quot;02:\t&quot; &lt;&lt; p &lt;&lt; endl;  &#x2F;&#x2F; p的类型是int32_t(*p)[3]    cout &lt;&lt; &quot;03:\t&quot; &lt;&lt; &amp;aa &lt;&lt; endl &lt;&lt; endl;  &#x2F;&#x2F; 数组的地址，类型是int32_t [2][3]    cout &lt;&lt; &quot;04:\t&quot; &lt;&lt; aa + 1 &lt;&lt; endl;    cout &lt;&lt; &quot;05:\t&quot; &lt;&lt; p + 1 &lt;&lt; endl;    cout &lt;&lt; &quot;06:\t&quot; &lt;&lt; &amp;aa + 1 &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; &quot;07:\t&quot; &lt;&lt; aa[0] &lt;&lt; endl;  &#x2F;&#x2F; aa[0]指向aa数组的第一行，类型是int32_t *    cout &lt;&lt; &quot;08:\t&quot; &lt;&lt; &amp;aa[0] &lt;&lt; endl &lt;&lt; endl;  &#x2F;&#x2F; &amp;aa[0]是第一行数组的地址,区别于&amp;aa，类型是int32_t (*p)[3]    cout &lt;&lt; &quot;09:\t&quot; &lt;&lt; aa[0] + 1 &lt;&lt; endl;    cout &lt;&lt; &quot;10:\t&quot; &lt;&lt; &amp;aa[0] + 1 &lt;&lt; endl &lt;&lt; endl;        cout &lt;&lt; &quot;11:  &quot; &lt;&lt; *p &lt;&lt; endl;  &#x2F;&#x2F; p &#x3D; aa[0]cout &lt;&lt; &quot;12:  &quot; &lt;&lt; *p + 1 &lt;&lt; endl;  &#x2F;&#x2F; aa[0] + 1cout &lt;&lt; &quot;13:  &quot; &lt;&lt; **p &lt;&lt; endl;  &#x2F;&#x2F; *p &#x3D; aa[0]  **p &#x3D; aa[0][0]return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aa length &#x3D; 2401:0x7ffcc94ae23002:0x7ffcc94ae23003:0x7ffcc94ae23004:0x7ffcc94ae23c05:0x7ffcc94ae23c06:0x7ffcc94ae24807:0x7ffcc94ae23008:0x7ffcc94ae23009:0x7ffcc94ae23410:0x7ffcc94ae23c11:  0x7ffcc94ae23012:  0x7ffcc94ae23413:  1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-3、指针数组与二级指针"><a href="#6-2-3、指针数组与二级指针" class="headerlink" title="6.2.3、指针数组与二级指针"></a>6.2.3、指针数组与二级指针</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main()&#123;    const char *str[4] &#x3D; &#123;&quot;welcome&quot;, &quot;to&quot;, &quot;new&quot;, &quot;Beijing&quot;&#125;;    const char **p &#x3D; str;  &#x2F;&#x2F; str相当于二级指针    std::cout &lt;&lt; &quot;*p&#x3D;\t\t&quot; &lt;&lt; *p &lt;&lt; std::endl;   &#x2F;&#x2F; *p is char *    std::cout &lt;&lt; &quot;**p&#x3D;\t\t&quot; &lt;&lt; **p &lt;&lt; std::endl;   &#x2F;&#x2F; **p is char    std::cout &lt;&lt; &quot;(*p++) + 1&#x3D;\t&quot; &lt;&lt; (*p++) + 1 &lt;&lt; std::endl;   &#x2F;&#x2F; (*p++) is char *, 后置++    &#x2F;&#x2F; 由于(*p++)后*p指向了&quot;to&quot;，故二级指针p也向前移动了一个char *指向str[1]    std::cout &lt;&lt; &quot;*(p+1)&#x3D;\t\t&quot; &lt;&lt; *(p+1) &lt;&lt; std::endl;   &#x2F;&#x2F; &quot;new&quot;    std::cout &lt;&lt; &quot;p[1] + 3&#x3D;\t&quot; &lt;&lt; p[1] + 1&lt;&lt; std::endl;   &#x2F;&#x2F; &quot;ew&quot;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*p&#x3D;welcome**p&#x3D;w(*p++) + 1&#x3D;elcome*(p+1)&#x3D;newp[1] + 3&#x3D;ew<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当str退化成数组时相当于一个二级指针，指向一个包含四个char *的一维数组，这四个char *指针内存空间是连续的，但各自指向的字符串字面常量内存空间并不是连续的；</p><h2 id="6-3、指针与字面常量"><a href="#6-3、指针与字面常量" class="headerlink" title="6.3、指针与字面常量"></a>6.3、指针与字面常量</h2><p>字面常量包括：整形字面常量、字符串字面常量   </p><ul><li>字符串字面自身在编译期会被优化，进行去重处理(全局变量 + 局部变量)，全局只会保留一份，所有指向同一个字符串字面常量的指针值都是一样的； </li><li>整形字面常量自身并不会做去重处理，所以，包含相同整形字面常量的变量地址是不一样的；</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const char *c1 &#x3D; &quot;hello&quot;;const char *c2 &#x3D; &quot;hello&quot;;int32_t i1 &#x3D; 1234;int32_t i2 &#x3D; 1234;int main()&#123;    const char *c3 &#x3D; &quot;hello&quot;;    int32_t i3 &#x3D; 1234;        printf(&quot;c1 pointer: %p\n&quot;, c1);    printf(&quot;c2 pointer: %p\n&quot;, c2);    printf(&quot;c3 pointer: %p\n&quot;, c3);    printf(&quot;i1 pointer: %p\n&quot;, &amp;i1);    printf(&quot;i2 pointer: %p\n&quot;, &amp;i2);    printf(&quot;i3 pointer: %p\n&quot;, &amp;i3);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">c1 pointer: 0x402004c2 pointer: 0x402004c3 pointer: 0x402004i1 pointer: 0x404058i2 pointer: 0x40405ci3 pointer: 0x7ffeb65eab64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>C与C++之中对于字符串字面常量与指针间的赋值操作规则是不一样的</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;int main()&#123;    char *str &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; C语言中编译、执行均OK，但C++中编译会报错，提示const char *无法赋值给char *，这样来看C++的安全机制更高    printf(&quot;%s\n&quot;, str);    char *c_ptr &#x3D; (char*)str;    c_ptr[1] &#x3D; &#39;c&#39;;  &#x2F;&#x2F; C中编译OK，执行报错，C++中g++编译会报错Segmentation fault,clang++不报错，但结果不符合预期，这是编译器的差异引起，因为str指向的内存区域是.rodata不可更改    *str &#x3D; &quot;world&quot;;  &#x2F;&#x2F; C中编译OK，执行报错，C++中编译会报错，因为*str是char类型，而&quot;world&quot;是char *    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-1、通过指针修改字面常量"><a href="#6-3-1、通过指针修改字面常量" class="headerlink" title="6.3.1、通过指针修改字面常量"></a>6.3.1、通过指针修改字面常量</h3><ul><li>整形字面常量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 整形字面常量赋值的const常量const int32_t i2 &#x3D; 1234;int main()&#123;    const int32_t i3 &#x3D; 1234;    int32_t *ptr2 &#x3D; (int32_t *)(&amp;i2);    *ptr2 &#x3D; *ptr2 + 1;    std::cout &lt;&lt; ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i2 &lt;&lt; &quot;  &quot; &lt;&lt; i2 &lt;&lt; std::endl;    int32_t *ptr3 &#x3D; (int32_t *)(&amp;i3);    *ptr3 &#x3D; *ptr3 + 1;    std::cout &lt;&lt; ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i3 &lt;&lt; &quot;  &quot; &lt;&lt; i3 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>g++编译后运行报错Segmentation fault    </p><p>clang++编译后运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x402004  1234  0x402004  12340x7fff71761654  1235  0x7fff71761654  1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>i2与i3仍然输出值1234，说明了被整形字面量赋值的const常量会在编译期以立即数的形式展开，直接编译进.text段，所以后续通过指针间接修改值对其无影响；<br>【编译器差异】不报错，但与预期不符，*ptr2输出1234，而*ptr3输出1235，因为ptr2指向的i2地址空间位于.rodata常量区，不可更改，而ptr3指向的i3位于栈空间，可以通过指针ptr3间接修改；</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 整形字面常量赋值的非const变量int32_t i2 &#x3D; 1234;int main()&#123;    int32_t i3 &#x3D; 1234;    int32_t *ptr2 &#x3D; (int32_t *)(&amp;i2);    *ptr2 &#x3D; *ptr2 + 1;    std::cout &lt;&lt; ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr2 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i2 &lt;&lt; &quot;  &quot; &lt;&lt; i2 &lt;&lt; std::endl;    int32_t *ptr3 &#x3D; (int32_t *)(&amp;i3);    *ptr3 &#x3D; *ptr3 + 1;    std::cout &lt;&lt; ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; *ptr3 &lt;&lt; &quot;  &quot; &lt;&lt; &amp;i3 &lt;&lt; &quot;  &quot; &lt;&lt; i3 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x404078  1235  0x404078  12350x7ffe43290234  1235  0x7ffe43290234  1235<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于i2与i3只是普通非const变量，故在编译器不会以立即数的形式被优化</p><ul><li>字符串字面量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;const char * c1 &#x3D; &quot;hello&quot;;int main()&#123;    const char *c2 &#x3D; &quot;hello&quot;;    char *c_ptr3 &#x3D; (char *)c1;    c_ptr3[0] &#x3D; &#39;m&#39;;    printf(&quot;%p  %s  %p  %s\n&quot;, c_ptr3, c_ptr3, c1, c1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译OK，运行时报错Segmentation fault，因为c1、c_ptr3指向的是.rodata空间的”hello”，它是不可更改的。   </p><p>特例：【编译器差异】若使用clang++编译器，且将c2赋值给c_ptr3，运行时不报错，但运行结果与预期不符</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;const char * c1 &#x3D; &quot;hello&quot;;int main()&#123;    const char *c2 &#x3D; &quot;hello&quot;;    char *c_ptr3 &#x3D; (char *)c2;    c_ptr3[0] &#x3D; &#39;m&#39;;    printf(&quot;%p  %s  %p  %s\n&quot;, c_ptr3, c_ptr3, c2, c2);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">0x402004  hello  0x402004  hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-4、指针常量和常量指针"><a href="#6-4、指针常量和常量指针" class="headerlink" title="6.4、指针常量和常量指针"></a>6.4、指针常量和常量指针</h2><p><strong>指针常量</strong>—可以这么理解”指针是常量”，指针的值不可更改    </p><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 30;int *const p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>常量指针</strong>—可以这么理解”常量的指针”指针指向的值不可更改</p><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 30;const int *p &#x3D; &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-5、智能指针"><a href="#6-5、智能指针" class="headerlink" title="6.5、智能指针"></a>6.5、智能指针</h2><p>头文件：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;memory&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>智能指针的原理：在栈上构造一个的智能指针对象，并接受一块申请好的heap地址，当退出栈的作用域后，栈上的智能指针对象自动被销毁，进而调用析构函数，释放动态内存。</p><h3 id="6-5-1、std-shared-ptr共享智能指针"><a href="#6-5-1、std-shared-ptr共享智能指针" class="headerlink" title="6.5.1、std::shared_ptr共享智能指针"></a>6.5.1、std::shared_ptr共享智能指针</h3><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存，每拷贝一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，删除所指向的堆内存。<br><font color=red><strong>shared_ptr内部的引用计数是线程安全的，但是指向堆内存的读写需要线程同步</strong></font></p><h4 id="1、初始化-3"><a href="#1、初始化-3" class="headerlink" title="1、初始化"></a>1、初始化</h4><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(1));std::shared_ptr&lt;int&gt; p2 &#x3D; p;std::shared_ptr&lt;int&gt; p3;p3 &#x3D; p;class Weight&#123;public:    int i;    Weight()&#123;&#125;&#125;std::shared_ptr&lt;Weight&gt; sptr1 &#x3D; std::make_shared&lt;Weight&gt;();  &#x2F;&#x2F; 会自动调用Weight的构造函数，()里也可以放入Weight其他构造函数的初始化参数std::shared_ptr&lt;int&gt; sptr1 &#x3D; std::make_shared&lt;int&gt;(3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们应该优先使用make_shared来构造智能指针。<br><strong>切记</strong>：在赋值语句”=”中不能使用原始指针直接赋值给一个智能指针，因为原始指针是指针类型，而智能指针是一个类   </p><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p &#x3D; new int(1);  &#x2F;&#x2F; error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2、获取原始指针"><a href="#2、获取原始指针" class="headerlink" title="2、获取原始指针"></a>2、获取原始指针</h4><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(1));int *ptr &#x3D; p.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3、指定删除器"><a href="#3、指定删除器" class="headerlink" title="3、指定删除器"></a>3、指定删除器</h4><pre class="line-numbers language-none"><code class="language-none">void DeletePtr(int *p)&#123;    delete p;&#125;std::shared_ptr&lt;int&gt; p(new int(10), DeletePtr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当引用计数减为0时，会自动调用DeletePtr函数来释放对象内存。<br><font color=red>由于shared_ptr的默认删除器不支持数组对象</font>，所以需要指定删除器</p><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int[10], [](int *p)&#123;delete[] p&#125;);&#x2F;&#x2F; 自行封装一个动态数组共享智能指针template&lt;typename T&gt;std::shared_ptr&lt;T&gt; make_shared_array(size_t nSize)&#123;    return std::shared_ptr&lt;T&gt; (new T[nSize], std::default_delete&lt;T[]&gt;());&#125;&#x2F;&#x2F;或者template&lt;typename T&gt;std::shared_ptr&lt;T&gt; make_shared_array(size_t nSize)&#123;    return std::shared_ptr&lt;T&gt; (new T[nSize], [](T *p)&#123;delete[] p&#125;);&#125;std::shared_ptr&lt;int&gt; p &#x3D; make_shared_array&lt;int&gt;(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、reset"><a href="#4、reset" class="headerlink" title="4、reset"></a>4、reset</h4><p>用于释放已绑定的堆内存，有三个重载版本</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::shared_ptr&lt;int&gt; pt1(new int(2));std::shared_ptr&lt;int&gt; pt2 &#x3D; pt1;  &#x2F;&#x2F; 引用计数为2&#x2F;&#x2F; 版本一pt2.reset();  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，pt2自身引用计数减0，而pt1的引用计数减为1&#x2F;&#x2F; 版本二pt2.reset(new int(3));  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，重新绑定新的堆内存int(3)&#x2F;&#x2F; 版本三 pt2.reset(new int[10], [](void *p)&#123;delete[] p;&#125;);  &#x2F;&#x2F; 原先指向的堆对象引用计数减一，然后重新绑定新的堆内存int(10)，并指定删除器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、避免heap对象重复释放"><a href="#5、避免heap对象重复释放" class="headerlink" title="5、避免heap对象重复释放"></a>5、避免heap对象重复释放</h4><ul><li>避免用一个原始指针初始化多个shared_ptr</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int *ptr &#x3D; new int(2);shared_ptr&lt;int&gt; p1(ptr);shared_ptr&lt;int&gt; p2(ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>避免将this指针作为shared_ptr返回<br>因为this本质上是一个指针，当this作为shared_ptr返回会导致多个shared_ptr对象的构造</li></ul><pre class="line-numbers language-none"><code class="language-none">struct A&#123;    shared_ptr&lt;A&gt; GetSelf()    &#123;        return shared_ptr&lt;A&gt;(this);    &#125;&#125;int main()&#123;    shared_ptr&lt;A&gt; sp1(new A);    shared_ptr&lt;A&gt; sp2 &#x3D; sp1-&gt;GetSelf();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于同一个指针this构造了两个shared_ptr，引发重复析构。当需要返回对象的shared_ptr时，正确的做法是让目标类通过派生std::enable_shared_from_this<T>类，然后使用基类的成员函数shared_from_this返回：   </p><pre class="line-numbers language-none"><code class="language-none">class A: public std::enable_shared_from_this&lt;A&gt;&#123;    shared_ptr&lt;A&gt; GetSelf()    &#123;        return shared_from_this();    &#125;&#125;int main()&#123;    shared_ptr&lt;A&gt; sp1(new A);    shared_ptr&lt;A&gt; sp2 &#x3D; sp1-&gt;GetSelf();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::enable_shared_from_this 能让一个对象（假设其名为t，且已被一个std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。<br> 若一个类T继承std::enable_shared_from_this<T>，则会为该类T提供成员函数：shared_from_this 。 当 T 类型对象t被一个为名为pt的std::shared_ptr<T>类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。<br> std::enable_shared_from_this<T>原理详见<strong>C++壹.6.5.3.2</strong>节</p><h4 id="6、避免在函数参数中创建shared-ptr"><a href="#6、避免在函数参数中创建shared-ptr" class="headerlink" title="6、避免在函数参数中创建shared_ptr"></a>6、避免在函数参数中创建shared_ptr</h4><pre class="line-numbers language-none"><code class="language-none">function(shared_ptr&lt;int&gt;(new int(10)), g()); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数的执行顺序因编译器而不同，通常的顺序是从右往左，但也可能是从左往右。所以，可能的情况是，先new int(10)，然后调用g(),最后再创建智能指针对象。如果恰好g()出错，而shared_ptr<int>还未创建，此时int(10)内存泄漏</p><h4 id="7、避免循环引用"><a href="#7、避免循环引用" class="headerlink" title="7、避免循环引用"></a>7、避免循环引用</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct A&#123;    std::shared_ptr&lt;B&gt; bptr;    ~A()    &#123;        cout&lt;&lt;&quot;A is deleted&quot;&lt;&lt;endl;    &#125;&#125;    struct B&#123;    std::shared_ptr&lt;A&gt; aptr;    ~B()    &#123;        cout&lt;&lt;&quot;B is deleted&quot;&lt;&lt;endl;    &#125;&#125;void Test()&#123;    shared_ptr&lt;A&gt; ap(new A);    shared_ptr&lt;B&gt; bp(new B);    ap-&gt;bptr &#x3D; bp;    bp-&gt;aptr &#x3D; ap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环引用导致ap和bp的引用计数为2，当离开函数Test之后，ap和bp的引用计数减1，并不是0，无法调用析构函数，出现内存泄漏。解决此问题需要使用weak_ptr智能指针。  </p><h4 id="8、shared-ptr的移动语义"><a href="#8、shared-ptr的移动语义" class="headerlink" title="8、shared_ptr的移动语义"></a>8、shared_ptr的移动语义</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> shared_ptr(shared_ptr&amp;&amp; __r) noexcept      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) &#123; &#125;      &#x2F;&#x2F; construct shared_ptr object that takes resource from _r      shared_ptr&amp;      operator&#x3D;(shared_ptr&amp;&amp; __r) noexcept      &#123;this-&gt;__shared_ptr&lt;_Tp&gt;::operator&#x3D;(std::move(__r));return *this;      &#125;      &#x2F;&#x2F; construct shared_ptr object that takes resource from _r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr的移动赋值运算符、移动构造函数都是使用的move语义，说明它们与_r不是共享关系，而是切换，操作之后_r立即失去了控制权，例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;memory&gt;class Test&#123;public:    Test(int32_t val):val_(val)&#123;&#125;    int32_t val_;&#125;;int main()&#123;    std::shared_ptr&lt;Test&gt; ptr1(new Test(10));        std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;    std::shared_ptr&lt;Test&gt; ptr2(std::move(ptr1));    std::cout &lt;&lt; ptr2.use_count() &lt;&lt; std::endl;    std::cout &lt;&lt; ptr1.use_count() &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-base" data-language="base"><code class="language-base">110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-5-2、std-unique-ptr独占智能指针"><a href="#6-5-2、std-unique-ptr独占智能指针" class="headerlink" title="6.5.2、std::unique_ptr独占智能指针"></a>6.5.2、std::unique_ptr独占智能指针</h3><p>独占智能指针不允许其他智能指针共享其内部的heap空间，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr，只允许进行右值相关操作，比如move方式，通过move的方式转移unique_ptr之后，本身就不再拥有原来指针的所有权了：   </p><pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int&gt; p(new int);std::unique_ptr&lt;int&gt; p2 &#x3D; p;  &#x2F;&#x2F; errorstd::unique_ptr&lt;int&gt; p3 &#x3D; std::move(p);std::unique_ptr&lt;int&gt; p4；p4 &#x3D; std::move(p3);  &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从实现上讲，unique_ptr是一个disable了普通拷贝构造函数、普通赋值运算符，但保留了移动拷贝构造函数、移动赋值运算符。程序员仅可以使用右值对unique_ptr对象进行构造，而且一旦构造成功，原unique对象中的heap指针即被”窃取”，即刻失去了对heap指针的”所有权”。”窃取”的操作是在unique_ptr移动拷贝构造函数、移动赋值运算符的定义里实现。    </p><h4 id="1、基本用法"><a href="#1、基本用法" class="headerlink" title="1、基本用法"></a>1、基本用法</h4><p>unique_ptr和shared_ptr相比，前者可以直接指向一个数组heap，后者指向数组heap时需要指定删除器：   </p><pre class="line-numbers language-none"><code class="language-none">unique_ptr&lt;int[]&gt; p(new int[10]);  &#x2F;&#x2F;okshared_ptr&lt;int[]&gt; p2(new int[10]);  &#x2F;&#x2F;error，需要指定删除器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>unique_ptr指定删除器的方式也不同于shared_ptr：    </p><pre class="line-numbers language-none"><code class="language-none">std::shared_ptr&lt;int&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;okstd::unique_ptr&lt;int&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>unique_ptr在指定删除器时需要确定删除器的类型：   </p><pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int, void(*)(int *)&gt; p(new int(2), [](int *p)&#123;delere p;&#125;)   &#x2F;&#x2F;ok<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>但是要注意</strong>：当上面的lambda表达式不捕获变量时是可以的，但是当捕获变量的时候就报错，因为lambda不捕获变量时是可以直接转换为函数指针，当捕获时就不能转换为函数指针了，此时需要这样写：   </p><pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;int, std::function&lt;void(int *)&gt;&gt; p(new int(2), [&amp;](int *p)&#123;delere p;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-5-3、weak-ptr弱引用智能指针"><a href="#6-5-3、weak-ptr弱引用智能指针" class="headerlink" title="6.5.3、weak_ptr弱引用智能指针"></a>6.5.3、weak_ptr弱引用智能指针</h3><p>它是用来监视shared_ptr的，更像是shared_ptr的助手，不会使引用计数加1。而且其内部并没有重载*和-&gt;，不能操作heap资源。   </p><h4 id="1、基本用法-1"><a href="#1、基本用法-1" class="headerlink" title="1、基本用法"></a>1、基本用法</h4><ul><li><strong>使用use_count()获取当前观测资源的引用计数</strong>    </li></ul><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));weak_ptr&lt;int&gt; wp(sp);wp.use_count();  &#x2F;&#x2F; 输出为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>通过expired()判断所观测的资源是否被释放</strong>   </p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));weak_ptr&lt;int&gt; wp(sp);if(wp.expired())&#x2F;&#x2F;wp无效，所监视的资源已释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>通过lock获取所监视的shared_ptr</strong><br>原型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::shared_ptr&lt;T&gt; lock() const noexcept;Creates a new std::shared_ptr that shares ownership of the managed object. If there is no managed object, i.e. *this is empty, then the returned shared_ptr also is empty.   Effectively returns expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this), executed atomically.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>lock返回的是新shared_ptr，与它所监视的shared_ptr共享所有权，详见<strong>6.5.3.4节</strong></p><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; sp(new int(10));weak_ptr&lt;int&gt; wp;wp &#x3D; sp;if(wp.expired())&#x2F;&#x2F;wp无效，所监视的资源已释放else&#123;    auto spt &#x3D; wp.lock();    *spt;   &#x2F;&#x2F; 结果是10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2、std-enable-shared-from-this原理"><a href="#2、std-enable-shared-from-this原理" class="headerlink" title="2、std::enable_shared_from_this原理"></a>2、std::enable_shared_from_this原理</h4><p>enable_shared_from_this类中有一个weak_ptr，这个weak_ptr用来监视继承类的shared_ptr对象，调用shared_from_this成员函数时会调用内部的lock方法，构建新的shared_ptr对象并返回，而不是返回this指针，返回的shared_pt对象与weak_ptr所监视的继承类的shared_ptr对象共享所有权</p><p>enable_shared_from_this是一个模板类，头文件<memory>，其原型为：</p><p><code>template&lt; class T &gt; class enable_shared_from_this;</code></p><p>若一个类 T 继承 <code>std::enable_shared_from_this&lt;T&gt; </code>，则会为该类 T 提供成员函数： <code>shared_from_this</code> 。 当 T 类型对象 t 被一个为名为 pt 的 <code>std::shared_ptr&lt;T&gt;</code> 类对象管理时，调用 <code>T::shared_from_this</code> 成员函数，将会返回一个新的 <code>std::shared_ptr&lt;T&gt; </code>对象，它与 pt 共享 t 的所有权。<br><code>std::enable_shared_from_this</code> 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 <code>std::shared_ptr</code> 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。这也就意味着只有<code>std::shared_ptr</code> 实例才可以调用<code>shared_from_this</code> 成员函数</p><ul><li>使用场景<br>当类T被share_ptr管理，且在类T的成员函数里需要把当前类对象作为参数传给其他函数时，就需要传递一个指向自身的<code>share_ptr</code>   </li></ul><p>那么问题就来了：<br><strong>为何不能直接传递this指针？</strong><br>使用智能指针的初衷就是为了方便资源管理，如果在某些地方使用智能指针，某些地方使用原始指针，很容易破坏智能指针的语义，进而产生各种错误。   </p><p>直接传递this在异步场景下，容易出现无法”保活”的问题，即发生异步调用时无从知晓this指向的对象是否已经被析构。此时若使用<code>shared_from_this</code>使引用计数增加，即可确保异步调用期间对象不会被析构，详见下方示例”异步调用场景”。</p><p><strong>为何不直接传递share_ptr<this>？</strong><br>这样会出现一个this构建两个shared_ptr对象，导致重复析构的问题。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;memory&gt;#include &lt;iostream&gt; class Bad&#123;public:    std::shared_ptr&lt;Bad&gt; getptr() &#123;        &#x2F;&#x2F; 有一些业务场景需要在类的成员函数里将类对象的指针传递给其他函数，这是如果使用getptr就会引起重复析构的问题        return std::shared_ptr&lt;Bad&gt;(this);    &#125;~Bad() &#123;     std::cout &lt;&lt; &quot;Bad::~Bad() called&quot; &lt;&lt; std::endl; &#125;&#125;; int main()&#123;    &#x2F;&#x2F; 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者    std::shared_ptr&lt;Bad&gt; bp1(new Bad());    std::shared_ptr&lt;Bad&gt; bp2 &#x3D; bp1-&gt;getptr();    &#x2F;&#x2F; 打印bp1和bp2的引用计数    std::cout &lt;&lt; &quot;bp1.use_count() &#x3D; &quot; &lt;&lt; bp1.use_count() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;bp2.use_count() &#x3D; &quot; &lt;&lt; bp2.use_count() &lt;&lt; std::endl;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序会因重复析构而崩溃</p><p><font color=red><strong>异步调用场景</strong></font></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Foo&#123;public:    coid Bar(std::function&lt;void(Foo *)&gt; p_func_callback)    &#123;        &#x2F;&#x2F; async call p_func_callback whit this    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Foo::Bar接受一个函数对象，这个对象需要一个Foo*指针，其实要的就是Foo::Bar的this指针，但是这个回调是异步的，也就是说可能在调用这个回调函数时，this指向的Foo对象已经提前析构了。这时候，std::enable_shared_from_this就派上用场了。修改后如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Foo&#123;public:    coid Bar(std::function&lt;void(std::shared_ptr&lt;Foo&gt;)&gt; p_func_callback)    &#123;        std::shared_ptr&lt;Foo&gt; spt_foo &#x3D; shared_from_this();        &#x2F;&#x2F; async call p_func_callback whit sptr_foo    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以shared_from_this获取对象使引用计数增加，进而保证对象在异步调用期间不会被析构。</p><h4 id="3、weak-ptr解决shared-ptr循环引用问题"><a href="#3、weak-ptr解决shared-ptr循环引用问题" class="headerlink" title="3、weak_ptr解决shared_ptr循环引用问题"></a>3、weak_ptr解决shared_ptr循环引用问题</h4><pre class="line-numbers language-none"><code class="language-none">struct A&#123;    std::shared_ptr&lt;B&gt; bptr;    ~A()    &#123;        cout&lt;&lt;&quot;A is deleted&quot;&lt;&lt;endl;    &#125;&#125;    struct B&#123;    std::weak_ptr&lt;A&gt; aptr;    ~B()    &#123;        cout&lt;&lt;&quot;B is deleted&quot;&lt;&lt;endl;    &#125;&#125;void Test()&#123;    shared_ptr&lt;A&gt; ap(new A);    shared_ptr&lt;B&gt; bp(new B);    ap-&gt;bptr &#x3D; bp;    bp-&gt;aptr &#x3D; ap;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于aptr是weak_ptr，它并不会增加引用计数，所以ap的引用计数仍然是1，在离开作用域之后，ap的引用计数是0，A指针被析构，析构后，其内部的bptr的引用计数减1，然后离开作用域的后的bp引用计数又从1减为0，B指针也被析构。</p><h4 id="4、weak-ptr的lock函数"><a href="#4、weak-ptr的lock函数" class="headerlink" title="4、weak_ptr的lock函数"></a>4、weak_ptr的lock函数</h4><p>函数原型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std::shared_ptr&lt;T&gt; lock() const noexcept;Creates a new std::shared_ptr that shares ownership of the managed object. If there is no managed object, i.e. *this is empty, then the returned shared_ptr also is empty.   Effectively returns expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this), executed atomically.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lock返回的是新shared_ptr，与它所监视的shared_ptr对象共享所有权<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;memory&gt;class TEST&#123;public:    int32_t value_;&#125;;int main()&#123;    std::shared_ptr&lt;TEST&gt; sptr_a(new TEST());    sptr_a-&gt;value_ &#x3D; 10;    std::cout &lt;&lt; &quot;01 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;    std::shared_ptr&lt;TEST&gt; sptr_b(sptr_a);    std::cout &lt;&lt; &quot;02 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;    std::weak_ptr&lt;TEST&gt; wptr_a(sptr_a);    std::cout &lt;&lt; &quot;03 counter is: &quot; &lt;&lt; wptr_a.use_count() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;04 counter is: &quot; &lt;&lt; wptr_a.lock().use_count() &lt;&lt; std::endl;    std::shared_ptr&lt;TEST&gt; sptr_c(wptr_a.lock());    std::cout &lt;&lt; &quot;05 counter is: &quot; &lt;&lt; sptr_a.use_count() &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>运行结果<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">01 counter is: 102 counter is: 203 counter is: 204 counter is: 305 counter is: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>lock的原子性<br>通过上面函数原型的注释来看，lock的操作是原子性的<code>executed atomically</code><br>那么为何lock的操作会是原子性的呢？   <ul><li>首先weak_ptr并不会引起shared_ptr的引用计数增加，说明weak_ptr对象中存放的就是shared_ptr；</li><li>对于某些异步场景，比如，当weak_ptr对象与shared_ptr对象不在同一个线程之中时，若想通过lock函数构建新的shared_ptr对象，这里就涉及到同一个shared_ptr对象在不同线程的读写问题，存在竞太条件，详见<strong>6.5.6节</strong></li></ul></li></ul><h3 id="6-5-4、RAII：智能指针的理论基础"><a href="#6-5-4、RAII：智能指针的理论基础" class="headerlink" title="6.5.4、RAII：智能指针的理论基础"></a>6.5.4、RAII：智能指针的理论基础</h3><p>详见<strong>1.8</strong>节</p><h3 id="6-5-5、weak-ptr解决回调函数中对象参数已消亡问题"><a href="#6-5-5、weak-ptr解决回调函数中对象参数已消亡问题" class="headerlink" title="6.5.5、weak_ptr解决回调函数中对象参数已消亡问题"></a>6.5.5、weak_ptr解决回调函数中对象参数已消亡问题</h3><p>在回调函数中有时需要调用其他对象指针的成员或函数，多线程模式下，可能不知道对象是否还活着，存在race condition的情况，通过weak_ptr的方式，在回调的时候先尝试提升为shared_ptr判断是否有效可以很好的解决此类问题，这种方式称作”弱回调”：</p><pre class="line-numbers language-none"><code class="language-none">class StacksFactory : pubic boost::enable_shared_from_this&lt;StocksFactory&gt;, boost::noncopyable&#123;public:    shared_ptr&lt;Stock&gt; get(const string &amp;key)    &#123;        shared_ptr&lt;Stock&gt; pStock;        MutexLockGuard lock(mutex_);        weak_ptr&lt;Stock&gt;&amp;wStock &#x3D; stocks_[key];  &#x2F;&#x2F; 注意这里是引用        pStock &#x3D; wStock.lock();        if(!pStock)        &#123;            pStock.reset(new Stock(key), boost::bind(&amp;StockFactory::weakDeleteCallback, boost::weak_ptr&lt;StockFactory&gt;(shared_from_this()), _1));            &#x2F;&#x2F; 必须强制把shared_from_this()转型为weak_ptr，才不会延长生命周期            &#x2F;&#x2F; 因为boost::bind拷贝的是实参，而不是形参            wStock &#x3D; pStock;        &#125;        return pStock;    &#125;    private:     static void weakDeleteCallback(const boost::weak_ptr&lt;StockFactory&gt;&amp; wStock, Stock* stock)     &#123;         shared_ptr&lt;StockFactory&gt; factory(wFactory.lock());  &#x2F;&#x2F; 尝试提升         if(factory)         &#123;             factory-&gt;removeStock(stocj);         &#125;         delete stock;     &#125;        void removeStock(Stock* stock)    &#123;        if(stock)        &#123;            MutexLockGuard lock(mutex_);            stocks_.erase(stock-&gt;key());        &#125;    &#125;        mutable MutexLock mutex_;    map&lt;string, weak_ptr&lt;StockFactory&gt;&gt; stocks_;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-6、shared-ptr的线程安全问题"><a href="#6-5-6、shared-ptr的线程安全问题" class="headerlink" title="6.5.6、shared_ptr的线程安全问题"></a>6.5.6、shared_ptr的线程安全问题</h3><p>参考：<br><a href="https://www.jianshu.com/p/cb3e574eee5f">智能指针的线程安全</a><br><a href="https://blog.csdn.net/D_Guco/article/details/80155323?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">shared_ptr的线程安全性</a></p><p>shared_ptr对象的成员至少包括：</p><ul><li>一个指向堆空间对象的指针；</li><li>一个指向引用计数对象的指针；</li></ul><p>对这两个对象的操作不是一个指令可以完成的，因此多线程环境下，势必有问题<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE233bf2066ae985f9ecd2adf78712ffcf/39789" alt="image06"></p><p>线程安全的场景：   </p><ul><li><p>同一个shared_ptr对象被多个线程读，是线程安全的；</p></li><li><p>同一个shared_ptr对象被多个线程写，不是线程安全的；</p></li><li><p>引用计数的增、减操作是线程安全的（参见6.5.7节），但对管理引用计数的对象的操作不是线程安全的，详见下方示例；</p></li><li><p>线程安全</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread Ashared_ptr&lt;int&gt; p2(p); &#x2F;&#x2F; reads p&#x2F;&#x2F; thread Bshared_ptr&lt;int&gt; p3(p); &#x2F;&#x2F; OK, multiple reads are safe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p的赋值操作不涉及堆空间的写操作，仅是引用计数的增加，故是线程安全的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread Ap.reset(new int(1912)); &#x2F;&#x2F; writes p&#x2F;&#x2F; thread Bp2.reset(); &#x2F;&#x2F; OK, writes p2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p与p2虽然都被reset，并不涉及堆空间的写操作，仅是对引用计数的操作，故是线程安全的。</p></li><li><p>线程不安全<br>线程不安全的原因详见下方示例</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread Ap &#x3D; p3; &#x2F;&#x2F; reads p3, writes p&#x2F;&#x2F; thread Bp3.reset(); &#x2F;&#x2F; writes p3; undefined, simultaneous read&#x2F;write<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread Ap3 &#x3D; p2; &#x2F;&#x2F; reads p2, writes p3&#x2F;&#x2F; thread B&#x2F;&#x2F; p2 goes out of scope: undefined, the destructor is considered a &quot;write access&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; thread Ap3.reset(new int(1));&#x2F;&#x2F; thread Bp3.reset(new int(2)); &#x2F;&#x2F; undefined, multiple writes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>多线程场景下的竞态条件示例</strong></font><br>shared_ptr对象的拷贝、赋值操作至少包括如下两步：</p><ul><li>拷贝指向堆空间对象的指针;</li><li>拷贝引用计数对象的指针;</li></ul><p>考虑一个简单的场景，有 3 个 shared_ptr<Foo> 对象 x、g、n：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shared_ptr&lt;Foo&gt; g(new Foo); &#x2F;&#x2F; 线程之间共享的 shared_ptrshared_ptr&lt;Foo&gt; x; &#x2F;&#x2F; 线程 A 的局部变量shared_ptr&lt;Foo&gt; n(new Foo); &#x2F;&#x2F; 线程 B 的局部变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一开始，各安其事<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE0603c082a1b134065903a4ec2d59e798/39791" alt="image07"></p><p>线程 A 执行x = g;（即 read g），以下完成了步骤 1，还没来及执行步骤 2。这时切换到了 B 线程<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE2ba124e790af8967ad69aa28a4378909/39794" alt="image08"></p><p>同时线程 B 执行 g = n; （即 write G），两个步骤一起完成了<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE03443423e9145c6ed28a3deb23a4a626/39796" alt="image09"></p><p>这时 Foo1 对象已经销毁，x.ptr 成了空悬指针！<br>最后回到线程 A，完成步骤 2<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCEddbb3631887362b151a4fb1b18d77c43/39799" alt="image10"></p><p>多线程无保护地读写 g，造成了”x 是空悬指针”的后果。这正是多线程读写同一个 shared_ptr 对象必须加锁的原因。</p><h3 id="6-5-7、shared-ptr的引用计数源码"><a href="#6-5-7、shared-ptr的引用计数源码" class="headerlink" title="6.5.7、shared_ptr的引用计数源码"></a>6.5.7、shared_ptr的引用计数源码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;_Lock_policy _Lp &#x3D; __default_lock_policy&gt;   class _Sp_counted_base   : public _Mutex_base&lt;_Lp&gt;   &#123;   public:       _Sp_counted_base() noexcept     : _M_use_count(1), _M_weak_count(1) &#123; &#125;          virtual     ~_Sp_counted_base() noexcept     &#123; &#125;      &#x2F;&#x2F;当_M_use_count为0时调用，是个纯虚函数(必须实现)，这个函数的作用是释放指针指向的对象所持有的资源，即*this     virtual void     _M_dispose() noexcept &#x3D; 0;          &#x2F;&#x2F; 当_M_weak_count为0时调用，释放自己本身的资源，即this     &#x2F;&#x2F;  _M_weak_count &#x3D; _M_weak_count + (_M_use_count!&#x3D; 0),当_M_weak_count和_M_use_count都为0时释放this     virtual void     _M_destroy() noexcept     &#123; delete this; &#125;          virtual void*     _M_get_deleter(const std::type_info&amp;) noexcept &#x3D; 0;     &#x2F;&#x2F;增加一个引用     void     _M_add_ref_copy()     &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); &#125;      void     _M_add_ref_lock();      bool     _M_add_ref_lock_nothrow();      void     _M_release() noexcept     &#123;       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);  &#x2F;&#x2F;首先use_count减去1，并对比减操作之前的值，如果减之前是1，说明减后是0，a1没有任何shared_ptr指针指向它了将销毁对象if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) &#x3D;&#x3D; 1)  &#123;           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);    _M_dispose();    &#x2F;&#x2F;如果destory和dispose存在内存屏障，保证dispose函数的效果在destory函数的调用该线程的可见性    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)      &#123;   __atomic_thread_fence (__ATOMIC_ACQ_REL);      &#125;     &#x2F;&#x2F;同时对a1的weak_count减去1，也对比减操作之前的值，如果减之前是1，说明减后是0，a1没有weak_ptr指向它了，    &#x2F;&#x2F;应该将管理对象销毁，于是调用_M_destroy()销毁了管理对象           _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,                      -1) &#x3D;&#x3D; 1)             &#123;               _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);        _M_destroy();             &#125;  &#125;     &#125;      void     _M_weak_add_ref() noexcept     &#123; __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); &#125;      void     _M_weak_release() noexcept     &#123;       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) &#x3D;&#x3D; 1)  &#123;           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)      &#123;   __atomic_thread_fence (__ATOMIC_ACQ_REL);      &#125;    _M_destroy();  &#125;     &#125;     &#x2F;&#x2F;获取引用计数      long     _M_get_use_count() const noexcept     &#123;       return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);     &#125;    private:       _Sp_counted_base(_Sp_counted_base const&amp;) &#x3D; delete;     _Sp_counted_base&amp; operator&#x3D;(_Sp_counted_base const&amp;) &#x3D; delete;      _Atomic_word  _M_use_count;        _Atomic_word  _M_weak_count;      &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过其中的函数<code>_M_add_ref_copy()</code>实现可以看到，引用计数的增量操作是以atomic的原子类型进行的，故是线程安全的。<br>shared_ptr在多线程下传递使用时引用计数是不会有线程安全问题的，但是对shared_ptr对象的操作在多线程环境下却无法保证安全性，详见6.5.6节</p><h2 id="6-6、NULL、nullptr、0、nullptr-t"><a href="#6-6、NULL、nullptr、0、nullptr-t" class="headerlink" title="6.6、NULL、nullptr、0、nullptr_t"></a>6.6、NULL、nullptr、0、nullptr_t</h2><p>nullptr_t是个class，是nullptr的类型<br><font color=red>NULL、nullptr、0</font>均可表示空指针，区别如下：<br>C与C++中对NULL的定义</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Define NULL pointer value#ifndef NULL    #ifdef __cplusplus        #define NULL    0    #else  &#x2F;&#x2F; __cplusplus        #define NULL    ((void *)0)    #endif  &#x2F;&#x2F; __cplusplus#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C中NULL就是个void*，而C++中是0<br>C++ NULL为0可能引发的问题，可以通过函数重载的例子看出：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;memory&gt;void fun(int)&#123;    std::cout &lt;&lt; &quot;fuck1&quot; &lt;&lt; std::endl;&#125;void fun(void *)&#123;    std::cout &lt;&lt; &quot;fuck2&quot; &lt;&lt; std::endl;&#125;int main(int argc, char *argv[])&#123;    fun(NULL);    system(&quot;pause&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，我们传进去一个NULL，想要调用是参数为指针的重载函数fun，但实际调用的是int的版本。这是因为C++中NULL就是整形值(size_t)0，调用时当发现没有匹配size_t类型的重载函数，会发生隐式转换为int，进而与void fun(int)匹配。为解决此问题，C++引入了nullptr。</p><h3 id="6-6-1、nullptr"><a href="#6-6-1、nullptr" class="headerlink" title="6.6.1、nullptr"></a>6.6.1、nullptr</h3><p>nullptr并不是(void*)0的一个别名，nullptr是一个关键字、编译时期的常量，能够为编译器所识别。nullptr可以被隐式转换为任意类型的指针，但C++中(void*)不可以隐式转换，必须要显式指明被转换的指针类型</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int foo()&#123;int*px&#x3D;(void*)0;  &#x2F;&#x2F; 编译错误， 不能隐式地将无类型指针转换为int*类型的指针int*px&#x3D;(int *)((void*)0);  &#x2F;&#x2F;okint*py&#x3D;nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nullptr实际上是一个编译期行为，编译器会识别nullptr的存在，虽然编译时会将nullptr替换为一个指定整形，比如0，但由于其是编译期行为，明确知晓它是一个nullpter_t类型，进而可以有效规避NULL与0的重载问题</p><h2 id="6-7、this、空指针、野指针"><a href="#6-7、this、空指针、野指针" class="headerlink" title="6.7、this、空指针、野指针"></a>6.7、this、空指针、野指针</h2><ul><li>this指针<ul><li>this是指向类对象的指针，编译器会将this作为第一个参数传递给非静态成员函数；</li><li>this虽然是个指针，但它是一种特殊的指针，不能通过取地址符&amp;来获取this的指针地址，否则编译器会报错；</li><li>this既不占据类的内存空间，也不占据类对象的内存空间，通常存放在寄存器之中。</li></ul></li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Empty  &#x2F;&#x2F; 只占1byte，用于占位符&#123;&#125;;int main()&#123;    Empty obj;    std::cout &lt;&lt; sizeof(Empty) &lt;&lt; &quot;    &quot; &lt;&lt; sizeof(obj) &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">1    1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>空类以及空的类对象只占1Byte，说明this指针既不占据类的内存空间，也不占据类对象的内存空间</p><ul><li><p>this是一个指针常量，不能修改this指针的值；</p></li><li><p>空指针<br>被赋值为NULL、nullptr、0的指针</p></li><li><p>野指针<br>被delete、free且未被赋值为NULL、nullptr、0的指针</p></li></ul><p>空指针与野指针在内存访问行为上是有区别的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;    Car *ptr_one_car &#x3D; new Car(4);    std::cout &lt;&lt; &quot;01******&quot; &lt;&lt; std::endl;    ptr_one_car-&gt;print();    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\n02******&quot; &lt;&lt; std::endl;    delete ptr_one_car;  &#x2F;&#x2F; 野指针    ptr_one_car-&gt;print();    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;    ptr_one_car &#x3D; nullptr;  &#x2F;&#x2F; 空指针    std::cout &lt;&lt; &quot;\n03******&quot; &lt;&lt; std::endl;    ptr_one_car-&gt;print();    std::cout &lt;&lt; ptr_one_car-&gt;wheels_ &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">01******I have 4 wheeves402******I have 4 wheeves003******I have 4 wheevesSegmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、由于print函数并未访问任何类成员，所以并未使用到this指针，故不会报错；<br>2、访问类成员wheels_时需要使用this指针，而空指针是不允许被访问的，故03报core dumped错，而野指针虽然已被delete，但此内存区域仍存在，可能空闲也可能被他人使用或者被系统回收，所以野指针有些时候访问是OK的，存在不确定行为；</p><h2 id="6-8、函数指针"><a href="#6-8、函数指针" class="headerlink" title="6.8、函数指针"></a>6.8、函数指针</h2><p>函数指针的定义形如：</p><pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处便定了一个函数指针seq_ptr，指向的函数类型是const int *返回值，参数列表是char和float.<br>也可以像普通变量那样，为函数指针赋初值：</p><pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float) &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数指针数组：</p><pre class="line-numbers language-none"><code class="language-none">const int * (*seq_ptr)(char,float) &#x3D; &#123;    fibon_ptr, lucas_ptr, pell_ptr&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-9、原始指针的不妥"><a href="#6-9、原始指针的不妥" class="headerlink" title="6.9、原始指针的不妥"></a>6.9、原始指针的不妥</h2><p>原始指针存在的问题：     </p><ul><li>1、缓存区溢出 buffer overrun；</li><li>2、空悬指针/野指针；</li><li>3、重复释放double delete；</li><li>4、内存泄漏memory leak；</li><li>5、不配对的new[]/delete；</li><li>6、内存碎片memory fragmentation；</li></ul><p>针对以上的指针问题的解决方案：</p><ul><li>1、缓存区溢出：设计保存缓存区长度的成员；</li><li>2、空悬指针/野指针：智能指针解决；</li><li>3、重复释放：只在对象析构时释放；</li><li>4、内存泄漏：在对象析构时释放；</li><li>5、不配对的new[]/delete：把new[]替换成容器形式，逐一遍历delete；</li></ul><h2 id="6-10、、C-C-指针问题的根源"><a href="#6-10、、C-C-指针问题的根源" class="headerlink" title="6.10、、C/C++指针问题的根源"></a>6.10、、C/C++指针问题的根源</h2><p>指针就是指向一块内存，由操作系统管理，程序自身无从知晓内存是否越界、是否被释放等状态，既然无从知晓内存的状态，便无法判断一个指针是否有效，这就是C/C++指针问题的根源。  </p><ul><li>内存越界的判断是由CPU的(控制单元 + 地址寄存器)完成；</li><li>唯一能在程序中做的就是指针的判空行为，但此操作仅在单线程中有效，在多线程时便失效了，详见《服务器多线程编程》的1.4节。</li></ul>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-plus-贰</title>
      <link href="2021/07/10/C-plus-%E8%B4%B0/"/>
      <url>2021/07/10/C-plus-%E8%B4%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="7、关键字-amp-amp-修饰符"><a href="#7、关键字-amp-amp-修饰符" class="headerlink" title="7、关键字&amp;&amp;修饰符"></a>7、关键字&amp;&amp;修饰符</h1><h2 id="7-1、static"><a href="#7-1、static" class="headerlink" title="7.1、static"></a>7.1、static</h2><ul><li>隐藏<br>这是最重要的一个作用   <ul><li>作用域：具有static前缀的变量和函数仅当前源文件可见，故不能使用extern关键字；   </li><li>普通变量不能在头文件中定义，当被多个文件include时会报重复定义错误，需要使用extern关键字，才能将其具有跨文件作用域的全局性；   </li><li>静态变量和函数可以在头文件定义，不会报重复定义错误，因其不具备跨文件作用域的全局性。每个include的文件中都是独立分配的内存空间，彼此之间并无关联性；   </li></ul></li><li>生命周期<br>全局变量、静态全局变量、静态局部变量的生命周期都是整个程序运行期间</li><li>修饰C++类成员变量和函数<br>static成员属于整个类，不属于任何对象；<br>static成员变量内存只分配一次，对类的所有对象只有一份拷贝；<br>static成员变量和函数只能被本类访问，对类外不可见；<br>static成员函数不接收this指针，因此只能访问static成员；<br>static成员函数不能被virtual修饰，因为static成员不属于任何对象/实例，没有this指针，而virtual函数的实现是通过为每一有个对象分配一个vptr指针，而vptr是通过this指针调用地； </li></ul><h3 id="7-1-1、static特例场景"><a href="#7-1-1、static特例场景" class="headerlink" title="7.1.1、static特例场景"></a>7.1.1、static特例场景</h3><ul><li><p>static变量和函数的定义可以放在头文件，普通函数和变量的定义不能放在头文件，否则编译报错： ***** redefinition。 static变量和函数被include进源文件之后，都是独立的拷贝，彼此之间无关联；</p></li><li><p>类的static成员在类中定义之后，必须要在源文件中再显示定义一次，这是由static的两个属性决定的：</p><ul><li>static作用域仅限当前文件；</li><li>类的static成员只属于类，不属于类的对象；    </li></ul><p>所以必须要再次显示定义类static成员，为其在某一个源文件之中申请内存。</p></li></ul><p>否则编译报错：****undefined</p><h3 id="7-1-2、初始化时机及线程安全性"><a href="#7-1-2、初始化时机及线程安全性" class="headerlink" title="7.1.2、初始化时机及线程安全性"></a>7.1.2、初始化时机及线程安全性</h3><ul><li>全局变量、全局静态变量<ul><li>C语言中，它们的初始化发生在main函数之前，属于编译器常量；</li><li>C++中，对于非类对象的全局变量、全局静态变量，初始化时机与C语言一致；</li><li>C++中，类对象的全局变量、全局静态变量只有在第一次使用时才会进行初始化，这个’使用’包括显示调用该变量以及其他调用发生在其所在的源文件之中；<br>C++的对象必须由构造函数生成，并最终执行析构函数释放，由于构造动作需要执行相关代码，无法在编译期完成，所以类对象的全局变量、全局静态变量不是编译器常量，只有在第一次使用时才会进行初始化；</li></ul></li><li>局部静态变量<ul><li>C和C++中，都是第一次使用时才会进行初始化；</li></ul></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;class Wheel&#123;public:    Wheel()&#123;std::cout &lt;&lt; &quot;Wheel constructor&quot; &lt;&lt; std::endl;&#125;    ~Wheel()&#123;&#125;&#125;;class Window&#123;public:    Window()&#123;std::cout &lt;&lt; &quot;Window constructor&quot; &lt;&lt; std::endl;&#125;    ~Window()&#123;&#125;&#125;;class Car&#123;public:    Car()&#123;std::cout &lt;&lt; &quot;Car constructor&quot; &lt;&lt; std::endl;&#125;    ~Car()&#123;&#125;    void print()    &#123;        static Window four_windows;        std::cout &lt;&lt; &quot;I have four windows&quot; &lt;&lt; std::endl;    &#125;    static Wheel four_wheels;&#125;;Wheel Car::four_wheels;int main()&#123;    std::cout &lt;&lt; &quot;step in main&quot; &lt;&lt; std::endl;    Car my_car;    my_car.print();    std::cout &lt;&lt; &quot;step out main&quot; &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Wheel constructorstep in mainCar constructorWindow constructorI have four windowsstep out main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然并没有显式调用静态变量four_wheels，但声明语句’Wheel Car::four_wheels;’被放在main.cpp源文件之中，main函数的调用也发生在此文件之中，所以静态变量four_wheels完成了它的第一次使用；   </p><p>假如声明语句’Wheel Car::four_wheels;’放在另一个不相干的源文件之中，比如a.cpp，且没有任何的调用牵涉到a.cpp文件，那么静态变量four_wheels就没有被使用，运行结果也便不会打印’Wheel constructor’     </p><ul><li><strong>线程安全性</strong><ul><li>非类对象的全局变量、全局静态变量的初始化发生在main函数之前，故不存在线程安全性问题；</li><li>类对象的全局变量、全局静态变量以及局部静态变量，只有当第一次使用时才会进行初始化，故存在线程安全性问题。C++11之前并未对此有强制要求，故其线程安全性是存在问题的，但C++标准对此有了强制要求，要求编译器实现其线程安全性，例如g++使用了类似全局锁的方式解决此问题；</li></ul></li></ul><h3 id="7-1-3、优势"><a href="#7-1-3、优势" class="headerlink" title="7.1.3、优势"></a>7.1.3、优势</h3><ul><li>static变量和函数会在静态存储区申请空间，具有完整声明周期，与程序声明周期相同。在static变量访问、static函数调用时不用反复出栈入栈；</li><li>static变量和函数仅限当前文件作用域，故其他文件可以有相同名称的变量和函数；</li></ul><h2 id="7-2、const"><a href="#7-2、const" class="headerlink" title="7.2、const"></a>7.2、const</h2><p>const并不能代表”常量”，它仅仅是对变量的一种修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过指针间接的修改）。而这个变量的值，既可以在运行时也可以在编译时指定。    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">const int a &#x3D; 123;  &#x2F;&#x2F;  编译时常量void getResult(const int b);  &#x2F;&#x2F;  运行时常量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>const可以修饰变量、函数、指针、函数返回值、形参、类成员变量、类成员函数</p><ul><li>设置变量常量性，定义时既要初始化。对于类的const成员变量则必须在初始化列表里进行初始化，也可在class的声明处初始化，此方法与在构造函数的初始化列表里初始化相同，如果此时初始化列表重新指定值，那么声明时的值就会被修改掉；</li><li>对于指针来说，可以修饰指针本身int *const ptrA，也可以修饰指针指向的对象const int *ptrA、int const *ptrA;</li><li>修饰函数返回值const int functionName()，使其返回值不能为”左值”，不能被修改，例如返回指向堆的指针；</li><li>指定类成员函数为常函数，int functionName() const，不能修改类的成员变量。类的常量对象只能访问类的常函数；</li><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>const属性可以通过类型转换符const_cast转换为非const；</li></ul><p>示例：    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">①const Stock &amp; Stock::topval (②const Stock &amp; s)③const   ①处const：确保返回的Stock对象在以后的使用中不能被修改②处const：确保此方法不修改形参s，或者说不能修改传递给形参s的实参③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-1、const特例场景"><a href="#7-2-1、const特例场景" class="headerlink" title="7.2.1、const特例场景"></a>7.2.1、const特例场景</h3><ul><li>const变量的定义可以放在头文件，普通变量的定义不能放在头文件，否则编译报错： ***** redefinition。 const变量被include进源文件之后，都是独立的拷贝，彼此之间无关联；</li><li>const之于函数重载<ul><li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参，则这个时候无论加不加const对实参不会产生任何影响；</li><li>但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。所以，只有引用传递和指针传递可以用是否加const来重载，而值传递的const不具备重载性；</li></ul></li></ul><h2 id="7-3、mutable"><a href="#7-3、mutable" class="headerlink" title="7.3、mutable"></a>7.3、mutable</h2><p>如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;</p><h2 id="7-4、extern"><a href="#7-4、extern" class="headerlink" title="7.4、extern"></a>7.4、extern</h2><ul><li>声明外部属性，修饰变量、函数；</li><li>指示C、C++编译规范：<br>比如在C＋＋中调用C库函数，就需要在C＋＋程序中用如下命令声明要引用的函数   <pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef __cplusplusextern &quot;C&quot; &#123;#endifvoid print(char *);    #ifdef __cplusplus&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</li></ul><h2 id="7-5、inline"><a href="#7-5、inline" class="headerlink" title="7.5、inline"></a>7.5、inline</h2><p>inline用于定义内联函数<br><strong>产生背景：</strong>    </p><ul><li>函数调用时需要出栈入栈，频繁的出入栈时间成本增加，且会造成栈空间的大量消耗；</li><li>取代宏表达式，内联函数与普通函数一样，编译时会进行严格的类型检查，不像宏表达式没有类型检查，只是简单的文本替换，且宏表达式的编译错误很难发现；</li></ul><p><strong>PS：</strong>   </p><ul><li><p>inline只是对编译器的一种建议，编译器并不一定会将函数变成内联函数，是否内联依赖于函数具体实现、编译选项等因素：   </p><ul><li>默认编译优化选项-O0时inline不起作用，-O2、-O3时inline会生效；</li><li>存在inline函数的指针调用时，inline在调用位置失去内联属性，与普通函数无异；</li><li>存在结构控制语句时不生效，例如while、switch、for；</li><li>函数体实现过长时也不生效；</li></ul></li><li><p>inline函数定义可以放在头文件之中，符合语法规则。因为inline函数在调用处就地展开，不同调用处均是互不相干inline的函数副本；</p></li><li><p>inline函数只能有定义，不能单独进行声明，类成员函数除外，说明如下：</p><ul><li>声明处的inline是无效的，编译会报错：***** is not defined<br>因为inline函数编译期需要在调用处直接展开，它不能像普通函数一样通过声明去找函数定义体，所以要求inline的声明和定义必须是一体的，类成员函数除外。<br>示例：<br>假如inline的声明和定义是分开的，不管声明处是否显式包含inline，编译都会报错<pre class="line-numbers language-C" data-language="C"><code class="language-C">inline void func(void)ERROR: inline function func is not defined  &#x2F;&#x2F;inline函数声明void func(void)ERROR: function func is not defined  &#x2F;&#x2F;报错信息不同于上面的例子，这是因为声明处是普通函数func，它会去源文件中查找函数func的定义，而源文件中只有inline func，二者是没有关联的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p><strong>使用场景：</strong>   </p><ul><li>函数定义较短，且调用的地方不是很多。这是因为内联函数的汇编代码会在调用处展开，如果函数体过大或调用处过多，会造成代码膨胀；    </li></ul><p>内联函数在编译时会就地展开，不生成独立汇编码，<strong>不会生成函数名，所以也不会添加进符号表之中</strong>，故在文件作用域外无法调用inline函数，否则编译报错：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">undefined reference to ***<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-6、constexpr"><a href="#7-6、constexpr" class="headerlink" title="7.6、constexpr"></a>7.6、constexpr</h2><p>首先了解两个概念：</p><ul><li>编译时常量；</li><li>运行时常量；</li></ul><p>通常来讲运行时常量是指使用const修饰的对象，const可以修饰函数参数、函数返回值、函数本身、类等，在不同的使用条件下，const有不同的意义，不过大多数情况下，const描述的都是一些”运行时常量性”的概念，即具有运行时数据的不可更改性。不过有的时候，我们需要的却是编译时期的常量性，这是const关键字无法保证的。</p><pre class="line-numbers language-none"><code class="language-none">const int GetConst()&#123;return 1;&#125;void Constless(int cond)&#123;    int arr[GetConst()]&#x3D;&#123;0&#125;;&#x2F;&#x2F;无法通过编译    enum&#123;e1&#x3D;GetConst(),e2&#125;;&#x2F;&#x2F;无法通过编译    switch(cond)        &#123;            case GetConst():&#x2F;&#x2F;无法通过编译            break;            default:            break;        &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组大小、枚举值和switch均是需要编译时常量。   </p><p>此时便需要常量表达式，将函数或值转换为常量表达式函数或常量表达式值，例如：</p><pre class="line-numbers language-none"><code class="language-none">constexpr int GetConst()&#123;return 1;&#125;constexpr int i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常量表达式主要是允许一些计算发生在编译时Compile-time calculation。<br>constexpr可以使代码具有编译时运算的能力，同inline关键字类似，但constexpr只是一种建议，是否发挥作用还取决于具体的调用。</p><p>constexpr可以修饰变量、函数、构造函数</p><h3 id="7-6-1、constexpr修饰函数时的限制"><a href="#7-6-1、constexpr修饰函数时的限制" class="headerlink" title="7.6.1、constexpr修饰函数时的限制"></a>7.6.1、constexpr修饰函数时的限制</h3><ul><li>函数体只能有一个return语句（C++14之后此限制放开了，只要return语句返回的是常量即可）；</li><li>只能调用其他constexpr函数；</li><li>只能使用全局constexpr变量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">constexpr int32_t getValue() &#123;return 1;&#125;constexpr int32_t getLength(int32_t i) &#123;return i + 2;&#125;constexpr int32_t getLength02(int32_t i)&#123;    i +&#x3D; 2;    return i;&#125;int main()&#123;    int32_t i &#x3D; 3;    int32_t nums01[getValue()] &#x3D; &#123;1&#125;;  &#x2F;&#x2F; ok    int32_t nums02[getLength(1)] &#x3D; &#123;3&#125;;  &#x2F;&#x2F; ok    int32_t nums03[getLength02(2)] &#x3D; &#123;4&#125;;  &#x2F;&#x2F; ok        std::cout &lt;&lt; nums01[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums02[0] &lt;&lt; &quot;    &quot; &lt;&lt; nums03[0] &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-6-2、constexpr修饰构造函数"><a href="#7-6-2、constexpr修饰构造函数" class="headerlink" title="7.6.2、constexpr修饰构造函数"></a>7.6.2、constexpr修饰构造函数</h3><p>可以构造函数声明为constexpr，则在编译期就可以构造类对象，要求构造函数调用处传入的参数都必须是常量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Circle&#123;    public:    constexpr Circle (int x, int y, int radius) : _x( x ), _y( y ), _radius( radius ) &#123;&#125;    constexpr double getArea ()    &#123;        return _radius * _radius * 3.1415926;    &#125;    private:        int _x;        int _y;        int _radius;&#125;;constexpr Circle temCircle(0, 0, 10);  &#x2F;&#x2F; 编译期执行构造函数，计算半径为10的Circle面积<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-6-3、constexpr与const"><a href="#7-6-3、constexpr与const" class="headerlink" title="7.6.3、constexpr与const"></a>7.6.3、constexpr与const</h3><pre class="line-numbers language-none"><code class="language-none">const int i&#x3D;1;constexpr int j&#x3D;1;  &#x2F;&#x2F; 常量表达式值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>大多数情况下这两种声明方式没有区别，都是将变量声明为常量，主要不同之处在于i不能用于编译期常量的场景，比如数组大小、枚举值和switch值等。</p><h2 id="7-7、mallloc-free和new-delete的区别"><a href="#7-7、mallloc-free和new-delete的区别" class="headerlink" title="7.7、mallloc/free和new/delete的区别"></a>7.7、mallloc/free和new/delete的区别</h2><ul><li>malloc/free是C语言的库函数，而new/delete是C++的关键字，故他们不能被重载，但它们的二级调用operator new / operator delete可以被重载；</li><li>malloc/free只能用于基本类型，而new/delete不但可以用于基本类型还可用于自定义类型；</li><li>malloc返回的是void*类型，需要显示转换为指定类型，new不涉及类型转换的问题；</li><li>maloc只负责申请空间，并返回首地址，new运算符除了申请空间，还调用构造函数进行初始化。free函数只负责释放空间，并标识这段空间是可用空间，delete除了释放空间，还调用析构函数；</li></ul><p>事实上，new/delete的功能已经完全覆盖了malloc/free。</p><h2 id="7-8、delete和delete-的区别"><a href="#7-8、delete和delete-的区别" class="headerlink" title="7.8、delete和delete[]的区别"></a>7.8、delete和delete[]的区别</h2><p>对于基本类型delete和delete[]没有区别，都可以正常释放单个空间或数组空间，对于数组空间，系统可以根据数组长度和数据类型计算出数组所占空间，然后一次性释放。    </p><p>但是对于自定义类型，delete只会释放数组的第一个元素，其他元素空间并不会释放，而delete[]可以循环释放数组所有元素的空间。</p><h1 id="8、异常处理"><a href="#8、异常处理" class="headerlink" title="8、异常处理"></a>8、异常处理</h1><p>异常处理机制主要包含两个部分：</p><ul><li>异常的鉴定与抛出；</li><li>异常的捕获与处理</li></ul><p>异常抛出之后，当前的执行流程会被暂停，然后在程序的全局范围内搜索可以捕获此异常的地方，异常处理完之后，程序会从异常处理点继续往下执行（<strong>不一定是抛出异常的地方</strong>）    </p><p>异常处理提供了一种转移程序控制权的方式    </p><p>程序运行时常会碰到一些异常情况，例如：</p><ul><li>做除法的时候除数为 0；</li><li>用户输入年龄时输入了一个负数；</li><li>用 new 运算符动态分配空间时，空间不够导致无法分配；</li><li>访问数组元素时，下标越界；打开文件读取时，文件不存在；</li></ul><p>这些异常情况如果不能被发现并加以处理，很可能会导致程序崩溃</p><p>所谓”处理”，可以是给出错误提示信息，然后让程序沿一条不会出错的路径继续执行；也可能是不得不结束程序，但在结束前做一些必要的工作，如将内存中的数据写入文件、关闭打开的文件、释放动态分配的内存空间等。   </p><p>一发现异常情况就立即处理未必妥当，因为在一个函数执行过程中发生的异常，在有的情况下由该函数的调用者决定如何处理更加合适。</p><p>此外，将异常分散在各处进行处理不利于代码的维护，如果能在发生各种异常时让程序都执行到同一个地方，这个地方能够对异常进行集中处理，则程序就会更容易编写、维护。</p><p>C++ 引入了异常处理机制。其基本思想是：函数A在执行过程中发现异常时可以不加处理，而只是”拋出一个异常”给 A的调用者，假定为函数B。拋出异常而不加处理会导致函数A立即中止，在这种情况下，函数B可以选择捕获A拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。</p><p>如果一层层的函数都不处理异常，异常最终会被拋给最外层的main函数。main函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。</p><h2 id="8-1、抛出异常"><a href="#8-1、抛出异常" class="headerlink" title="8.1、抛出异常"></a>8.1、抛出异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;异常的抛出if(a &gt; b)throw compare_class_obj(a,b);if(a &lt;&#x3D; b)......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当a大于b的时候，异常便会以类为compare_class_obj的对象抛出。<br>所谓抛出异常(throw exception)抛出的是一个实体，这个实体可以是一个复杂的类对象，也可以是一个简单的整形或字符串</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">throw 42;throw &quot;error: no buffer&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8-2、捕获异常"><a href="#8-2、捕获异常" class="headerlink" title="8.2、捕获异常"></a>8.2、捕获异常</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">bool catchOperator()&#123;    catch(int errno)    &#123;        ......    &#125;    catch(const char*str)    &#123;        ....    &#125;    catch(compare_class_obj &amp;it)    &#123;        ....    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被抛出异常对象的类型会被拿来逐一地与catch子句对比，如果类型符合，那么该catch子句便会被执行。<br>如果想要捕获所有类型的异常，可以使用一网打尽的方式，只需要在catch中使用(…)即可</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">catch(...)    &#123;        ....    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-3、try、catch组合"><a href="#8-3、try、catch组合" class="headerlink" title="8.3、try、catch组合"></a>8.3、try、catch组合</h2><p>try和catch通常搭配使用，try语句块抛出异常，catch语句块捕获异常</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include&lt;exception&gt;using namespace std;   int main()&#123;   cout &lt;&lt; &quot;Enter number of integers you wish to reserve: &quot;;   try   &#123;      int Input &#x3D; 0;      cin &gt;&gt; Input;      &#x2F;&#x2F; Request memory space and then return it      int* pReservedInts &#x3D; new int [Input];  &#x2F;&#x2F; new操作中包含throw语句      delete[] pReservedInts;     &#125;   catch (std::bad_alloc&amp; exp)   &#123;      cout &lt;&lt; &quot;Exception encountered: &quot; &lt;&lt; exp.what() &lt;&lt; endl;      cout &lt;&lt; &quot;Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   catch(...)   &#123;      cout &lt;&lt; &quot;Exception encountered. Got to end, sorry!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::bad_alloc表明捕获内存申请异常</p><p><strong>==配合throw自定义异常==</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;iostream&gt;using namespace std;double Divide(double Dividend, double Divisor)&#123;   if(Divisor &#x3D;&#x3D; 0)      throw &quot;Dividing by 0 is a crime&quot;;   return (Dividend &#x2F; Divisor);&#125;int main()&#123;   cout &lt;&lt; &quot;Enter dividend: &quot;;   double Dividend &#x3D; 0;   cin &gt;&gt; Dividend;   cout &lt;&lt; &quot;Enter divisor: &quot;;   double Divisor &#x3D; 0;   cin &gt;&gt; Divisor;   try   &#123;      cout &lt;&lt; &quot;Result of division is: &quot; &lt;&lt; Divide(Dividend, Divisor);   &#125;   catch(char* exp)   &#123;      cout &lt;&lt; &quot;Exception: &quot; &lt;&lt; exp &lt;&lt; endl;      cout &lt;&lt; &quot;Sorry, can&#39;t continue!&quot; &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-4、标准异常基类std-exception"><a href="#8-4、标准异常基类std-exception" class="headerlink" title="8.4、标准异常基类std::exception"></a>8.4、标准异常基类std::exception</h2><p>头文件：   </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdexcept&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>C++提供了标准异常基类，以及一些标准异常派生类<br><img src="http://note.youdao.com/yws/public/resource/892d9e7fee7b3f46884b29983e9b7cac/xmlnote/WEBRESOURCE79dc7e0746bf807241a0c16fb37ce99c/38324" alt="image04"></p><p>这些都是exception的派生类，当有异常发生时，即使没有显式的throw语句，也会抛出相应的异常，派生类中都会实现虚函数what，用于返回异常的描述信息</p><p>示例：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;class Base&#123;    virtual void func() &#123;&#125;&#125;;class Derived : public Base&#123;public:    void Print() &#123;&#125;&#125;;void PrintObj(Base &amp; b)&#123;    try &#123;        Derived &amp; rd &#x3D; dynamic_cast &lt;Derived &amp;&gt;(b);        &#x2F;&#x2F;此转换若不安全，会拋出 bad_cast 异常        rd.Print();    &#125;    catch (bad_cast &amp; e) &#123;        cerr &lt;&lt; e.what() &lt;&lt; endl;    &#125;&#125;int main()&#123;    Base b;    PrintObj(b);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br>Bad dynamic_cast!</p><p><strong>==自定义异常派生类==</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std; struct MyException : public exception&#123;  const char * what () const throw ()  &#123;    return &quot;C++ Exception&quot;;  &#125;&#125;; int main()&#123;  try  &#123;    throw MyException();  &#125;  catch(exception&amp; e)  &#123;    std::cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br>MyException caught<br>C++ Exception</p><h1 id="9、类型转换"><a href="#9、类型转换" class="headerlink" title="9、类型转换"></a>9、类型转换</h1><p>C语言中的类型转换包括隐式类型转换、显式类型转换(也称作强制类型转换)，但有些情况下转换操作并不安全，比如可将指针转换成任意类型，编译是正常，而在运行期可能引发无法预估的问题。<br>C++引入了多种可供选择的类型转换方法</p><h2 id="9-1、向上转换、向下转换"><a href="#9-1、向上转换、向下转换" class="headerlink" title="9.1、向上转换、向下转换"></a>9.1、向上转换、向下转换</h2><p>具有继承关系的类之间双向转换操作：</p><ul><li>向上转换，派生类向基类转换；</li><li>向下转换，基类向派生类转换；</li></ul><h2 id="9-2、static-cast"><a href="#9-2、static-cast" class="headerlink" title="9.2、static_cast"></a>9.2、static_cast</h2><ul><li><strong>==编译期类型转换检查==</strong>,只做编译阶段检查，不会在运行阶段检查；</li><li>操作对象可以是基本类型，也可以是具有继承关系的类；</li><li>不支持不具备继承关系的类之间的转换；</li><li>普通对象变量(非指针、非引用)只能向上转换；</li><li>指针、引用对象变量支持向上、向下转换；参考：<a href="">4.9.6、对象调用成员变量、成员函数的原理</a></li><li> 虽然指针、引用对象可以向下类型转换，但运行期是不安全的，可能引发不确定行为，比如空指针异常、访问未初始化的地址空间等；</li></ul><p>**==类似于c语言的显式类型转换==**，但没有显式类型转换那么暴力，不相关的类型之间转换会报错，比如没有继承关系的类之间、指针转整形操作等。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Base&#123;    .......&#125;class Dev : public Base&#123;    .......&#125;class NoDev&#123;    .......&#125;int main()&#123;    char ca &#x3D; &#39;a&#39;;    int ia &#x3D; static_cast&lt;int&gt;(ca);  &#x2F;&#x2F; OK    float *pa &#x3D; static_cast&lt;float*&gt;(ca);  &#x2F;&#x2F; error        Base base01;    Dev dev01 &#x3D; static_cast&lt;Dev&gt;(base01);  &#x2F;&#x2F; error，普通对象变量不支持向下转换        Dev dev02;    Base base02 &#x3D; static_cast&lt;Base&gt;(dev02);  &#x2F;&#x2F; OK        Base *pBase &#x3D; new Base();    Dev *pDev &#x3D; new Dev();    pDev &#x3D; static_cast&lt;Dev&gt;(pBase);  &#x2F;&#x2F; OK    pBase &#x3D; static_cast&lt;Base&gt;(pDev);  &#x2F;&#x2F; OK        Base base03;    NoDev no_dev &#x3D; static_cast&lt;NoDev&gt;(base03);  &#x2F;&#x2F; error，Base与NoDev之间不存在继承关系        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3、dynamic-static"><a href="#9-3、dynamic-static" class="headerlink" title="9.3、dynamic_static"></a>9.3、dynamic_static</h2><p>由于static_cast只在编译阶段检查，继承类之间向下类型转换在运行期存在不安全行为，dynamic_static可以执行运行期检查</p><ul><li>运行期类型转换检查；</li><li>只针对类的指针、引用对象，不支持普通对象、基础类型；</li><li>可以实现运行期安全的向下类型转换操作；</li><li>类指针向下转换失败返回nullptr，类引用向下转换失败返回bad_cast异常;</li><li>支持向上转化，但由于向上转换本来就是安全的，考虑到dynamic_static比较耗时，故向上类型转换不建议使用dynamic_static；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stdafx.h&quot;#include&lt;iostream&gt;using namespace std;class Base&#123;public:    Base()&#123;&#125;;    virtual void Show()&#123;cout&lt;&lt;&quot;This is Base calss&quot;;&#125;&#125;;class Derived:public Base&#123;public:    Derived()&#123;&#125;;    void Show()&#123;cout&lt;&lt;&quot;This is Derived class&quot;;&#125;&#125;;int main()&#123;    &#x2F;&#x2F; ************************类指针    Base* base &#x3D; new Derived();    if(Derived *der&#x3D; dynamic_cast&lt;Derived*&gt;(base))  &#x2F;&#x2F; OK，因为Base指针本来就指向继承类    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der-&gt;Show();        cout&lt;&lt;endl;    &#125;        Base * base1 &#x3D; new Base;    if(Derived *der1 &#x3D; dynamic_cast&lt;Derived*&gt;(base1))  &#x2F;&#x2F; error，向下转换失败    &#123;        cout&lt;&lt;&quot;success&quot;&lt;&lt;endl;        der1-&gt;Show();    &#125;    else     &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;    delete(base);    delete(base1);        &#x2F;&#x2F; ************************类引用    Derived b ;    Base &amp;base1&#x3D; b;    Derived &amp;der1 &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base1);  &#x2F;&#x2F; OK    Base a ;    Base &amp;base &#x3D; a ;    try&#123;        Derived &amp; der &#x3D; dynamic_cast&lt;Derived&amp;&gt;(base);  &#x2F;&#x2F; error    &#125;    catch(bad_cast)    &#123;        cout&lt;&lt;&quot;error&quot;&lt;&lt;endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-4、reinterpret-cast"><a href="#9-4、reinterpret-cast" class="headerlink" title="9.4、reinterpret_cast"></a>9.4、reinterpret_cast</h2><ul><li>只支持指针、引用的类型转换操作；</li></ul><p>可以将指针、引用转换成不相关的类型，包括基础类型、没有继承关系的类；<br>与C语言最接近的类型转换符，用于强制转换，通常在较低级的程序中使用</p><h2 id="9-5、const-cast"><a href="#9-5、const-cast" class="headerlink" title="9.5、const_cast"></a>9.5、const_cast</h2><ul><li>增加或修改类型限定符const;</li><li>只支持指针、引用的类型转换操作；</li><li>只能修改类型限定符，不能更改基础类型，即向上、向下转换，比如Derived *转换成const Base *是不允许的；</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">const Base *base01 &#x3D; new Base();Base *base02 &#x3D; const_cast&lt;Base*&gt;(base01);const Base * const base03 &#x3D; new Base();Base *base04 &#x3D; const_cast&lt;Base*&gt;(base03);Base *base05 &#x3D; new Base();const Base *base06 &#x3D; const_cast&lt;const Base*&gt;(base05);const Detived *dev01 &#x3D; new Derived();Base *base02 &#x3D; const_cast&lt;Base*&gt;(dev01);  &#x2F;&#x2F; error，不允许改变基础类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10、类型推导"><a href="#10、类型推导" class="headerlink" title="10、类型推导"></a>10、类型推导</h1><p>通常C和C+被称作静态类型语言，因为数据类型必须显示声明，而例如python、javascrip等被称作动态语言，它们的变量可以不指定类型，在编译阶段会自动推导。<br>C++中类型推导主要应用在模板、auto、decltype之中，模板的类型推导是基于auto演变而来，auto用于类型推导，而decltype用于获取类型</p><h2 id="10-1、模板类型推导"><a href="#10-1、模板类型推导" class="headerlink" title="10.1、模板类型推导"></a>10.1、模板类型推导</h2><p>模板函数伪代码：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(ParamType para);func(expr);  &#x2F;&#x2F; 以表达式expr创建模板函数实例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在编译期编译器会通过expr（也可以理解成实参）推导两个型别：</p><ul><li>模板类型T的型别；</li><li>函数形参ParamType（也可以理解错形参）的型别；</li></ul><p>T与ParamType之间的关系要视具体情况而言，比如：   </p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(const T&amp; para);int x &#x3D; 0;func(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>T被推导为int，ParamType被推导为const int&amp;。<br>我们很自热的认为T的型别与传入的实参expr型别是一样的，其实这一点并不总是成立，T的型别推导不仅仅依赖于expr，还依赖于ParaType，具体可分为以下三种情况讨论：   </p><ul><li>ParamType具有指针或引用型别，但不是个万能引用；</li><li>ParamType是个万能引用；</li><li>ParamType既非指针也非引用；</li></ul><p><font color=red><strong>此三种场景均遵循如下类型推导规则:</strong></font></p><ul><li>根据实参确定形参的类型；</li><li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li><li>模式匹配出T及ParamType类型；</li></ul><h3 id="10-1-1、ParamType是个指针或引用，但不是万能引用"><a href="#10-1-1、ParamType是个指针或引用，但不是万能引用" class="headerlink" title="10.1.1、ParamType是个指针或引用，但不是万能引用"></a>10.1.1、ParamType是个指针或引用，但不是万能引用</h3><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>func(x)中实参x传递给形参T&amp;，可确定ParamType类型是int &amp;，然后模式匹配结果T为int；</li><li>func(cx)中cx是const int，传递给形参T&amp;，func形参的意图是作为实参的引用，此时实参具备const性，即不希望后续操作中其值被修改，而且此时实参是按照引用传递的，那么便可确定ParamType类型是const int &amp;，T类型是const int;</li><li>func(rx)推导规则同样；</li></ul><p><font color=purple>当向引用型别的形参传入const对象时，他们期望该对象保持其不可被修改的属性，这也就是为何向持有T&amp;的型别模板传入const对象是安全的。 </font>   </p><p>若将模板中的T&amp;改成cosnt T&amp;，推导结果会略有不同：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(cosnt T&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是const int&amp;func(cx);  &#x2F;&#x2F; T是int，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是int，  para是const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于ParamType已经具有const属性，故模式匹配时T不会包含const属性。    </p><p>若将T&amp;换成指针T*，推导结果基本相同：  </p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T* para);int x &#x3D; 27;const int *px &#x3D; &amp;x;func(&amp;x);   &#x2F;&#x2F; T是int， para是int*func(px);   &#x2F;&#x2F; T是const int，  para是const int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-1-2、ParamType是个万能引用"><a href="#10-1-2、ParamType是个万能引用" class="headerlink" title="10.1.2、ParamType是个万能引用"></a>10.1.2、ParamType是个万能引用</h3><p>模板类型推导遵循引用折叠规则，详见<strong>5.6</strong>节</p><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T&amp;&amp; para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int&amp;， para是int&amp;func(cx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(rx);  &#x2F;&#x2F; T是const int&amp;，  para是const int&amp;func(27);  &#x2F;&#x2F; T是int， para是int&amp;&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-1-3、ParamType既非指针也非引用"><a href="#10-1-3、ParamType既非指针也非引用" class="headerlink" title="10.1.3、ParamType既非指针也非引用"></a>10.1.3、ParamType既非指针也非引用</h3><p>当ParamType即非指针也非引用时，它想表达的意图是接收实参的一个副本，也即一个全新对象。ParamType会是一个全新对象这一事实促成了如何从expr推导出T的型别规则：</p><ul><li>若实参具有引用型别，则形参是想借由实参构造一个全新的对象，故引用型别不被保留，若实参是指针类型，则实参传递的是指针的副本，指针* 会被保留；</li><li>由于实参传递给形参是一个副本，故const属性不会被保留；</li><li>特例：实参const T *、T const *的const会保留，是因为这里的const修饰的是指针指向的对象，并不是指针自身，所以T *const不会保留const属性；</li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参为非指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是int，  para是intfunc(rx);  &#x2F;&#x2F; T是int，  para是int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使cx和rx代表const值，para仍然不具有const型别，因为para是个完全独立于cx和rx存在的对象，从而cx和rx的不可修改属性并不会传递给para。       </p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 实参是指针类型template&lt;typename T&gt;void func(T para);int x &#x3D; 27;const int *cx &#x3D; &amp;x;int * const cx02 &#x3D; &amp;x;int *rx &#x3D; &amp;x;func(x);   &#x2F;&#x2F; T是int， para是intfunc(cx);  &#x2F;&#x2F; T是const int *，  para是const int *func(cx02);  &#x2F;&#x2F; T是int *，  para是int *func(rx);  &#x2F;&#x2F; T是int *，  para是int *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-2、auto类型推导"><a href="#10-2、auto类型推导" class="headerlink" title="10.2、auto类型推导"></a>10.2、auto类型推导</h2><p>auto类型推导表达式在编译时确定变量类型，auto所修饰的变量必须被初始化<br>推导规则与模板类型推导遵循如下规则：</p><ul><li>根据实参确定形参的类型；</li><li>根据实参到形参的传递过程是按值还是按地址传递确定const传递与否；</li><li>模式匹配出T及ParamType类型；</li></ul><p>示例：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;auto *a &#x3D; &amp;x;  &#x2F;&#x2F;a-&gt;int *auto b &#x3D; &amp;x;   &#x2F;&#x2F;b-&gt;int *auto &amp;c&#x3D; x;    &#x2F;&#x2F;c-&gt;int &amp;auto d&#x3D;c;      &#x2F;&#x2F;d-&gt;intconst auto e &#x3D; x;  &#x2F;&#x2F;e-&gt;const intauto f &#x3D; e;        &#x2F;&#x2F;f-&gt;intconst auto&amp;g &#x3D; x;  &#x2F;&#x2F;g-&gt;const int &amp;auto&amp; h &#x3D; g;   &#x2F;&#x2F;h-&gt;const int&amp; const int *j &#x3D; &amp;x;auto k &#x3D; j;  &#x2F;&#x2F; k-&gt;const int *int *const m &#x3D; &amp;x;auto n &#x3D; m;  &#x2F;&#x2F; n-&gt;int *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red><strong>特殊示例:</strong></font>  </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto x &#x3D; 5;   &#x2F;&#x2F; intauto pi &#x3D; new auto(1);  &#x2F;&#x2F;int *const auto *v&#x3D;&amp;x, u &#x3D; 6;  &#x2F;&#x2F;v是const int*, u是const intstatic auto y &#x3D; 0.0;  &#x2F;&#x2F;doubleauto yt&#123;1&#125;;  &#x2F;&#x2F;使用初始化列表的auto，auto被推导出初始化列表容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当经过v推导出auto为int之后，u仍然需要显示指定为6，以防在经过u推导时，auto出现二义性，比如u=6.0，编译器就会报错。<br>auto不能代表一个实际的类型声明，而是一个类型的占位符，在编译期间替换为真正的类型，使用auto必须马上初始化。</p><p>数组形式的大括号初始化auto推导，详见<strong>10.3.3</strong>节</p><h3 id="10-2-1、auto的限制"><a href="#10-2-1、auto的限制" class="headerlink" title="10.2.1、auto的限制"></a>10.2.1、auto的限制</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;void func(auto a &#x3D; 1);  &#x2F;&#x2F;error:auto不能用于函数参数struct Foo&#123;auto var1_ &#x3D; 0;  &#x2F;&#x2F;error:auto不能用于非静态成员变量static const auto var2_ &#x3D; 0;&#125;;template &lt;typename T&gt;struct Bar &#123;&#125;;int main(void)&#123;int arr[10] &#x3D; &#123;0&#125;;auto aa &#x3D; arr;  &#x2F;&#x2F;OK: aa -&gt; int *，数组名arr退化成指针auto rr[10] &#x3D; arr;  &#x2F;&#x2F;error:auto无法定义数组Bar&lt;int&gt; bar;Bar&lt;auto&gt; bb &#x3D; bar;  &#x2F;&#x2F;error:auto无法推导出模板参数system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>auto不能用于函数参数的类型推导，即使有默认值也不行；</li><li>auto不能用于非静态成员变量的类型推导（仅针对于结构体和类中的成员，即使有默认值也不行），同时仅能用于推导static const的整型或枚举成员；</li><li>auto不能用于数组类型推导；</li><li>auto不能用于模板参数类型推导；</li></ul><h2 id="10-3、decltype"><a href="#10-3、decltype" class="headerlink" title="10.3、decltype"></a>10.3、decltype</h2><p>auto声明的变量必须要初始化，而有时我们仅仅只是想知道表达式的类型，可以使用decltype来实现，它的推导过程也是在编译期完成。   </p><p>decltype获取数据类型的规则通常是所见即所得，但也有例外，特殊情况包括const限定符、函数返回值类型、重载函数、标记符表达式等，详见<strong>10.3.2</strong>节</p><h3 id="10-3-1、示例"><a href="#10-3-1、示例" class="headerlink" title="10.3.1、示例"></a>10.3.1、示例</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int x &#x3D; 0;decltype(x) y&#x3D;1;   &#x2F;&#x2F;y-&gt;intdecltype(x + y) z&#x3D;1;   &#x2F;&#x2F;z-&gt;intconst int &amp;i &#x3D; x;decltype(i) j&#x3D;y;   &#x2F;&#x2F;j-&gt;const int&amp;const int* k &#x3D; &amp;x;decltype(k) p &#x3D; 20;   &#x2F;&#x2F;p-&gt;const int *int * const m &#x3D; &amp;x;decltype(m) n &#x3D; 30;   &#x2F;&#x2F;p-&gt;int *constint func_int(void);decltype(func_int) f_01;  &#x2F;&#x2F; f_01-&gt;int (*)(void)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-3-2、特例"><a href="#10-3-2、特例" class="headerlink" title="10.3.2、特例"></a>10.3.2、特例</h3><h4 id="1、decltype与函数返回值"><a href="#1、decltype与函数返回值" class="headerlink" title="1、decltype与函数返回值"></a>1、decltype与函数返回值</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int value &#x3D; 20;const int func_int(void);const int * func_int_ptr_01(void);int * const func_int_ptr_02(void);decltype(func_int()) f&#x3D;0;   &#x2F;&#x2F;f-&gt;intdecltype(func_int_ptr_01()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;const int*decltype(func_int_ptr_02()) h&#x3D; &amp;value;   &#x2F;&#x2F;h-&gt;int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数返回值的const传递性规则与auto、模板参数类型推导规则一样，需要考虑是按值传递还是按地址传递。函数返回值换成引用类型，规则同样适用</p><h4 id="2、decltype与重载函数"><a href="#2、decltype与重载函数" class="headerlink" title="2、decltype与重载函数"></a>2、decltype与重载函数</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int func_int(void);int func_int(int value)decltype(func_int) f_01;  &#x2F;&#x2F; error，由于func_int是重载函数，decltype无法知晓需要获取哪一个函数的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3、decltype与多重指针符号、引用符号、const"><a href="#3、decltype与多重指针符号、引用符号、const" class="headerlink" title="3、decltype与多重指针符号、引用符号、const"></a>3、decltype与多重指针符号、引用符号、const</h4><pre class="line-numbers language-none"><code class="language-none">#include ＜type_traits＞#include ＜iostream＞using namespace std;int i&#x3D;1;int＆j&#x3D;i;int*p&#x3D;＆i;const int k&#x3D;1;int main()&#123;decltype(i)＆var1&#x3D;i;  &#x2F;&#x2F; var1-&gt;int &amp;decltype(j)＆var2&#x3D;i;  &#x2F;&#x2F;多余的＆被忽略, var2-&gt;int &amp;cout＜＜is_lvalue_reference＜decltype(var1)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用cout＜＜is_rvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;0,不是右值引用cout＜＜is_lvalue_reference＜decltype(var2)＞::value＜＜endl;&#x2F;&#x2F;1,是左值引用decltype(p)*var3&#x3D;＆i;  &#x2F;&#x2F;无法通过编译,var3的类型是int**decltype(p)*var3&#x3D;＆p;  &#x2F;&#x2F;var3的类型是int**auto*v3&#x3D;p;&#x2F;&#x2F;v3的类型是int*v3&#x3D;＆i;const decltype(k)var4&#x3D;1;&#x2F;&#x2F;冗余的const被忽略&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表达式中多余的引用符号、const会被忽略，而指针符号会被保留</p><h4 id="4、decltype与标记符表达式"><a href="#4、decltype与标记符表达式" class="headerlink" title="4、decltype与标记符表达式"></a>4、decltype与标记符表达式</h4><p>绝大多数时刻decltype都是平易近人的，但有时候也会让人疑惑，比如：</p><pre class="line-numbers language-none"><code class="language-none">int i;decltype(i)a;&#x2F;&#x2F;a:intdecltype((i))b;&#x2F;&#x2F;b:int＆,无法编译通过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为decltype具有以下四规则，不过需要先了解什么是<strong>标记符表达式</strong>：<br>基本上，所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier） 。 而单个标记符对应的表达式就是标记符表达式。比如程序员定义了：</p><pre class="line-numbers language-none"><code class="language-none">int arr[4];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么arr是一个标记符表达式， 而arr[3]+0,arr[3]等， 则都不是标记符表达式。   </p><ul><li><strong>规则一</strong>：如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。 此外， <strong>如果e是一个被重载的函数</strong>， 则会导致编译时错误；</li><li><strong>规则二</strong>：否则， 假设e的类型是T， 如果e是一个将亡值(xvalue)， 那么decltype(e)为T＆＆；</li><li><strong>规则三</strong>：否则， 假设e的类型是T， 如果e是一个左值， 则decltype(e)为T＆；</li><li><strong>规则四</strong>：否则， 假设e的类型是T， 则decltype(e)为T；</li></ul><p>这样便可解释上面的int i例子，由于(i)不是一个标记符表达式，而却是一个左值表达式（可以有具名的地址） ， 因此， 按照decltype推导规则3， 其类型应该是一个int的引用，所以b必须同时初始化。</p><pre class="line-numbers language-none"><code class="language-none">int i&#x3D;4;int arr[5]&#x3D;&#123;0&#125;;int*ptr&#x3D;arr;struct S&#123;double d;&#125;s;void Overloaded(int);void Overloaded(char);&#x2F;&#x2F;重载的函数int＆＆RvalRef();const bool Func(int);&#x2F;&#x2F;规则1:单个标记符表达式以及访问类成员， 推导为本类型decltype(arr)var1;&#x2F;&#x2F;int[5],标记符表达式decltype(ptr)var2;&#x2F;&#x2F;int*,标记符表达式decltype(s.d)var4;&#x2F;&#x2F;double,成员访问表达式decltype(Overloaded)var5;&#x2F;&#x2F;无法通过编译， 是个重载的函数&#x2F;&#x2F;规则2:将亡值， 推导为类型的右值引用decltype(RvalRef())var6&#x3D;1;&#x2F;&#x2F;int＆＆&#x2F;&#x2F;规则3:左值， 推导为类型的引用decltype(true?i:i)var7&#x3D;i;&#x2F;&#x2F;int＆,三元运算符， 这里返回一个i的左值decltype((i))var8&#x3D;i;&#x2F;&#x2F;int＆,带圆括号的左值decltype(++i)var9&#x3D;i;&#x2F;&#x2F;int＆,++i返回i的左值decltype(arr[3])var10&#x3D;i;&#x2F;&#x2F;int＆[]操作返回左值decltype(*ptr)var11&#x3D;i;&#x2F;&#x2F;int＆*操作返回左值decltype(&quot;lval&quot;)var12&#x3D;&quot;lval&quot;;&#x2F;&#x2F;const char(＆)[9],字符串字面常量为左值&#x2F;&#x2F;规则4： 以上都不是， 推导为本类型decltype(1)var13;&#x2F;&#x2F;int,除字符串外字面常量为右值decltype(i++)var14;&#x2F;&#x2F;int,i++返回右值decltype((Func(1)))var15;&#x2F;&#x2F;const bool,圆括号可以忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处顺便可以理解，前置++ 与后置++的区别，前置++是一个左值，后置++是一个表达式，需要返回一个临时值</p><h2 id="10-4、数组与类型推导"><a href="#10-4、数组与类型推导" class="headerlink" title="10.4、数组与类型推导"></a>10.4、数组与类型推导</h2><h3 id="10-4-1、数组常规推导"><a href="#10-4-1、数组常规推导" class="headerlink" title="10.4.1、数组常规推导"></a>10.4.1、数组常规推导</h3><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T param);const char name[13] &#x3D; &quot;abcddftg&quot;;func(name);  &#x2F;&#x2F; T是const char *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>T被推导成const char *而不是const char [13]，因为：</p><ul><li>数组到指针的退化规则，name的const char [13]退化成了const char *；</li><li>也可以理解成函数无法声明真正意义上的数组形参；    </li></ul><h3 id="10-4-2、数组引用类型推导"><a href="#10-4-2、数组引用类型推导" class="headerlink" title="10.4.2、数组引用类型推导"></a>10.4.2、数组引用类型推导</h3><p><strong>难点来了</strong>：<br>虽然函数无法声明真正意义上的数组形参，但却可以将形参声明成数组的引用</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(T&amp; param);const char name[13] &#x3D; &quot;abcddftg&quot;;f(name);  &#x2F;&#x2F; T是const char [13], param是const char (&amp;)[13]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意参考2.7.1的情形，此时ParamType是个引用类型，传入的是个数组const char [13]，这里的const性便得以保留。    </p><p><strong>实际应用</strong>：<br>可以利用这个功能创造出一个模板，用来推导出数组含有的元素数：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以编译期常量的形式返回数组尺寸template&lt;typename T, std::size_t N&gt;constpxer std::size_t arraySize(T (&amp;)[N]) nonexcept&#123;    return N;&#125;int keyVals[] &#x3D; &#123;1,3,7,9&#125;;int mappedVals[arraySize(keyVals)];  &#x2F;&#x2F; mappedVals被指定为与keyVals一样大小的数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-4-3、数组初始化形式作为实参的类型推导"><a href="#10-4-3、数组初始化形式作为实参的类型推导" class="headerlink" title="10.4.3、数组初始化形式作为实参的类型推导"></a>10.4.3、数组初始化形式作为实参的类型推导</h3><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;int x(27);int x &#x3D; &#123;27&#125;;int x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上是四种初始表达式，都可以将x初始化为27，但在以初始化形式发生auto类型推导时情况略有不同：</p><pre class="line-numbers language-none"><code class="language-none">auto x &#x3D; 27;auto x(27);auto x &#x3D; &#123;27&#125;;auto x&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>前两个没有问题，可以正常初始化x为int，值为27，但后两个会将x初始化为std::initializer_list<int>类型，且包含单个值27<br>，这是因为在auto推导时会将大括号推导为std::initializer_list<int>类型，而模板推导中就会失败，因为模板不支持这种推导形式：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void func(T name);func(&#123;1,2,3&#125;);  &#x2F;&#x2F; 错误，无法推导T的型别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不过，若指定该模板中param为std::initializer_list<T>类型，则可以推导出T的型别：</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(std::initializer_list&lt;T&gt; name);f(&#123;1,2,3&#125;);  &#x2F;&#x2F; T被推导为int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="11、std-string类"><a href="#11、std-string类" class="headerlink" title="11、std::string类"></a>11、std::string类</h1><p>传统字符数组的缺点：</p><ul><li>普通字符数组的长度在编译期已固定，不可更改；</li><li>动态申请的字符数组虽然可以按需分配空间，但当扩容时内存空间需要销毁重建；</li><li>char *在浅复制时易出现内存泄漏、double free等问题；</li></ul><h2 id="11-1、初始化"><a href="#11-1、初始化" class="headerlink" title="11.1、初始化"></a>11.1、初始化</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    &#x2F;&#x2F; char * To std::string    const char * c_string &#x3D; &quot;Hello world!&quot;;    std::string str01 &#x3D; &quot;Hello world!&quot;;  &#x2F;&#x2F; copy constructor    std::string str02 &#x3D; c_string;  &#x2F;&#x2F; copy constructor    std::string str03(c_string);  &#x2F;&#x2F; default constructor    std::string str04;    str04 &#x3D; c_string;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n01: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str01 &lt;&lt; &quot;\n&quot; &lt;&lt; str02 &lt;&lt; &quot;\n&quot; &lt;&lt; str03  &lt;&lt; &quot;\n&quot; &lt;&lt; str04 &lt;&lt; std::endl;    &#x2F;&#x2F; std::string To std::string    std::string str_str &#x3D; &quot;Everything is OK!&quot;;    std::string str05 &#x3D; str_str;  &#x2F;&#x2F; copy constructor    std::string str06(str05);  &#x2F;&#x2F; defalut constructor    std::string str07;    str07 &#x3D; str_str;  &#x2F;&#x2F; operator &#x3D; constructor    std::cout &lt;&lt; &quot;\n02: &quot; &lt;&lt; str_str &lt;&lt; &quot;\n&quot; &lt;&lt; str05 &lt;&lt; &quot;\n&quot; &lt;&lt; str06 &lt;&lt; &quot;\n&quot; &lt;&lt; str07 &lt;&lt; std::endl;    &#x2F;&#x2F; member function    &#x2F;&#x2F; function: *_copy_*(source, begin_pos, len)， 指定位置开始复制    std::string str08(c_string,2,10);  &#x2F;&#x2F; str08 &#x3D; &quot;llo world!&quot;&quot;    std::string str09(c_string,2);  &#x2F;&#x2F; str09 &#x3D; &quot;He&quot; copy len &#x3D; 2 from begin pos    std::string str10(str_str,2,15);  &#x2F;&#x2F; str10 &#x3D; &quot;erything is OK!&quot;&quot;    std::string str11(str_str,2);  &#x2F;&#x2F; str11 &#x3D; &quot;erything is OK!&quot; copy from 2th pos to end pos    std::cout &lt;&lt; &quot;\n03: &quot; &lt;&lt; str08 &lt;&lt; &quot;\n&quot; &lt;&lt; str09 &lt;&lt; &quot;\n&quot; &lt;&lt; str10 &lt;&lt; &quot;\n&quot; &lt;&lt; str11 &lt;&lt; std::endl;    &#x2F;&#x2F; function: *_copy_*(begin_pos, end_pos), 区间复制    std::string str12(c_string + 2, c_string + 8);  &#x2F;&#x2F; str12 &#x3D; &quot;llo wo&quot;    std::string str13(c_string + 2);  &#x2F;&#x2F; str13 &#x3D; &quot;llo world!&quot;    std::cout &lt;&lt; &quot;\n04: &quot; &lt;&lt;c_string &lt;&lt; &quot;\n&quot; &lt;&lt; str12 &lt;&lt; &quot;\n&quot; &lt;&lt; str13 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Hello world!Hello world!Hello world!Hello world!Hello world!02: Everything is OK!Everything is OK!Everything is OK!Everything is OK!03: llo world!Heerything is OK!erything is OK!04: Hello world!llo wollo world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-2、访问"><a href="#11-2、访问" class="headerlink" title="11.2、访问"></a>11.2、访问</h2><ul><li>类数组下标形式访问；</li><li>C风格指针形式访问；</li><li>迭代器形式访问</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    &#x2F;&#x2F; 数组下标形式    for (int32_t i &#x3D; 0; i &lt; str_str.length(); ++i) &#123;        std::cout &lt;&lt; str_str[i];    &#125;        &#x2F;&#x2F; C风格指针    const char *c_string &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\n\n&quot; &lt;&lt; c_string &lt;&lt; std::endl;    &#x2F;&#x2F; 迭代器    std::cout &lt;&lt; &quot;\n&quot;;    for (auto iter &#x3D; str_str.begin(); iter !&#x3D; str_str.end(); ++iter) &#123;        std::cout &lt;&lt; *iter;    &#125;    std::cout &lt;&lt; &quot;\n&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-3、拼接"><a href="#11-3、拼接" class="headerlink" title="11.3、拼接"></a>11.3、拼接</h2><ul><li>拼接符：+=、+</li><li>appen函数</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str01 &#x3D; &quot;Hello&quot;;    std::string str_str02 &#x3D; &quot; world!&quot;;    std::string str_str03 &#x3D; str_str01 + str_str02;    std::string str_str04 &#x3D; str_str01.append(str_str02);    std::string str_str05 &#x3D; &quot;Everybody, &quot; + str_str03;    std::cout &lt;&lt; str_str03 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str04 &lt;&lt; &quot;\n&quot; &lt;&lt; str_str05 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-4、查找"><a href="#11-4、查找" class="headerlink" title="11.4、查找"></a>11.4、查找</h2><p>查找相关的函数：</p><ul><li>find</li><li>find_first_of</li><li>find_first_not_of</li><li>find_last_of</li><li>find_last_not_of</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;every body is everybody&quot;;    std::string str_obj &#x3D; &quot;everybody&quot;;    size_t pos01 &#x3D; str_str.find(str_obj, 2);    size_t pos02 &#x3D; str_str.find(str_obj);    size_t pos03 &#x3D; str_str.find_first_of(str_obj, 2);    size_t pos04 &#x3D; str_str.find_first_of(str_obj);    size_t pos05 &#x3D; str_str.find_first_not_of(str_obj);    size_t pos06 &#x3D; str_str.find_last_of(str_obj);    size_t pos07 &#x3D; str_str.find_last_of(str_obj, 2);    size_t pos08 &#x3D; str_str.find_last_not_of(str_obj);    std::cout &lt;&lt; pos01 &lt;&lt; &quot;  &quot; &lt;&lt; pos02 &lt;&lt; &quot;  &quot;  &lt;&lt; pos03 &lt;&lt; &quot;  &quot;  &lt;&lt; pos04 &lt;&lt; &quot;  &quot;     &lt;&lt; pos05 &lt;&lt; &quot;  &quot;  &lt;&lt; pos06 &lt;&lt; &quot;  &quot;  &lt;&lt; pos07 &lt;&lt; &quot;  &quot;  &lt;&lt; pos08 &lt;&lt; std::endl;        &#x2F;&#x2F; 迭代器    auto iter &#x3D; find(str_str.begin(), str_str.end(), &#39;e&#39;);  &#x2F;&#x2F; 第三个参数如果是std::string类型会报错，因为str_str的iteration是字符，字符与字符串是无法match    if (iter !&#x3D; str_str.end()) &#123;        std::cout &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;Has been found&quot; &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">14  14  2  0  5  22  2  13Has been found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>find_first_of/find_last_of查找规则是如果str_str中含有str_obj中的任何字符，则就会查找成功，而find则是要完全匹配；</p><h2 id="11-5、截短"><a href="#11-5、截短" class="headerlink" title="11.5、截短"></a>11.5、截短</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;Hello world!&quot;;    str_str.erase(3, 7);  &#x2F;&#x2F; 从第3位开始删除7个字符，遇到字符串结尾结束    std::cout &lt;&lt; &quot;01: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    str_str.erase(2);  &#x2F;&#x2F; 遇到字符串结尾结束    std::cout &lt;&lt; &quot;02: &quot; &lt;&lt; str_str &lt;&lt; std::endl;        str_str.erase(str_str.begin(), str_str.end());    std::cout &lt;&lt; &quot;03: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#x2F;&#x2F; 删除指定字符    str_str &#x3D; &quot;Hello world!&quot;;    size_t pos &#x3D; str_str.find(&#39;H&#39;);    if (pos !&#x3D; str_str.npos) &#123;        str_str.erase(pos, 1);        std::cout &lt;&lt; &quot;04: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    auto iter &#x3D; std::find(str_str.begin(), str_str.end(), &#39;w&#39;);    if (iter !&#x3D; str_str.end()) &#123;        str_str.erase(iter);        std::cout &lt;&lt; &quot;05: &quot; &lt;&lt; str_str &lt;&lt; std::endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">01: Held!02: He03:04: ello world!05: ello orld!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-6、获取子字符串std-substr"><a href="#11-6、获取子字符串std-substr" class="headerlink" title="11.6、获取子字符串std::substr"></a>11.6、获取子字符串std::substr</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string targt &#x3D; &quot;Hello,world!&quot;;        int nComma &#x3D; targt.find(&#39;,&#39;);    if (nComma !&#x3D; std::string::npos)    &#123;    std::string keywordSegmt_1 &#x3D; targt.substr(0, nComma);    std::cout &lt;&lt; &quot;test 1  &quot; &lt;&lt; keywordSegmt_1 &lt;&lt; std::endl;        std::string keywordSegmt_2 &#x3D; targt.substr(nComma + 1, targt.length() - 1 - nComma);    std::cout &lt;&lt; &quot;test 2  &quot; &lt;&lt; keywordSegmt_2 &lt;&lt; std::endl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">test 1  Hellotest 2  world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="11-7、翻转std-reverse"><a href="#11-7、翻转std-reverse" class="headerlink" title="11.7、翻转std::reverse"></a>11.7、翻转std::reverse</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;algorithm&gt;int main()&#123;    using namespace std;    string strSample (&quot;Hello String!&quot;);    cout &lt;&lt; &quot;The original sample string is: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl &lt;&lt; endl;     reverse (strSample.begin (), strSample.end ());     cout &lt;&lt; &quot;After applying the std::reverse algorithm: &quot; &lt;&lt; endl;    cout &lt;&lt; strSample &lt;&lt; endl;     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">The original sample string is: Hello String!After applying the std::reverse algorithm: !gnirtS olleH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-8、大小写转换transform、toupper、tolower"><a href="#11-8、大小写转换transform、toupper、tolower" class="headerlink" title="11.8、大小写转换transform、toupper、tolower"></a>11.8、大小写转换transform、toupper、tolower</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;cctype&gt;#include &lt;algorithm&gt;int main ()&#123;    std::string strInput &#x3D; &quot;Hello world!&quot;;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::toupper);  &#x2F;&#x2F; ::toupper为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to upper case is: &quot; &lt;&lt;std:: endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        std::transform (strInput.begin(), strInput.end(), strInput.begin(), ::tolower);  &#x2F;&#x2F; ::tolower为匿名命名空间    std::cout &lt;&lt; &quot;The string converted to lower case is: &quot; &lt;&lt; std::endl;    std::cout &lt;&lt; strInput &lt;&lt; std::endl &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">The string converted to upper case is: HELLO WORLD!The string converted to lower case is: hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-9、字符串与其他类型转换"><a href="#11-9、字符串与其他类型转换" class="headerlink" title="11.9、字符串与其他类型转换"></a>11.9、字符串与其他类型转换</h2><h3 id="11-9-1、实数转字符串"><a href="#11-9-1、实数转字符串" class="headerlink" title="11.9.1、实数转字符串"></a>11.9.1、实数转字符串</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 普通字符串std::string to_string(int);std::string to_string(long);std::string to_string(long long);std::string to_string(unsigned);std::string to_string(unsigned long);std::string to_string(unsigned long long);std::string to_string(float);std::string to_string(double);std::string to_string(long double);&#x2F;&#x2F; 宽字符串std::wstring to_wstring(int);std::wstring to_wstring(long);std::wstring to_wstring(long long);std::wstring to_wstring(unsigned);std::wstring to_wstring(unsigned long);std::wstring to_wstring(unsigned long long);std::wstring to_wstring(float);std::wstring to_wstring(double);std::wstring to_wstring(long double);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以使用C函数snprintf</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int snprintf(char *str, size_t size, const char *format, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main ()&#123;    int32_t int_str &#x3D; 123456;    char c_string[20];    snprintf(c_string, 20 - 1, &quot;%09d&quot;, int_str);    std::cout &lt;&lt; &quot;string is: &quot; &lt;&lt; c_string &lt;&lt; &quot;\nint string is: &quot; &lt;&lt; int_str &lt;&lt; std::endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">string is: 000123456int string is: 123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将int_str按照format格式转化成字符串，可以指定字符串的长度为9，不足的部分使用字符’0’填充，末尾自动添加\0，然后将转换结果放入c-string之中，成功则返回写入的字符串长度，失败返回负值</p><h3 id="11-9-2、字符串转实数"><a href="#11-9-2、字符串转实数" class="headerlink" title="11.9.2、字符串转实数"></a>11.9.2、字符串转实数</h3><pre class="line-numbers language-none"><code class="language-none">int std::atoi(const char*);long std::atol(const char*);long long std::atoll(const char*);float std::atof(const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要转换的字符串起始部分不是数字，返回0，如果是空格，会被忽略掉。</p><pre class="line-numbers language-none"><code class="language-none">long int strtol(const char* nptr, char **endptr, int base);long long int strtoll(const char* nptr, char **endptr, int base);unsigned long int strtoul(const char* nptr, char **endptr, int base);unsigned long long int strtoull(const char* nptr, char **endptr, int base);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将参数nptr按照base的格式转化成整形<br>base是0-36，代表进制，函数会扫描参数nptr，跳过前面的空格字符串，直到遇上数字或正负符号才开始转换(如果是不合法字符，直接退出)，再遇到非数字或字符串结束符停止转换，若endptr不为NULL，则会将遇到的不符合条件而终止的nptr中的字符指针返回。<br>如果base=0，则根据字符串起始部分是0还是0x来判断转换成8进制还是16进制，如果都不是默认转换成10进制</p><pre class="line-numbers language-none"><code class="language-none">using namespace std;int main()&#123;    char *endptr;    char nptr[]&#x3D;&quot;123abc&quot;;    int ret &#x3D; strtol(nptr, &amp;endptr, 10 );    cout &lt;&lt; &quot;*****01*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr &#x3D; &quot;&lt;&lt;endptr&lt;&lt;endl;    char *endptr2;    char nptr2[]&#x3D;&quot; \t    abc&quot;;    ret &#x3D; strtol(nptr2, &amp;endptr2, 10 );     cout &lt;&lt; &quot;\n*****02*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr2 &#x3D; &quot;&lt;&lt;endptr2&lt;&lt;endl;    char *endptr8;    char nptr8[]&#x3D;&quot;0123&quot;;    ret &#x3D; strtol(nptr8, &amp;endptr8,0);     cout &lt;&lt; &quot;\n*****03*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr8 &#x3D; &quot;&lt;&lt;endptr8&lt;&lt;endl;       char *endptr16;    char nptr16[]&#x3D;&quot;0x123&quot;;    ret &#x3D; strtol(nptr16, &amp;endptr16,0);     cout &lt;&lt; &quot;\n*****04*****&quot; &lt;&lt; endl;    cout&lt;&lt;&quot;ret &#x3D; &quot;&lt;&lt;ret&lt;&lt;endl;    cout&lt;&lt;&quot;endptr16 &#x3D; &quot;&lt;&lt;endptr16&lt;&lt;endl;       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><pre class="line-numbers language-none"><code class="language-none">*****01*****ret &#x3D; 123endptr &#x3D; abc*****02*****ret &#x3D; 0endptr2 &#x3D;      abc*****03*****ret &#x3D; 83endptr8 &#x3D; *****04*****ret &#x3D; 291endptr16 &#x3D; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-9-3、stringstream类"><a href="#11-9-3、stringstream类" class="headerlink" title="11.9.3、stringstream类"></a>11.9.3、stringstream类</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sstream&gt;using namespace std;int main()&#123;   int32_t int_input &#x3D; 6789;   stringstream converterStream01;   converterStream01 &lt;&lt; int_input;    string str_output;   converterStream01 &gt;&gt; str_output;   cout &lt;&lt; &quot;Integer Input &#x3D; &quot; &lt;&lt; int_input &lt;&lt; endl;   cout &lt;&lt; &quot;String gained from integer, strInput &#x3D; &quot; &lt;&lt; str_output &lt;&lt; endl;   std::string str_input &#x3D; str_output;   stringstream converterStream02;   converterStream02 &lt;&lt; str_input;   int32_t Copy &#x3D; 0;   converterStream02 &gt;&gt; Copy;   cout &lt;&lt; &quot;Integer gained from string, Copy &#x3D; &quot; &lt;&lt; Copy + 1 &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Integer Input &#x3D; 6789String gained from integer, strInput &#x3D; 6789Integer gained from string, Copy &#x3D; 6790<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="11-10、string转C风格字符串"><a href="#11-10、string转C风格字符串" class="headerlink" title="11.10、string转C风格字符串"></a>11.10、string转C风格字符串</h2><ul><li>data()返回char *指针，指向std::string对象内存放数组的内存空间；</li><li>c_str()返回const char *指针，指向std::string对象内存放数组的内存空间；</li><li>copy()将std::string内容复制至指定字符数组内；<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; copy函数原型copy(_CharT* __s, size_type __n, size_type __pos)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;memory.h&gt;int main()&#123;    std::string str_str &#x3D; &quot;hello&quot;;    char *ptr01;    ptr01 &#x3D; str_str.data();    std::cout &lt;&lt; &quot;execute function data: &quot; &lt;&lt; ptr01 &lt;&lt; std::endl;    const char *ptr02 &#x3D; str_str.c_str();    std::cout &lt;&lt; &quot;\nexecute function c_str: &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    char array[6];    memset(array, 0, sizeof(array));    str_str.copy(array, 3, 2);    std::cout &lt;&lt; &quot;\nexecute function copy: &quot; &lt;&lt; array &lt;&lt; std::endl;    &#x2F;&#x2F; modify std::string    str_str &#x3D; &quot;Hello world!&quot;;    std::cout &lt;&lt; &quot;\nafter modify:\nptr01 &#x3D; &quot; &lt;&lt; ptr01 &lt;&lt; &quot;\nptr02 &#x3D; &quot; &lt;&lt; ptr02 &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>运行结果：<pre class="line-numbers language-C" data-language="C"><code class="language-C">execute function data: helloexecute function c_str: helloexecute function copy: lloafter modify:ptr01 &#x3D; Hello world!ptr02 &#x3D; Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="11-11、其他常用函数"><a href="#11-11、其他常用函数" class="headerlink" title="11.11、其他常用函数"></a>11.11、其他常用函数</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">int compare(string);  &#x2F;&#x2F; string比较，相同返回0int capacity() const;  &#x2F;&#x2F;返回string容量，已分配的内存空间int max_size()const;  &#x2F;&#x2F;返回string对象可存放的最大字符串长度，通常是个很大的数int size()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间int length()const;  &#x2F;&#x2F;返回string的大小，已使用的内存空间bool empty()const;  &#x2F;&#x2F;当前字符串是否为空void resize(int len, char c)const;&#x2F;&#x2F;把当前字符串大小设置为len，并用字符c填充不足的部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    std::string str_str &#x3D; &quot;hello world!&quot;;    std::cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; str_str.capacity() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nmax_size &#x3D; &quot; &lt;&lt; str_str.max_size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nsize &#x3D; &quot; &lt;&lt; str_str.size() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;\nlength &#x3D; &quot; &lt;&lt; str_str.length() &lt;&lt; std::endl;    str_str.resize(15, &#39;B&#39;);    std::cout &lt;&lt; &quot;\nresize &#x3D; &quot; &lt;&lt; str_str &lt;&lt; std::endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-12、C风格字符串"><a href="#11-12、C风格字符串" class="headerlink" title="11.12、C风格字符串"></a>11.12、C风格字符串</h2><h3 id="11-12-1、strcmp的实现"><a href="#11-12-1、strcmp的实现" class="headerlink" title="11.12.1、strcmp的实现"></a>11.12.1、strcmp的实现</h3><pre class="line-numbers language-none"><code class="language-none">int mystrcmp(const char *str1, const char *str2)&#123;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39; &amp;&amp; *str1 &#x3D;&#x3D; *str2)    &#123;        str1++;        str2++;    &#125;        if(*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 &#x3D;&#x3D; &#39;\0&#39;)    return 1;    else if(*str1 &#x3D;&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;)    return -1;    else if(*str1 &gt; *str2)    return 1;    else if (*str1 &lt; *str2)    return -1;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-12-2、strcpy的实现"><a href="#11-12-2、strcpy的实现" class="headerlink" title="11.12.2、strcpy的实现"></a>11.12.2、strcpy的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrcpy(char *str1, const char *str2)&#123;    char *p &#x3D; str1;    if(p &#x3D;&#x3D; NULL || str2 &#x3D;&#x3D; NULL)    &#123;         printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;        while(*str2 !&#x3D; &#39;\0&#39;)    &#123;        *p &#x3D; *str2;        p++;        str2++;    &#125;    *p &#x3D; &#39;\0&#39;;    return str1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-12-3、strstr的实现"><a href="#11-12-3、strstr的实现" class="headerlink" title="11.12.3、strstr的实现"></a>11.12.3、strstr的实现</h3><pre class="line-numbers language-none"><code class="language-none">char *mystrstr(const char *str1, const char *str2)&#123;    char *src, char *sub;    if(str1 &#x3D;&#x3D; NULL || str2&#x3D;&#x3D; NULL)    &#123;        printf(&quot;The string is error!\n&quot;);        exit(0);    &#125;    while(*str1 !&#x3D; &#39;\0&#39;)    &#123;        src &#x3D; str1;        sub &#x3D; str2;                do        &#123;            if(*sub &#x3D;&#x3D; &#39;\0&#39;)            &#123;                return str1;            &#125;        &#125;while(*src ++ &#x3D;&#x3D; *sub++);                str1++    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-、字符、字符串相关函数"><a href="#11-、字符、字符串相关函数" class="headerlink" title="11.*、字符、字符串相关函数"></a>11.*、字符、字符串相关函数</h2><ul><li>字母（不区分大小写）：isalpha();</li><li>大写字母：isupper();</li><li>小写字母：islower();</li><li>数字：isdigit();</li><li>字母和数字：isalnum();</li><li>转化为大写：toupper();</li><li>转化为小写：tolower();</li></ul><h1 id="12、lambda表达式"><a href="#12、lambda表达式" class="headerlink" title="12、lambda表达式"></a>12、lambda表达式</h1><p>语法结构：   </p><pre class="line-numbers language-none"><code class="language-none">[capturer]   (params) mutable-&gt;ret   &#123;body;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>capturer是捕获列表</strong>:[]是lambda引出符,编译器根据该引出符判断接下来的代码是lambda表达式；    </li><li><strong>params是参数列表</strong>:如果不需要参数传递，则可以连同括号()一起省略；   </li><li><strong>mutable是修饰符</strong>：默认情况下，lambda总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略；   </li><li><strong>ret是返回类型</strong>：不需要返回值的时候也可以连同符号-＞一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导；    </li><li><strong>body是函数体</strong>；    </li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto f &#x3D; []  (int a) -&gt;int &#123;return a+1;&#125;std::cout&lt;&lt;f(1)&lt;&lt;endl;   &#x2F;&#x2F;输出2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>lambda的捕获列表</strong>：    </p><ul><li>[]不捕获任何变量；</li><li>[&amp;]捕获外部作用域所有变量，并作为引用在函数体中使用；</li><li>[=]捕获外部作用域所有变量，并作为副本在函数体中使用；</li><li>[=,&amp;foo]按值捕获外部作用域所有变量，但按引用捕获foo变量；</li><li>[bar]按值捕获bar变量；</li><li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限；</li></ul><p><strong>通用语法</strong>：    </p><ul><li>必须以方括号[]打头，这个方括号告诉编译器接下来是一个lambda表达式。方括号后面是一个参数列表及函数表达式。[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li><li>stateVar1,stateVar2为状态变量，param1，param2为参数列表；   </li><li>如果要在表达式中修改状态变量，需要添加关键字mutable或捕获左值形式:<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) mutable {lambda表达式}；   </li><li>使用mutable修改状态变量，在离开lambda之后将无效，若要使之有效需使用引用:<br>[&amp;stateVar1,&amp;stateVar2] (Type&amp; param1，Type&amp; param2) {lambda表达式}；   </li><li>向编译器指明返回类型：<br>[stateVar1,stateVar2] (Type&amp; param1，Type&amp; param2) -&gt;returnType {lambda表达式}；</li></ul><p><font color=red><strong>[]只能捕获父作用域的变量；lambda可以直接使用全局变量，不需要额外捕获</strong></font></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;class A&#123;int i_ &#x3D; 0;void func(int x, int y)&#123;auto x1 &#x3D; []&#123;return i_; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量auto x2 &#x3D; [&#x3D;]&#123;return i_ + x + y; &#125;;auto x3 &#x3D; [&amp;]&#123;return i_ + x + y; &#125;;auto x4 &#x3D; [this]&#123;return i_; &#125;;auto x5 &#x3D; [this]&#123;return i_ + x + y; &#125;;  &#x2F;&#x2F;error,没有捕获x和yauto x6 &#x3D; [this, x, y]&#123;return i_ + x + y; &#125;;auto x7 &#x3D; [this]&#123;return i_++; &#125;;&#125;&#125;;int main(void)&#123;&#123;int a &#x3D; 0;int b &#x3D; 1;auto func1 &#x3D; []&#123;return a; &#125;;  &#x2F;&#x2F;error,没有捕获外部变量 auto func2 &#x3D; [&amp;]&#123;return a++; &#125;;auto func3 &#x3D; [&#x3D;]&#123;return a; &#125;;auto func4 &#x3D; [&#x3D;]&#123;return a++; &#125;;  &#x2F;&#x2F;error,a是以复制方式捕获的，无法修改auto func5 &#x3D; [a]&#123;return a + b; &#125;;  &#x2F;&#x2F;error,没有捕获变量bauto func6 &#x3D; [a, &amp;b]&#123;return a + (b++); &#125;;auto func7 &#x3D; [&#x3D;, &amp;b]&#123;return a + (b++); &#125;;&#125;system(&quot;pause&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red>lambda按值捕获时实际捕获的是外部变量的副本，捕获之后的任何修改与原始变量无关，此种行为称作lambda捕获延时性</font></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a&#x3D;0;auto f &#x3D; [&#x3D;] &#123;return a;&#125;;a +&#x3D; 1;cout&lt;&lt;f()&lt;&lt;endl;  &#x2F;&#x2F;结果仍然是0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=red>没有捕获外部变量的lambda表达式可以直接转换为函数指针</font>，可以这么理解：假如lambda捕获了作用域内的rivate、protect成员，lambda转换为函数指针后，若在它处发生调用，函数是不会对private、protect进行检查，这样就破坏了封装性。</p><h2 id="12-1、lambda表达式的类型"><a href="#12-1、lambda表达式的类型" class="headerlink" title="12.1、lambda表达式的类型"></a>12.1、lambda表达式的类型</h2><p>从C++11标准的定义上可以发现，lambda的类型被定义为”<strong>闭包</strong>“（closure）的类，而每个lambda表达式则会产生一个闭包类型的临时对象（右值）。因此，严格地讲，lambda表达式并非函数指针。不过C++11标准却允许lambda表达式向函数指针转换(不允许函数指针向lambda转换)，但前提是lambda函数<strong>没有捕捉任何变量</strong>，且函数指针所示的函数原型， 必须跟lambda表达式类型相同。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int girls&#x3D;3,boys&#x3D;4;auto totalChild&#x3D;[](int x,int y)-＞int&#123;return x+y;&#125;;typedef int(*allChild)(int x,int y);typedef int(*oneChild)(int x);allChild p;p&#x3D;totalChild;oneChild q;q&#x3D;totalChild;&#x2F;&#x2F;编译失败， 参数必须一致decltype(totalChild)allPeople&#x3D;totalChild;&#x2F;&#x2F;需通过decltype获得lambda的类型decltype(totalChild)totalPeople&#x3D;p;&#x2F;&#x2F;编译失败， 指针无法转换为lambdareturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-2、lambda的常量性"><a href="#12-2、lambda的常量性" class="headerlink" title="12.2、lambda的常量性"></a>12.2、lambda的常量性</h2><p>lambda默认是const(常量性)，mutable可以修改其常量性，不过极少使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;int val;auto const_val_lambda&#x3D;[&#x3D;]()&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;编译失败,不允许在const的lambda中修改按值捕获的变量auto mutable_val_lambda&#x3D;[&#x3D;]()mutable&#123;val&#x3D;3;&#125;;  &#x2F;&#x2F;非const的lambda,可以修改捕获的变量。对于按值捕获的变量，修改的是其捕获的副本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-3、lambda的底层实现"><a href="#12-3、lambda的底层实现" class="headerlink" title="12.3、lambda的底层实现"></a>12.3、lambda的底层实现</h2><p>lambda表达式被设计的目的就是要就地书写，就地使用。使用lambda的用户，更倾向于在一个文件作用域里看到所有的代码，而不是依靠代码浏览工具在文件间找到函数的实现。在封装的思维层面上，lambda只是一种局部的封装以及局部的共享。<br>由<strong>12.1节</strong>可知lambda是一个闭包类型，那么它的底层是怎么实现的呢？这就要从函数对象说起，函数对象是对函数调用符operator()的重载，详见<strong>4.9.7节</strong><br>lambda的原理与此相关：<font color=red>编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符</font></p><h3 id="12-3-1、无捕获列表-无参数列表"><a href="#12-3-1、无捕获列表-无参数列表" class="headerlink" title="12.3.1、无捕获列表 + 无参数列表"></a>12.3.1、无捕获列表 + 无参数列表</h3><p><code>auto print = []&#123;cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl; &#125;;</code><br>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;用给定的lambda表达式生成相应的类class print_class&#123;public:void operator()(void) const&#123;cout &lt;&lt; &quot;zhangxiang&quot; &lt;&lt; endl;&#125;&#125;;&#x2F;&#x2F;用构造的类创建对象，print此时就是一个函数对象auto print &#x3D; print_class();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-3-2、无捕获列表-参数列表"><a href="#12-3-2、无捕获列表-参数列表" class="headerlink" title="12.3.2、无捕获列表 + 参数列表"></a>12.3.2、无捕获列表 + 参数列表</h3><p><code>auto add = [](int a, int b)&#123;return a + b; &#125;;</code><br>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class add_class&#123;public:auto operator()(int a, int b) const&#123;return a + b;&#125;&#125;;auto add &#x3D; add_class();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-3-3、按值捕获"><a href="#12-3-3、按值捕获" class="headerlink" title="12.3.3、按值捕获"></a>12.3.3、按值捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;&#x2F;&#x2F;采用值捕获，捕获所有的已定义的局部变量，如year，nameauto print &#x3D; [&#x3D;]()&#123;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译器会翻译成，伪代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:&#x2F;&#x2F;根据捕获列表来决定构造函数的参数列表形式print_class(int year, char *name) :year(year), name(name)&#123; &#125;void operator()(void) const&#123;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;private:int year;char *name;&#125;;auto print &#x3D; print_class(a, str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是：</p><ul><li>值的传递方式是以含参数的构造函数实现；</li><li>按值捕获时lambda默认为const，在编译时以operator() const形式实现，同理mutable将const属性去除，是通过取消operator()的const性实现；<h3 id="12-3-4、按引用捕获"><a href="#12-3-4、按引用捕获" class="headerlink" title="12.3.4、按引用捕获"></a>12.3.4、按引用捕获</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;auto print &#x3D; [&amp;]()&#123;year++;cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>编译器会翻译成，伪代码<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int year &#x3D; 19900212;char *name &#x3D; &quot;zhangxiang&quot;;class print_class&#123;public:&#x2F;&#x2F;由于是引用捕获，参数列表采用引用的方式print_class(int &amp;year, char *&amp;name) :year(year), name(name)&#123; &#125;void operator()(void) const&#123;year++;   &#x2F;&#x2F;编译通过，const对引用类型无效cout &lt;&lt; year &lt;&lt; ends &lt;&lt; name &lt;&lt; endl;&#125;private:int &amp;year;char *&amp;name;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-4、lambda的优势"><a href="#12-4、lambda的优势" class="headerlink" title="12.4、lambda的优势"></a>12.4、lambda的优势</h2><font color=purple>lambda表达式的优势：</font></li><li>提升代码的可读性，它是就地书写，就地使用；</li><li>底层使用函数对象的方法实现，故同函数对象一样的优势，就地展开，避免了频繁的函数调用，性能更加；<h1 id="13、I-O操作"><a href="#13、I-O操作" class="headerlink" title="13、I/O操作"></a>13、I/O操作</h1>stream流操作是读写功能的通用实现，不管数据来自网络、磁盘、程序或键盘，都以相同的方式处理读写操作。</li></ul><h2 id="13-1、C-stream流操作类与控制符"><a href="#13-1、C-stream流操作类与控制符" class="headerlink" title="13.1、C++ stream流操作类与控制符"></a>13.1、C++ stream流操作类与控制符</h2><p><strong>常用stream类</strong></p><ul><li><strong>cout</strong>—标准输出；   </li><li><strong>cin</strong>—标准输入；   </li><li><strong>cerr</strong>—用于显示错误信息的标准输出流；    </li><li><strong>fstream</strong>—文件的输入输出流，集合了ofstream和ifstream；   </li><li><strong>ifstream</strong>—文件的输入流，用于读取文件；   </li><li><strong>ofstream</strong>—文件的输出流，用于写入文件操作；   </li><li><strong>stringstream</strong>—字符串的输入输出流，继承了istringstream和ostringstream，通常用于字符串和其他类型之间的转换；</li></ul><p><strong>常用stream流控制符</strong></p><ul><li>endl—输出换行符；</li><li>ends—输出空字符；</li><li>oct—以八进制形式进行输入输出；</li><li>dec—以十进制形式进行输入输出；</li><li>hex—以十六进制形式进行输入输出；</li><li>fixed—以定点表示法显示数据；</li><li>scientific—以科学表示法显示数据；</li><li>setprecision—设置小数精度；   </li><li>setw—设置字段宽度；   </li><li>setfill—设置填充字符；   </li><li>setbase—设置基数，与dec、hex、oct等效；   </li><li>setiosflag—通过类型为std::io_base::fmtflags的掩码输入参数设置标志；   </li><li>resetiosflag–重置标志；   </li></ul><h3 id="13-1-1、指定整形输出格式"><a href="#13-1-1、指定整形输出格式" class="headerlink" title="13.1.1、指定整形输出格式"></a>13.1.1、指定整形输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int Input &#x3D; 0;   cin &gt;&gt; Input;   cout &lt;&lt; &quot;Integer in octal: &quot; &lt;&lt; oct &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hexadecimal: &quot; &lt;&lt; hex &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer in hex using base notation: &quot;;   cout &lt;&lt; setiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;   cout &lt;&lt; &quot;Integer after resetting I&#x2F;O flags: &quot;;   cout &lt;&lt; resetiosflags(ios_base::hex|ios_base::showbase|ios_base::uppercase);   cout &lt;&lt; Input &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 253    Integer in octal: 375   Integer in hexadecimal: fd   Integer in hex using base notation: 0XFD   Integer after resetting I&#x2F;O flags: 253<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-2、指定浮点型输出格式"><a href="#13-1-2、指定浮点型输出格式" class="headerlink" title="13.1.2、指定浮点型输出格式"></a>13.1.2、指定浮点型输出格式</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;   const double Pi &#x3D; (double)22.0 &#x2F; 7;   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 7: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(7);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Setting precision to 10: &quot; &lt;&lt; endl;   cout &lt;&lt; setprecision(10);   cout &lt;&lt; &quot;Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; fixed &lt;&lt; &quot;Fixed Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; scientific &lt;&lt; &quot;Scientific Pi &#x3D; &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; endl &lt;&lt; &quot;Enter a radius: &quot;;   double Radius &#x3D; 0.0;   cin &gt;&gt; Radius;   cout &lt;&lt; &quot;Area of circle: &quot; &lt;&lt; 2*Pi*Radius*Radius &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Pi&#x3D;3.14286    Setting precision to 7:    Pi&#x3D;3.142857   Fixed Pi &#x3D; 3.1428571    Scientific Pi &#x3D; 3.1428571e+000Setting precision to 10:    Pi&#x3D;3.1428571429e+000   Fixed Pi &#x3D; 3.1428571429  Scientific Pi &#x3D; 3.142857129e+000    Enter a radius:    Area of circle: 6.2731491429e+002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-3、设置文本对齐与宽度"><a href="#13-1-3、设置文本对齐与宽度" class="headerlink" title="13.1.3、设置文本对齐与宽度"></a>13.1.3、设置文本对齐与宽度</h3><p>setw设置字段宽度<br>setfill指定字符填充空白区域</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hey - default!&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and right default, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - right aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nweight length &#x3D; 35, and left, fill with *&quot; &lt;&lt; endl;    cout &lt;&lt; setiosflags(ios::left);    cout &lt;&lt; setw(35) &lt;&lt; setfill(&#39;*&#39;);    cout &lt;&lt; &quot;Hey - left aligned!&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;\nback to default:&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;Hey - back to default!&quot; &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hey - default!weight length &#x3D; 35, and right default               Hey - right aligned!weight length &#x3D; 35, and right default, fill with ****************Hey - right aligned!weight length &#x3D; 35, and left, fill with *Hey - left aligned!****************back to default:Hey - back to default!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-4、cin读取"><a href="#13-1-4、cin读取" class="headerlink" title="13.1.4、cin读取"></a>13.1.4、cin读取</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter an integer: &quot;;   int InputInt &#x3D; 0;   cin &gt;&gt; InputInt;   cout &lt;&lt; &quot;Enter an float: &quot;;   double Pi &#x3D; 0.0;   cin &gt;&gt; Pi;   cout &lt;&lt; &quot;Enter three characters separated by space: &quot; &lt;&lt; endl;   char Char1 &#x3D; &#39;\0&#39;, Char2 &#x3D; &#39;\0&#39;, Char3 &#x3D; &#39;\0&#39;;   cin &gt;&gt; Char1 &gt;&gt; Char2 &gt;&gt; Char3;   cout &lt;&lt; &quot;\nThe recorded variable values are: &quot; &lt;&lt; endl;   cout &lt;&lt; &quot;InputInt: &quot; &lt;&lt; InputInt &lt;&lt; endl;   cout &lt;&lt; &quot;Pi: &quot; &lt;&lt; Pi &lt;&lt; endl;   cout &lt;&lt; &quot;The three characters: &quot; &lt;&lt; Char1 &lt;&lt; Char2 &lt;&lt; Char3 &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter an integer: 123Enter an float: 3.1415926Enter three characters separated by space: a b c    The recorded variable values are: InputInt: 123Pi: 3.14159The three characters: abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><font color=red><strong>读取数组</strong></font><br>可以直接使用cin，但这样存在地址越界的风险，最好使用get函数指定输入长度，避免地址越界</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter a line: &quot; &lt;&lt; endl;   char CStyleStr[10] &#x3D; &#123;0&#125;;   cin.get(CStyleStr, 9);   cout &lt;&lt; &quot;CStyleStr: &quot; &lt;&lt; CStyleStr &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><font color=red><strong>读取字符串</strong></font><br>使用cin读取数据到string时，如果输入流中有空格，cin的读取会停止，所以更好的方法是getline函数</li></ul><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   cout &lt;&lt; &quot;Enter your name: &quot;;   string Name;   getline(cin, Name);   &#x2F;&#x2F; 或者   cin.getline(Name);   cout &lt;&lt; &quot;Hi &quot; &lt;&lt; Name &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-5、fstream文件流操作"><a href="#13-1-5、fstream文件流操作" class="headerlink" title="13.1.5、fstream文件流操作"></a>13.1.5、fstream文件流操作</h3><p>fstream继承了ifstream和ofstream，需包含头文件<fstream></p><pre class="line-numbers language-none"><code class="language-none">fstream myFile;myFile.open(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);  &#x2F;&#x2F; 或者构造函数形式fstream myFile(&quot;hell.txt&quot;, ios_base::in|ios_base::out|ios_base::trunc);if(myFile.is_open())&#123;    &#x2F;&#x2F; do something    myFile.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一个参数为打开文件的路径和名称，未指定路径时，默认为程序当前的执行路径；   </li><li>第二个参数为打开模式，主要有如下几种：   <ul><li>ios_base::app—附加到现有文件末尾，而不是覆盖它；   </li><li>ios_base::ate—切换到文件末尾，但可在文件任何地方写入数据；   </li><li>ios_base::trunc—直接覆盖现有文件，此为默认模式；   </li><li>ios_base::binary—创建二进制文件，默认为文本文件；   </li><li>ios_base::in—以只读方式打开，<strong>注意</strong>：此种打开方式要求文件必须已经存在，否则打开失败；   </li><li>ios_base::out—以只写方式打开；</li></ul></li></ul><p><font color=purple>**&lt;&lt;文本文件写入**</font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;int main()&#123;   ofstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::out);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful&quot; &lt;&lt; endl;      myFile &lt;&lt; &quot;My first text file!&quot; &lt;&lt; endl;      myFile &lt;&lt; &quot;Hello file!&quot;;       cout &lt;&lt; &quot;Finished writing to file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color=purple><strong>&gt;&gt;文本文件读取</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123;   ifstream myFile;   myFile.open(&quot;HelloFile.txt&quot;, ios_base::in);   if (myFile.is_open())   &#123;      cout &lt;&lt; &quot;File open successful. It contains: &quot; &lt;&lt; endl;      string fileContents;      while (myFile.good())      &#123;         getline (myFile, fileContents);       cout &lt;&lt; fileContents &lt;&lt; endl;      &#125;           cout &lt;&lt; &quot;Finished reading file, will close now&quot; &lt;&lt; endl;      myFile.close();   &#125;   else      cout &lt;&lt; &quot;open() failed: check if file is in right folder&quot; &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>good函数用于判断是否到达文件末尾；<br>getline函数逐行读取；   </p><p><font color=purple><strong>二进制文件读写read、write</strong></font></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;#include&lt;iomanip&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;struct Human&#123;Human() &#123;&#125;;   Human(const char* inName, int inAge, const char* inDOB) : Age(inAge)   &#123;      strcpy(Name, inName);      strcpy(DOB, inDOB);   &#125;   char Name[30];   int Age;   char DOB[20];&#125;;int main()&#123;   Human Input(&quot;Siddhartha Rao&quot;, 101, &quot;May 1910&quot;);   ofstream fsOut (&quot;MyBinary.bin&quot;, ios_base::out | ios_base::binary);   if (fsOut.is_open())   &#123;  cout &lt;&lt; &quot;Writing one object of Human to a binary file&quot; &lt;&lt; endl;      fsOut.write(reinterpret_cast&lt;const char*&gt;(&amp;Input), sizeof(Input));      fsOut.close();   &#125;   ifstream fsIn (&quot;MyBinary.bin&quot;, ios_base::in | ios_base::binary);   if(fsIn.is_open())   &#123;      Human somePerson;      fsIn.read((char*)&amp;somePerson, sizeof(somePerson));      cout &lt;&lt; &quot;Reading information from binary file: &quot; &lt;&lt; endl;      cout &lt;&lt; &quot;Name &#x3D; &quot; &lt;&lt; somePerson.Name &lt;&lt; endl;      cout &lt;&lt; &quot;Age &#x3D; &quot; &lt;&lt; somePerson.Age &lt;&lt; endl;      cout &lt;&lt; &quot;Date of Birth &#x3D; &quot; &lt;&lt; somePerson.DOB &lt;&lt; endl;   &#125;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-2、C-stream流操作"><a href="#13-2、C-stream流操作" class="headerlink" title="13.2、C stream流操作"></a>13.2、C stream流操作</h2><h3 id="13-2-1、输出64位整型"><a href="#13-2-1、输出64位整型" class="headerlink" title="13.2.1、输出64位整型"></a>13.2.1、输出64位整型</h3><pre class="line-numbers language-none"><code class="language-none">uint64_t num &#x3D; 0;printf(&quot;%llu&quot;, num);或者printf(&quot;%lld&quot;, num);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-2、输出到数组"><a href="#13-2-2、输出到数组" class="headerlink" title="13.2.2、输出到数组"></a>13.2.2、输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">char src[32];char dst[32];sprintf(dst, &quot;%s&quot;, src);snprintf(dst, sizeof(dst),&quot;%s&quot;, src);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-3、以日期格式输出到数组"><a href="#13-2-3、以日期格式输出到数组" class="headerlink" title="13.2.3、以日期格式输出到数组"></a>13.2.3、以日期格式输出到数组</h3><pre class="line-numbers language-none"><code class="language-none">time_t timeTick &#x3D; time(NULL);char timeStamp[24];strftime(timeStamp, _countof(timeStamp), &quot;%Y-%m-%d %H:%M:%S&quot;, localtime(&amp;timeTick));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-2-4、打开文件"><a href="#13-2-4、打开文件" class="headerlink" title="13.2.4、打开文件"></a>13.2.4、打开文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE *fopen( const char *path, const char *mode );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>函数说明：</strong>   </p><ul><li>path就是指定打开文件的路径，可以是相对路径，也可以绝对路径。mode代表打开文件的方式；</li><li>fopen打开成功，返回FILE的有效地址，失败返回NULL；</li></ul><p><strong>mode模式说明：</strong></p><ul><li><p>r 以只读方式打开文件，该文件必须存在，文件必须是可读的。</p></li><li><p>r+ 以可读写方式打开文件，该文件必须存在。</p></li><li><p>rb+ 读写打开一个二进制文件，允许读写数据，文件必须存在。</p></li><li><p>rw+ 读写打开一个文本文件，允许读和写。</p></li><li><p>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</p></li><li><p>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</p></li><li><p>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。<strong>EOF符保留</strong></p></li><li><p>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<strong>原来的EOF符不保留</strong></p></li></ul><h3 id="13-2-5、输出到文本文件"><a href="#13-2-5、输出到文本文件" class="headerlink" title="13.2.5、输出到文本文件"></a>13.2.5、输出到文本文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;fprintf(pfile, &quot;%d%s%c&quot;, num, strName, nChr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="13-2-6、输出到二进制文件"><a href="#13-2-6、输出到二进制文件" class="headerlink" title="13.2.6、输出到二进制文件"></a>13.2.6、输出到二进制文件</h3><pre class="line-numbers language-none"><code class="language-none">FILE * pfile;uint32_t num;fwrite(&amp;num, sizeof(uint32_t), 1, pfile);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-2-7、rename"><a href="#13-2-7、rename" class="headerlink" title="13.2.7、rename"></a>13.2.7、rename</h3><p>rename重命名或移动文件，但当目的目录下已存在同名文件时，不能被覆盖，被操作文件无法移动，所以操作之前需要检查目的目录下是否存在同名文件。</p><h2 id="13-3、I-O模型"><a href="#13-3、I-O模型" class="headerlink" title="13.3、I/O模型"></a>13.3、I/O模型</h2><p>I/O模型主要涉及两个对象：用户态、内核态。操作系统中I/O相关操作是内核行为，用户态是不能直接进行I/O操作的，比如读取文件、网络、键盘、鼠标、显示器等，用户态程序需要通过系统调用驱使内核态进行I/O操作。<br>同理同步、异步、阻塞、非阻塞也是针对用户态、内核态而言，相关概念参见：<strong>计算机系统.md第2节</strong>；</p><ul><li>同步阻塞I/O：用户态向内核态发起IO请求之后不做任何事情，死等内核返回IO操作结果；</li><li>同步非阻塞I/O：用户态向内核态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，不用死等。</li><li>异步非阻塞：用户态发起IO请求之后，在内核返回IO操作结果之前可以继续做其他事情，且用户态可以同时发起多次IO请求，内核态也可以同时返回多次IO操作结果；</li><li>异步只有非阻塞；</li></ul><h3 id="13-3-1、常见I-O模型"><a href="#13-3-1、常见I-O模型" class="headerlink" title="13.3.1、常见I/O模型"></a>13.3.1、常见I/O模型</h3><ul><li>阻塞状态下，用户态会一直等待内核返回结果，在此期间用户态会持续占有CPU；</li><li>非阻塞状态下，用户态不会一直等待内核返回结果，那么用户是如何接收内核返回的呢？常见的方式有：一通过轮询的方式检查内核是否结束，二是用户态发起请求之后就进入睡眠状态，待内核完成操作后以通知方式唤醒用户态接收；</li></ul><table><thead><tr><th>1、阻塞IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，排队三天买到一张票</td><td></td></tr><tr><td>耗费：在车站吃喝拉撒睡3天，其他事一件没干</td><td></td></tr></tbody></table><table><thead><tr><th>2、非阻塞IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，隔12小时去火车站问有没有票，三天后买到一张票</td><td></td></tr><tr><td>耗费：往返车站6次，路上6小时，其他时间做了好多事</td><td></td></tr></tbody></table><p><font color=red>这既是传统的轮询方式，轮询的不足之处在于不管IO队列之中是否有读写动作的发生，loop都会进行IO队列的遍历操作，这样便会白白浪费CPU资源。</font></p><p><strong>3、I/O复用模型，一共包括两种</strong></p><table><thead><tr><th>3.1、select/poll模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，委托黄牛，黄牛会监视所有车次的余票，然后每隔6小时老李都会电话询问黄牛，看下是否是自己想要的车次，黄牛三天内买到票，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次</td><td></td></tr><tr><td>select模型下黄牛可以监视的车次有限，poll模型下，黄牛可以监视全国范围内的所有车次</td><td></td></tr></tbody></table><p>这个代理可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个去轮询了，伪代码如下： </p><pre class="line-numbers language-none"><code class="language-none">while true  &#123;      select(streams[]) &#x2F;&#x2F;这一步阻塞在这里，直到有一个流有I&#x2F;O事件时，才往下执行      for i in streams[]      &#123;          if i has data          read until unavailable      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是依然有个问题，我们从select那里仅仅知道有I/O事件发生了，却并不知道是哪个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<br>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p><table><thead><tr><th>3.2、epoll模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，委托黄牛，黄牛通过车次编码识别老李需要的车次，黄牛买到后即通知老李去领，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</td><td></td></tr></tbody></table><p>epoll可以理解为event poll，不同于死循环和无差别轮询，epoll会以事件通知的方式反馈指定I/O流是否有事件发生，这样轮询的复杂度降低到了O(1)，伪代码如下：</p><pre class="line-numbers language-none"><code class="language-none">while true  &#123;      active_stream[] &#x3D; epoll_wait(epollfd)      for i in active_stream[]      &#123;          read or write till      &#125;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，select/poll和epoll最大的区别就是：select/poll只是告诉你一定数目的流有事件了，至于哪个流有事件，还得一个个地去轮询，而epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到指定的流。</p><p><font color=red><strong>这里的黄牛相当于代理功能的select/poll，epoll</strong>，这个代理位于内核态，可以同时监控多个IO动作。</font></p><table><thead><tr><th>4、信号驱动IO模型</th><th></th></tr></thead><tbody><tr><td>老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票</td><td></td></tr><tr><td>耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</td><td></td></tr></tbody></table><h3 id="13-3-2、I-O复用的理解"><a href="#13-3-2、I-O复用的理解" class="headerlink" title="13.3.2、I/O复用的理解"></a>13.3.2、I/O复用的理解</h3><p>IO复用产生的原因：<br>如果一个I/O操作到来我们就开启一个task进行处理，那么假设现在有一百万个I/O操作进来，那我们就需要开启一百万个task一一这就是传统意义下的多task并发阻塞处理。思考一下，一百万个task，你的CPU占有会多高，这钟实现方式极其的不合理。所以人们提出了I/O多路复用模型，一个专有task通过记录I/O状态的方式来同时管理多个I/O。</p><p>IO复用的英文单词I/O multiplexing翻译成多路复用其实并不合理，应该理解成将多个task注册的I/O凑在一起交由一个专有task统一管理。注册I/O的task在I/O操作返回之前可以处理其他的事情已到达提升吞吐量的目的，这种涉及模式称作Reactor模式。</p><p>IO复用的实现方式包括：select、poll、epoll</p>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-plus-叁</title>
      <link href="2021/07/10/C-plus-%E5%8F%81/"/>
      <url>2021/07/10/C-plus-%E5%8F%81/</url>
      
        <content type="html"><![CDATA[<h1 id="14、内存对齐"><a href="#14、内存对齐" class="headerlink" title="14、内存对齐"></a>14、内存对齐</h1><p>为什么需要内存对齐？<br>这是因为不是所有硬件平台都能够访问任意位置的内存，考虑到CPU处理内存的方式，比如32位的CPU，一个时钟周期最多可以处理4byte的内存空间，且起始地址一定是偶数。<br>假如将一个4byte的整型存放在奇数内存起始位置上，想把这4个字节读出来，32位的CPU就需要读取两次。<br>但对齐之后，只需要一次读取即可，因为内存对齐之后，数据在内存中的大小将会是4的整数倍。同时此种方式也伴随一个问题，那就是数据在内存之中的存放将不是紧挨着的，而是会出现空隙，这对类似结构体而言，使用sizeof不一定会得到预期的结果。</p><ul><li>内存对齐规则由操作系统 + 编译器共同决定；</li><li>默认对齐系数：32位机一般为4，64位机一般为8；</li></ul><h2 id="14-1、-pragma-pack-k-和-pragma-pack"><a href="#14-1、-pragma-pack-k-和-pragma-pack" class="headerlink" title="14.1、#pragma pack(k)和#pragma pack()"></a>14.1、#pragma pack(k)和#pragma pack()</h2><p>k表示对齐系数，k可以是1,2,3,4,8,16</p><pre class="line-numbers language-none"><code class="language-none">#pragma pack(1) &#x2F;&#x2F;内存对齐设置为1个字节　　struct s1　　&#123;　　　　int i;　　　　char c;　　　　bool f;　　&#125;    &#x2F;&#x2F;struct s2&#123;...&#125;　  &#x2F;&#x2F;...#pragma pack()   &#x2F;&#x2F;恢复默认的内存对齐（与文件开头的指令配对使用）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-2、、-pragma-pack-push-1-和-pragma-pack-pop"><a href="#14-2、、-pragma-pack-push-1-和-pragma-pack-pop" class="headerlink" title="14.2、、#pragma pack(push,1)和#pragma pack(pop)"></a>14.2、、#pragma pack(push,1)和#pragma pack(pop)</h2><pre class="line-numbers language-none"><code class="language-none">　#pragma pack(push,1) &#x2F;&#x2F;内存对齐设置为1个字节　　struct s3　　&#123;　　　　int i;　　　　char c;　　　　bool f;　　&#125;&#x2F;&#x2F;struct s4&#123;...&#125;　  &#x2F;&#x2F;...　#pragma pack(pop)   &#x2F;&#x2F;恢复默认的内存对齐(与文件开头的指令配对使用)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-3、C-11新增对齐关键字"><a href="#14-3、C-11新增对齐关键字" class="headerlink" title="14.3、C++11新增对齐关键字"></a>14.3、C++11新增对齐关键字</h2><pre class="line-numbers language-none"><code class="language-none">#include ＜iostream＞using namespace std;&#x2F;&#x2F;自定义的ColorVector， 对齐到32字节的边界struct alignas(32)ColorVector&#123;double r;double g;double b;double a;&#125;;int main()&#123;&#x2F;&#x2F;使用C++11中的alignof来查询ColorVector的对齐方式cout＜＜&quot;alignof(ColorVector):&quot;＜＜alignof(ColorVector)＜＜endl;return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>alignas(32)设置ColorVector对齐值为32字节；<br>alignof(ColorVector)获取ColorVector的对齐系数；</p><h1 id="15、union共用体-联合体"><a href="#15、union共用体-联合体" class="headerlink" title="15、union共用体/联合体"></a>15、union共用体/联合体</h1><p>union的外形看起来与struct非常类似，但二者的区别确实非常明显的</p><ul><li>struct的成员之间是共存的关系，编译器必须要为每一个成员分配内存（占位符除外，比如零长度的数组），不管是否被使用；</li><li>union的成员是互斥的关系，只有一个成员’有效’；</li></ul><p><font color=red><strong>本质</strong>：<br>所谓union就是在内存中申请一块足够大的内存，即占据内存最大的那个成员类型的空间，然后所有成员类型均使用相同的首地址</font>   </p><p><font color=purple><strong>union的使用场合</strong>：<br>是各数据类型各变量占用空间差不多并且对各变量同时使用要求不高的场合</font>    </p><p>借由union的特性可以判断大小端属性，<strong>大小端概念详见&lt;计算机系统.md第3节&gt;</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;union TEST&#123;    short a;    char b[sizeof(short)];&#125;;int main()&#123;    TEST test;    test.a&#x3D;0x0102;&#x2F;&#x2F; 不能引用共用体变量，只能引用共用体变量中的成员。    if(test.b[0]&#x3D;&#x3D;0x01&amp;&amp;test.b[1]&#x3D;&#x3D;0x02)&#123;        cout&lt;&lt;&quot;big endian.&quot;&lt;&lt;endl;    &#125;    else if(test.b[0]&#x3D;&#x3D;0x02&amp;&amp;test.b[1]&#x3D;&#x3D;0x01)&#123;        cout&lt;&lt;&quot;small endian.&quot;&lt;&lt;endl;    &#125;    else&#123;        cout&lt;&lt;&quot;unknown&quot;&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="16、enum枚举类型"><a href="#16、enum枚举类型" class="headerlink" title="16、enum枚举类型"></a>16、enum枚举类型</h1><h2 id="16-1、普通枚举类型"><a href="#16-1、普通枚举类型" class="headerlink" title="16.1、普通枚举类型"></a>16.1、普通枚举类型</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum Months&#123;Jan, Feb, Mar, Apr, May&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color=red>普通枚举类型的缺陷</font></p><h3 id="16-1-1、缺陷一：enum成员的名字是全局可见的"><a href="#16-1-1、缺陷一：enum成员的名字是全局可见的" class="headerlink" title="16.1.1、缺陷一：enum成员的名字是全局可见的"></a>16.1.1、缺陷一：enum成员的名字是全局可见的</h3><p>C/C++的enum有个很”奇怪”的设定， 就是具名（有名字） 的enum类型的名字，以及enum的成员的名字都是全局可见的。这与C++中具名的namespace、class/struct及union必须通过”名字::成员名”的方式访问相比是格格不入的（namespace等被称为强作用域类型，而enum则是非强作用域类型），比如：</p><pre class="line-numbers language-none"><code class="language-none">enum Type&#123;General,Light,Medium,Heavy&#125;;enum Category&#123;General,Pistol,MachineGun,Cannon&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Category中的General和Type中的General都是全局的名字，编译时会报错。</p><h3 id="16-1-2、缺陷二：可以隐式地转换为整型"><a href="#16-1-2、缺陷二：可以隐式地转换为整型" class="headerlink" title="16.1.2、缺陷二：可以隐式地转换为整型"></a>16.1.2、缺陷二：可以隐式地转换为整型</h3><p>枚举的成员总是可以被隐式地转换为整型，如上面的例子，General总是可以被隐式的转换为整型值0</p><h3 id="16-1-3、缺陷三：占用的空间大小是一个”不确定量”"><a href="#16-1-3、缺陷三：占用的空间大小是一个”不确定量”" class="headerlink" title="16.1.3、缺陷三：占用的空间大小是一个”不确定量”"></a>16.1.3、缺陷三：占用的空间大小是一个”不确定量”</h3><p>C++枚举所基于的”基础类型”是由编译器来决定的，这会导致枚举类型成员的基本类型的不确定性问题，例如：</p><pre class="line-numbers language-none"><code class="language-none">#include ＜iostream＞using namespace std;enum D&#123;D1&#x3D;1,D2&#x3D;2,Dbig&#x3D;0xFFFFFFF0U&#125;;enum E&#123;E1&#x3D;1,E2&#x3D;2,Ebig&#x3D;0xFFFFFFFFFLL&#125;;int main()&#123;cout＜＜Dbig＜＜endl;&#x2F;&#x2F;编译器输出不同,g++： 4294967280cout＜＜sizeof(D1)＜＜endl;&#x2F;&#x2F;4cout＜＜sizeof(Dbig)＜＜endl;&#x2F;&#x2F;4cout＜＜Ebig＜＜endl;&#x2F;&#x2F;68719476735cout＜＜sizeof(E1)＜＜endl;&#x2F;&#x2F;8return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-2、强枚举类型"><a href="#16-2、强枚举类型" class="headerlink" title="16.2、强枚举类型"></a>16.2、强枚举类型</h2><p>声明强类型枚举非常简单，只需要在enum后加上关键字class。比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum class Type&#123;General,Light,Medium,Heavy&#125;;&#x2F;&#x2F; 例如enum class Months:int&#123;Jan, Feb, Mar, Apr, May&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间，即不能直接被全局可见；</li><li>转换限制， 强类型枚举成员的值不可以与整型隐式地相互转换；</li><li>可以指定底层基础类型，强类型枚举默认的底层类型为int,但也可以显式地指定底层类型， 具体方法为在枚举名称后面加上”：type”，其中type可以是除wchar_t以外的任何整型；<br>如：</li></ul><pre class="line-numbers language-none"><code class="language-none">enum class Type:char&#123;General,Light,Medium,Heavy&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include ＜iostream＞using namespace std;enum class Type&#123;General,Light,Medium,Heavy&#125;;enum class Category&#123;General&#x3D;1,Pistol,MachineGun,Cannon&#125;;int main()&#123;Type t&#x3D;Type::Light;t&#x3D;General;&#x2F;&#x2F;编译失败， 必须使用强类型名称if(t&#x3D;&#x3D;Category::General)&#x2F;&#x2F;编译失败， 必须使用Type中的Generalcout＜＜&quot;General Weapon&quot;＜＜endl;if(t＞Type::General)&#x2F;&#x2F;通过编译cout＜＜&quot;Not General Weapon&quot;＜＜endl;if(t＞0)&#x2F;&#x2F;编译失败， 无法转换为int类型cout＜＜&quot;Not General Weapon&quot;＜＜endl;if((int)t＞0)&#x2F;&#x2F;通过编译cout＜＜&quot;Not General Weapon&quot;＜＜endl;cout＜＜is_pod＜Type＞::value＜＜endl;&#x2F;&#x2F;1cout＜＜is_pod＜Category＞::value＜＜endl;&#x2F;&#x2F;1return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> summary &amp;&amp; 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
